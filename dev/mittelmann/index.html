<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A generalized Bratu–Gelfand problem in two dimensions · Bifurcation Analysis in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Bifurcation Analysis in Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guidelines/">Overview</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (codim 2)</a></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf point</a></li></ul></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated Continuation</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problem</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><input class="collapse-toggle" id="menuitem-4-11" type="checkbox"/><label class="tocitem" for="menuitem-4-11"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitFD/">Finite Differences</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear / Eigen Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>A generalized Bratu–Gelfand problem in two dimensions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A generalized Bratu–Gelfand problem in two dimensions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/BifurcationKit.jl/blob/master/docs/src/mittelmann.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="A-generalized-Bratu–Gelfand-problem-in-two-dimensions-1"><a class="docs-heading-anchor" href="#A-generalized-Bratu–Gelfand-problem-in-two-dimensions-1">A generalized Bratu–Gelfand problem in two dimensions</a><a class="docs-heading-anchor-permalink" href="#A-generalized-Bratu–Gelfand-problem-in-two-dimensions-1" title="Permalink"></a></h1><ul><li><a href="#A-generalized-Bratu–Gelfand-problem-in-two-dimensions-1">A generalized Bratu–Gelfand problem in two dimensions</a></li><ul><li><a href="#Branch-of-homogenous-solutions-1">Branch of homogenous solutions</a></li></ul><li><a href="#sampling-grid-1">sampling grid</a></li><li><a href="#sample-reduced-equation-on-the-grid-for-the-first-component-1">sample reduced equation on the grid for the first component</a></li><li><a href="#intersect-with-second-component-1">intersect with second component</a></li><li><a href="#get-solutions-1">get solutions</a></li><li><a href="#deflation-operator-to-1">deflation operator to</a></li><li><a href="#options-for-the-newton-solver-1">options for the newton solver</a></li><li><a href="#eigen-elements-close-to-the-second-bifurcation-point-on-the-branch-1">eigen-elements close to the second bifurcation point on the branch</a></li><li><a href="#of-homogenous-solutions-1">of homogenous solutions</a></li></ul><div class="admonition is-category-unknown"><header class="admonition-header">References</header><div class="admonition-body"><p>The following example is exposed in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. <strong>The Computation of Disconnected Bifurcation Diagrams.</strong> ArXiv:1603.00809 [Math], March 2, 2016.</p></div></div><p>We consider the problem of Mittelmann:</p><div>\[\Delta u +NL(\lambda,u) = 0\]</div><p>with Neumann boundary condition on <span>$\Omega = (0,1)^2$</span> and where <span>$NL(\lambda,u)\equiv-10(u-\lambda e^u)$</span>. This is a good example to show how automatic branch switching works and also nonlinear deflation.</p><p>We start with some imports:</p><pre><code class="language-julia">using Revise
using DiffEqOperators, ForwardDiff
using BifurcationKit, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield
const BK = BifurcationKit

# define the sup norm and a L2 norm
norminf = x -&gt; norm(x, Inf)
normbratu = x-&gt; norm(x) / sqrt(length(x))

# some plotting function to simplify our life
plotsol!(x, nx = Nx, ny = Ny; kwargs...) = heatmap!(reshape(x, nx, ny); color = :viridis, kwargs...)
plotsol(x, nx = Nx, ny = Ny; kwargs...) = (plot();plotsol!(x, nx, ny; kwargs...))</code></pre><p>and with the discretization of the problem</p><pre><code class="language-julia">function Laplacian2D(Nx, Ny, lx, ly, bc = :Neumann)
	hx = 2lx/Nx
	hy = 2ly/Ny
	D2x = CenteredDifference(2, 2, hx, Nx)
	D2y = CenteredDifference(2, 2, hy, Ny)

	Qx = Neumann0BC(hx)
	Qy = Neumann0BC(hy)

	D2xsp = sparse(D2x * Qx)[1]
	D2ysp = sparse(D2y * Qy)[1]
	A = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))
	return A
end

ϕ(u, λ)  = -10(u-λ*exp(u))
dϕ(u, λ) = -10(1-λ*exp(u))

function NL!(dest, u, p)
	@unpack λ = p
	dest .= ϕ.(u, λ)
	return dest
end

NL(u, p) = NL!(similar(u), u, p)

function Fmit!(f, u, p)
	mul!(f, p.Δ, u)
	f .= f .+ NL(u, p)
	return f
end

Fmit(u, p) = Fmit!(similar(u), u, p)</code></pre><p>It will also prove useful to have the jacobian of our functional: </p><pre><code class="language-julia">function JFmit(x,p)
	J = p.Δ
	dg = dϕ.(x, p.λ)
	return J + spdiagm(0 =&gt; dg)
end</code></pre><p>We need to pass the parameters associated to this problem:</p><pre><code class="language-julia">Nx = 30
Ny = 30
lx = 0.5
ly = 0.5

Δ = Laplacian2D(Nx, Ny, lx, ly)
par_mit = (λ = .05, Δ = Δ)

# initial guess f for newton
sol0 = zeros(Nx, Ny) |&gt; vec</code></pre><p>To compute the eigenvalues, we opt for the shift-invert strategy with shift <code>=0.5</code></p><pre><code class="language-julia"># eigensolver
eigls = EigKrylovKit(dim = 70)

# options for Newton solver
opt_newton = BK.NewtonPar(tol = 1e-8, verbose = true, eigsolver = eigls, maxIter = 20)

# options for continuation
opts_br = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds = 0.01, pMax = 3.5, pMin = 0.025,
	detectBifurcation = 3, nev = 30, plotEveryStep = 10, newtonOptions = (@set opt_newton.verbose = true), 
	maxSteps = 100, precisionStability = 1e-6, nInversion = 4, dsminBisection = 1e-7, maxBisectionSteps = 25)</code></pre><p>Note that we put the option <code>detectBifurcation = 3</code> to detect bifurcations precisely with a bisection method. Indeed, we need to locate these branch points precisely to be able to call automatic branch switching.</p><h2 id="Branch-of-homogenous-solutions-1"><a class="docs-heading-anchor" href="#Branch-of-homogenous-solutions-1">Branch of homogenous solutions</a><a class="docs-heading-anchor-permalink" href="#Branch-of-homogenous-solutions-1" title="Permalink"></a></h2><p>At this stage, we note that the problem has a curve of homogenous (constant in space) solutions <span>$u_h$</span> solving <span>$N(\lambda, u_h)=0$</span>. We shall compute this branch now.</p><p>We can now call <code>continuation</code> with the initial guess <code>sol0</code> which is homogenous, thereby generating homogenous solutions:</p><pre><code class="language-julia">br, = @time BK.continuation(
	Fmit, JFmit,
	sol0, par_mit, (@lens _.λ), opts_br;
	printSolution = (x, p) -&gt; normbratu(x),
	plotSolution = (x, p; kwargs...) -&gt; plotsol!(x ; kwargs...),
	plot = true, verbosity = 3, normC = norminf)</code></pre><p>You should see the following result:</p><p><img src="../mittlemann1.png" alt/></p><p>Several branch point were detected as can be seen using the command</p><pre><code class="language-julia">julia&gt; br
Branch number of points: 84
Branch of Equilibrium
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,      bp at p ≈ 0.36787944 ± 2e-10, step =  18, eigenelements in eig[ 19], ind_ev =   1 [converged], δ = ( 1,  0), bifurcation ∈ (0.36787944, 0.36787944)
- #  2,      nd at p ≈ 0.27255474 ± 5e-06, step =  33, eigenelements in eig[ 34], ind_ev =   3 [converged], δ = ( 2,  0), bifurcation ∈ (0.27255937, 0.27255474)
- #  3,      bp at p ≈ 0.15215124 ± 7e-06, step =  48, eigenelements in eig[ 49], ind_ev =   4 [converged], δ = ( 1,  0), bifurcation ∈ (0.15215818, 0.15215124)
- #  4,      nd at p ≈ 0.03551852 ± 3e-05, step =  76, eigenelements in eig[ 77], ind_ev =   6 [converged], δ = ( 2,  0), bifurcation ∈ (0.03554981, 0.03551852)
Fold points:
- #  1,    fold at p ≈ 0.36787944, step =  19, eigenelements in eig[ 19], ind_ev =   0 [    guess]```

We notice several simple bifurcation points for which the dimension of the kernel of the jacobian is one dimensional. In the above box, `δ = ( 1,  0)` gives the change in the stability. In this case, there is one vector in the kernel which is real. The bifurcation point 2 has a 2d kernel and is thus not amenable to automatic branch switching.

## Automatic branch switching at simple branch points

To be able to perform branch switching, we need to pass the differentials of our functional. Using automatic differentiation, this is not a big deal:
</code></pre><p>julia D(f, x, p, dx) = ForwardDiff.derivative(t-&gt;f(x .+ t .* dx, p), 0.)</p><p>d1Fmit(x,p,dx1) = D((z, p0) -&gt; Fmit(z, p0), x, p, dx1) d2Fmit(x,p,dx1,dx2) = D((z, p0) -&gt; d1Fmit(z, p0, dx1), x, p, dx2) d3Fmit(x,p,dx1,dx2,dx3) = D((z, p0) -&gt; d2Fmit(z, p0, dx1, dx2), x, p, dx3)</p><pre><code class="language-none">
It is convenient to define the jet of `Fmit`
</code></pre><p>julia jet = (Fmit, JFmit, d2Fmit, d3Fmit)</p><pre><code class="language-none">
We can now compute the branch off the third bifurcation point:
</code></pre><p>julia br1, = continuation(jet..., br, 3,  	setproperties(opts_br;ds = 0.001, maxSteps = 40); 	verbosity = 3, plot = true, 	printSolution = (x, p) -&gt; normbratu(x), 	plotSolution = (x, p; kwargs...) -&gt; plotsol!(x ; kwargs...), 	normC = norminf)</p><pre><code class="language-none">
and you should see:

![](mittlemann2.png)

You can also plot the two branches together `plot([br,br1],plotfold=false)` and get

![](mittlemann3.png)

We continue our journey and compute the branch bifurcating of the first bifurcation point from the last branch we computed:
</code></pre><p>julia br2, = continuation(jet..., br1, 1,  	setproperties(opts_br;ds = 0.001, maxSteps = 40); 	verbosity = 3, plot = true, 	printSolution = (x, p) -&gt; norm(x), 	plotSolution = (x, p; kwargs...) -&gt; plotsol!(x ; kwargs...), normC = norminf)</p><pre><code class="language-none">
![](mittlemann4.png)

## Analysis at the 2d-branch points (manual)

The second bifurcation point on the branch `br` of homogenous solutions has a 2d kernel. We don&#39;t provide automatic branch switching but we provide two methods to deal with such case
- automatic local bifurcation diagram (see below)
- branch switching with deflation (see next section)

We provide a generic way to study branch points of arbitrary dimensions by computing a reduced equation. The general method is based on a Lyapunov-Schmidt reduction. We can compute the information about the branch point using the generic function (valid for simple branch points, Hopf bifurcation points,...)
</code></pre><p>julia bp2d = BK.computeNormalForm(jet..., br, 2;  verbose=true, nev = 50)</p><pre><code class="language-none">
You can print the 2d reduced equation as follows. Note that this is a multivariate polynomials. For more information, see [Non-simple branch point](@ref).
</code></pre><p>julia julia&gt; BK.nf(bp2d) 2-element Array{String,1}:  &quot; + (-73.897) * x1 ⋅ p + (-0.0012) ⋅ x1³ + (0.003) ⋅ x1 ⋅ x2²&quot;  &quot; + (0.003) ⋅ x1² ⋅ x2 + (-73.897) * x2 ⋅ p + (-0.0012) ⋅ x2³&quot;</p><pre><code class="language-none">
You can evaluate this polynomial as follows `bp2d(Val(:reducedForm),[0.1,0.2], 0.01)` which returns a 2d vector or `bp2d([0.1,0.2], 0.01)`. This last expression actually returns a vector corresponding to the PDE problem.

You need to solve these equations to compute the bifurcation diagram in the neighborhood of the bifurcation point. In the present case, we do it using brute force. We suggest to use `IntervalConstraintProgramming.jl` for a more precise way.
</code></pre><p>julia using ProgressMeter Nd = 200; L = 0.9</p><h1 id="sampling-grid-1"><a class="docs-heading-anchor" href="#sampling-grid-1">sampling grid</a><a class="docs-heading-anchor-permalink" href="#sampling-grid-1" title="Permalink"></a></h1><p>X = LinRange(-L,L, Nd); Y = LinRange(-L,L, Nd); P = LinRange(-0.0001,0.0001, Nd+1)</p><h1 id="sample-reduced-equation-on-the-grid-for-the-first-component-1"><a class="docs-heading-anchor" href="#sample-reduced-equation-on-the-grid-for-the-first-component-1">sample reduced equation on the grid for the first component</a><a class="docs-heading-anchor-permalink" href="#sample-reduced-equation-on-the-grid-for-the-first-component-1" title="Permalink"></a></h1><p>V1a = @showprogress [bp2d(Val(:reducedForm),[x1,y1], p1)[1] for p1 in P, x1 in X, y1 in Y] Ind1 = findall( abs.(V1a) .&lt;= 9e-4 * maximum(abs.(V1a)))</p><h1 id="intersect-with-second-component-1"><a class="docs-heading-anchor" href="#intersect-with-second-component-1">intersect with second component</a><a class="docs-heading-anchor-permalink" href="#intersect-with-second-component-1" title="Permalink"></a></h1><p>V2a = @showprogress [bp2d(Val(:reducedForm),[X[ii[2]],Y[ii[3]]], P[ii[1]])[2] for ii in Ind1] Ind2 = findall( abs.(V2a) .&lt;= 3e-3 * maximum(abs.(V2a)))</p><h1 id="get-solutions-1"><a class="docs-heading-anchor" href="#get-solutions-1">get solutions</a><a class="docs-heading-anchor-permalink" href="#get-solutions-1" title="Permalink"></a></h1><p>resp = Float64[]; resx = Vector{Float64}[]; resnrm = Float64[] 	@showprogress for k in Ind2 		ii = Ind1[k] 		push!(resp, P[ii[1]]) 		push!(resnrm, sqrt(X[ii[2]]^2+Y[ii[3]]^2)) 		push!(resx, [X[ii[2]], Y[ii[3]]]) 	end</p><pre><code class="language-none">
We can now plot the local bifurcation diagram as follows
</code></pre><p>julia using LaTeXStrings plot( 	scatter(1e4resp, map(x-&gt;x[1], resx), map(x-&gt;x[2], resx); label = &quot;&quot;, markerstrokewidth=0, xlabel = L&quot;10^4 \cdot \lambda&quot;, ylabel = L&quot;x<em>1&quot;, zlabel = L&quot;x</em>2&quot;, zcolor = resnrm, color = :viridis,colorbar=false), 	scatter(1e4resp, resnrm; label = &quot;&quot;, markersize =2, markerstrokewidth=0, xlabel = L&quot;10^4 \cdot \lambda&quot;, ylabel = L&quot;\|x\|&quot;))</p><pre><code class="language-none">![](mittlemann4a.png)

&gt; This looks like a Pitchfork bifurcation with D4 symmetry

We can see that there are two types of solutions. After the bifurcation point, the solutions are of the form $(x_1,x_2) = (\pm x,\pm x)$ for some real $x$. Before the bifurcation point, the solutions are of the form $(x_1,x_2) = (\pm x,0), (0, \pm x)$ for some real $x$. Here is an example `plotsol(bp2d(resx[10], resp[10]))`

![](mittlemann4b.png)

We could use the solutions saved in `resp, resx` as initial guesses for a call to `continuation` but we turn to a different method.

!!! tip &quot;Solutions&quot;
    The brute force method provided all solutions in a neighborhood of the bifurcation point.
    
    
!!! info &quot;Advanced computation&quot;
    Instead of using brute force and computing the vector field on a grid. One can rely on `IntervalConstraintProgramming.jl` to do better using bisection. See also this [discourse post](https://discourse.julialang.org/t/nd-level-sets/38532/13) where the same example is treated by D. P. Sanders.    

## Branch switching with deflated newton (manual)

At this stage, we know what happens at the 2d bifurcation point of the curve of homogenous solutions. We chose another method based on [Deflated problems](@ref). We want to find all nearby solutions of the problem close to this bifurcation point. This is readily done by trying several initial guesses in a brute force manner:
</code></pre><p>julia</p><p>out = zeros(Nx*Ny)</p><h1 id="deflation-operator-to-1"><a class="docs-heading-anchor" href="#deflation-operator-to-1">deflation operator to</a><a class="docs-heading-anchor-permalink" href="#deflation-operator-to-1" title="Permalink"></a></h1><p>deflationOp = DeflationOperator(2.0, (x, y) -&gt; dot(x, y), 1.0, [zeros(Nx*Ny)])</p><h1 id="options-for-the-newton-solver-1"><a class="docs-heading-anchor" href="#options-for-the-newton-solver-1">options for the newton solver</a><a class="docs-heading-anchor-permalink" href="#options-for-the-newton-solver-1" title="Permalink"></a></h1><p>optdef = setproperties(opt_newton; tol = 1e-8, maxIter = 100)</p><h1 id="eigen-elements-close-to-the-second-bifurcation-point-on-the-branch-1"><a class="docs-heading-anchor" href="#eigen-elements-close-to-the-second-bifurcation-point-on-the-branch-1">eigen-elements close to the second bifurcation point on the branch</a><a class="docs-heading-anchor-permalink" href="#eigen-elements-close-to-the-second-bifurcation-point-on-the-branch-1" title="Permalink"></a></h1><h1 id="of-homogenous-solutions-1"><a class="docs-heading-anchor" href="#of-homogenous-solutions-1">of homogenous solutions</a><a class="docs-heading-anchor-permalink" href="#of-homogenous-solutions-1" title="Permalink"></a></h1><p>vp, ve, <em>, _= eigls(JFmit(out, @set par</em>mit.λ = br.bifpoint[2].param), 5)</p><p>for ii=1:length(ve) 		outdef1, <em>, flag, _ = @time newton( 			Fmit, JFmit, 			# initial guess for newton 			br.bifpoint[2].x .+ 0.01 .*  real.(ve[ii]) .* (1 .+ 0.01 .* rand(Nx*Ny)), 			(@set par</em>mit.λ = br.bifpoint[2].param + 0.005), 			optdef, deflationOp) 			flag &amp;&amp; push!(deflationOp, outdef1) 	end</p><pre><code class="language-none">
This provides `length(deflationOp) = 5` solutions as there are some symmetries in the problem. For example `plotsol(deflationOp[5])` gives

![](mittlemann5.png)

We can continue this solution as follows in one direction
</code></pre><p>julia brdef1, _ = @time BK.continuation( 	Fmit, JFmit, 	deflationOp[3], (@set par<em>mit.λ = br.bifpoint[2].param + 0.005), (@lens _.λ), 	setproperties(opts</em>br;ds = -0.001, detectBifurcation = 3, dsmax = 0.01, maxSteps = 500); 	verbosity = 3, plot = true, 	printSolution = (x, p) -&gt; norm(x), 	plotSolution = (x, p; kwargs...) -&gt; plotsol!(x ; kwargs...), normC = norminf)</p><pre><code class="language-none">
If we repeat the above loop but before the branch point by using `@set par_mit.λ = br.bifpoint[2].param + 0.005`, we get 3 new solutions that we can continue
</code></pre><p>julia brdef2, _ = @time BK.continuation( 	Fmit, JFmit, 	deflationOp[5], (@set par<em>mit.λ = br.bifpoint[2].param + 0.005), (@lens _.λ), 	setproperties(opts</em>br;ds = 0.001, detectBifurcation = 3, dsmax = 0.01); 	verbosity = 3, plot = true, 	printSolution = (x, p) -&gt; norm(x), 	plotSolution = (x, p; kwargs...) -&gt; plotsol!(x ; kwargs...), normC = norminf)</p><pre><code class="language-none">
thereby providing the following bifurcation diagram with `plot([br,br1,br2,brdef1, brdef2],plotfold=false, putbifptlegend = false)`

![](mittlemann6.png)

## Automatic branch switching at the 2d-branch points

We now show how to perform automatic branch switching at the nonsimple branch points. However, we think it is important that the user is able to use the previous tools in case automatic branch switching fails.

The call for automatic branch switching is the same as in the case of simple branch points (see above) except that many branches are returned.
</code></pre><p>julia branches, = continuation(jet..., br, 2, 	setproperties(opts_br; detectBifurcation = 3, ds = 0.001, pMin = 0.01, maxSteps = 32 ) ; 	nev = 30, verbosity = 3,	 	plot = true, 	plotSolution = (x, p; k...) -&gt;(plotsol!(x; k...); plot!(br,subplot=1)), 	tangentAlgo = BorderedPred() 	)</p><pre><code class="language-none">
You can plot the branches using `plot(branches)`. The branches are as follows

</code></pre><p>julia julia&gt; branches 8-element Array{Branch,1}:   Branch number of points: 33 Branch of Equilibrium from NonSimpleBranchPoint bifurcation point. Bifurcation points:  (ind<em>ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind</em>ev]`)</p><ul><li><h1>1,      bp at p ≈ 0.27255723 ± 7e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255723, 0.27255723)</h1></li><li><h1>2,      bp at p ≈ 0.14414814 ± 9e-05, step =  24, eigenelements in eig[ 25], ind_ev =   3 [converged], δ = ( 1,  0), bifurcation ∈ (0.14424073, 0.14414814)</h1></li></ul><p>Fold points:</p><ul><li><h1>1,    fold at p ≈ 0.27255723, step =   2, eigenelements in eig[  2], ind_ev =   0 [    guess]</h1></li></ul><p>Branch number of points: 33 Branch of Equilibrium from NonSimpleBranchPoint bifurcation point. Bifurcation points:  (ind<em>ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind</em>ev]`)</p><ul><li><h1>1,      bp at p ≈ 0.27255723 ± 7e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255723, 0.27255723)</h1></li><li><h1>2,      bp at p ≈ 0.14414814 ± 9e-05, step =  24, eigenelements in eig[ 25], ind_ev =   3 [converged], δ = ( 1,  0), bifurcation ∈ (0.14424073, 0.14414814)</h1></li></ul><p>Fold points:</p><ul><li><h1>1,    fold at p ≈ 0.27255723, step =   2, eigenelements in eig[  2], ind_ev =   0 [    guess]</h1></li></ul><p>Branch number of points: 33 Branch of Equilibrium from NonSimpleBranchPoint bifurcation point. Bifurcation points:  (ind<em>ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind</em>ev]`)</p><ul><li><h1>1,      bp at p ≈ 0.27255723 ± 7e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255723, 0.27255723)</h1></li><li><h1>2,      bp at p ≈ 0.14414816 ± 9e-05, step =  24, eigenelements in eig[ 25], ind_ev =   3 [converged], δ = ( 1,  0), bifurcation ∈ (0.14424075, 0.14414816)</h1></li></ul><p>Fold points:</p><ul><li><h1>1,    fold at p ≈ 0.27255723, step =   2, eigenelements in eig[  2], ind_ev =   0 [    guess]</h1></li></ul><p>Branch number of points: 33 Branch of Equilibrium from NonSimpleBranchPoint bifurcation point. Bifurcation points:  (ind<em>ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind</em>ev]`)</p><ul><li><h1>1,      bp at p ≈ 0.27255723 ± 7e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255723, 0.27255723)</h1></li><li><h1>2,      bp at p ≈ 0.14414814 ± 9e-05, step =  24, eigenelements in eig[ 25], ind_ev =   3 [converged], δ = ( 1,  0), bifurcation ∈ (0.14424073, 0.14414814)</h1></li></ul><p>Fold points:</p><ul><li><h1>1,    fold at p ≈ 0.27255723, step =   2, eigenelements in eig[  2], ind_ev =   0 [    guess]</h1></li></ul><p>Branch number of points: 33 Branch of Equilibrium from NonSimpleBranchPoint bifurcation point. Bifurcation points:  (ind<em>ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind</em>ev]`)</p><ul><li><h1>1,      bp at p ≈ 0.27255724 ± 9e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255724, 0.27255724)</h1></li><li><h1>2,      bp at p ≈ 0.27868730 ± 3e-08, step =  15, eigenelements in eig[ 16], ind_ev =   2 [converged], δ = (-1,  0), bifurcation ∈ (0.27868728, 0.27868730)</h1></li></ul><p>Fold points:</p><ul><li><h1>1,    fold at p ≈ 0.27868730, step =  16, eigenelements in eig[ 16], ind_ev =   0 [    guess]</h1></li></ul><p>Branch number of points: 33 Branch of Equilibrium from NonSimpleBranchPoint bifurcation point. Bifurcation points:  (ind<em>ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind</em>ev]`)</p><ul><li><h1>1,      bp at p ≈ 0.27255724 ± 9e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255724, 0.27255724)</h1></li><li><h1>2,      bp at p ≈ 0.27868730 ± 3e-08, step =  15, eigenelements in eig[ 16], ind_ev =   2 [converged], δ = (-1,  0), bifurcation ∈ (0.27868728, 0.27868730)</h1></li></ul><p>Fold points:</p><ul><li><h1>1,    fold at p ≈ 0.27868730, step =  16, eigenelements in eig[ 16], ind_ev =   0 [    guess]</h1></li></ul><p>Branch number of points: 33 Branch of Equilibrium from NonSimpleBranchPoint bifurcation point. Bifurcation points:  (ind<em>ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind</em>ev]`)</p><ul><li><h1>1,      bp at p ≈ 0.27255724 ± 9e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255724, 0.27255724)</h1></li><li><h1>2,      bp at p ≈ 0.27868730 ± 3e-08, step =  15, eigenelements in eig[ 16], ind_ev =   2 [converged], δ = (-1,  0), bifurcation ∈ (0.27868728, 0.27868730)</h1></li></ul><p>Fold points:</p><ul><li><h1>1,    fold at p ≈ 0.27868730, step =  16, eigenelements in eig[ 16], ind_ev =   0 [    guess]</h1></li></ul><p>Branch number of points: 33 Branch of Equilibrium from NonSimpleBranchPoint bifurcation point. Bifurcation points:  (ind<em>ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind</em>ev]`)</p><ul><li><h1>1,      bp at p ≈ 0.27255724 ± 9e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255724, 0.27255724)</h1></li><li><h1>2,      bp at p ≈ 0.27868730 ± 3e-08, step =  15, eigenelements in eig[ 16], ind_ev =   2 [converged], δ = (-1,  0), bifurcation ∈ (0.27868728, 0.27868730)</h1></li></ul><p>Fold points:</p><ul><li><h1>1,    fold at p ≈ 0.27868730, step =  16, eigenelements in eig[ 16], ind_ev =   0 [    guess]</h1></li></ul><p>```</p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 18 September 2020 21:24">Friday 18 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
