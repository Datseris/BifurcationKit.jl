<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4/ The Swift-Hohenberg on the GPU (non-local) · Pseudo Arc Length Continuation in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Pseudo Arc Length Continuation in Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials1/">1/ Temperature model</a></li><li><a class="tocitem" href="../tutorials1b/">2/ Temperature model with Spectral Collocation</a></li><li><a class="tocitem" href="../tutorials2/">3/ Swift-Hohenberg</a></li><li class="is-active"><a class="tocitem" href>4/ The Swift-Hohenberg on the GPU (non-local)</a><ul class="internal"><li><a class="tocitem" href="#Computing-the-inverse-of-the-differential-operator-1"><span>Computing the inverse of the differential operator</span></a></li><li><a class="tocitem" href="#Linear-Algebra-on-the-GPU-1"><span>Linear Algebra on the GPU</span></a></li><li><a class="tocitem" href="#Newton-iterations-and-deflation-1"><span>Newton iterations and deflation</span></a></li><li><a class="tocitem" href="#Computation-of-the-branches-1"><span>Computation of the branches</span></a></li></ul></li><li><a class="tocitem" href="../tutorials3/">5/ Brusselator 1d</a></li><li><a class="tocitem" href="../tutorialsPD/">6/ Period Doubling in BVAM model</a></li><li><a class="tocitem" href="../tutorialsCGL/">7/ Ginzburg-Landau 2d (GPU)</a></li><li><a class="tocitem" href="../tutorialsCGLShoot/">8/ Ginzburg-Landau 2d (Shooting)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Advanced Usage</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li><li><a class="tocitem" href="../linearsolver/">Linear / Eigen Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../detectionBifurcation/">Bifurcations</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><a class="tocitem" href="../periodicOrbitFD/">Periodic Orbits (Finite Differences)</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Periodic Orbits (Shooting)</a></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>4/ The Swift-Hohenberg on the GPU (non-local)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>4/ The Swift-Hohenberg on the GPU (non-local)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/master/docs/src/tutorials2b.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Swift-Hohenberg-equation-on-the-GPU-1"><a class="docs-heading-anchor" href="#The-Swift-Hohenberg-equation-on-the-GPU-1">The Swift-Hohenberg equation on the GPU</a><a class="docs-heading-anchor-permalink" href="#The-Swift-Hohenberg-equation-on-the-GPU-1" title="Permalink"></a></h1><p>Here we give an example where the continuation can be done <strong>entirely</strong> on the GPU, <em>e.g.</em> on a single Tesla K80.</p><p>We choose the 2d Swift-Hohenberg as an example and consider a larger grid. See <a href="../tutorials2/#Snaking-in-the-2d-Swift-Hohenberg-equation-1">Snaking in the 2d Swift-Hohenberg equation</a> for more details. Solving the sparse linear problem in <span>$v$</span></p><div>\[-(I+\Delta)^2 v+(l +2\nu u-3u^2)v = rhs\]</div><p>with a <strong>direct</strong> solver becomes prohibitive. Looking for an iterative method, the conditioning of the jacobian is not good enough to have fast convergence, mainly because of the Laplacian operator. However, the above problem is equivalent to:</p><div>\[-v + L \cdot (d \cdot v) = L\cdot rhs\]</div><p>where</p><div>\[L := ((I+\Delta)^2 + I)^{-1}\]</div><p>is very well conditioned and</p><div>\[d := l+1+2\nu v-3v^2.\]</div><p>Hence, to solve the previous equation, only a <strong>few</strong> GMRES iterations are required.</p><blockquote><p>In effect, the preconditioned PDE is an example of nonlocal problem.</p></blockquote><h2 id="Computing-the-inverse-of-the-differential-operator-1"><a class="docs-heading-anchor" href="#Computing-the-inverse-of-the-differential-operator-1">Computing the inverse of the differential operator</a><a class="docs-heading-anchor-permalink" href="#Computing-the-inverse-of-the-differential-operator-1" title="Permalink"></a></h2><p>The issue now is to compute <span>$L$</span> but this is easy using Fourier transforms.</p><p>Hence, that&#39;s why we slightly modify the previous Example by considering <strong>periodic</strong> boundary conditions. Let us now show how to compute <span>$L$</span>. Although the code looks quite technical, it is based on two facts. First, the Fourier transform symbol associated to <span>$L$</span> is</p><div>\[l_1 = 1+(1-k_x^2-k_y^2)^2\]</div><p>which is pre-computed in the composite type <code>SHLinearOp</code>. Then, the effect of <code>L</code> on <code>u</code> is as simple as <code>real.(ifft( l1 .* fft(u) ))</code> and the inverse <code>L\u</code> is <code>real.(ifft( fft(u) ./ l1 ))</code>. However, in order to save memory on the GPU, we use inplace FFTs to reduce temporaries which explains the following code.</p><pre><code class="language-julia">using Revise
using AbstractFFTs, FFTW, KrylovKit, Setfield, Parameters
using PseudoArcLengthContinuation, LinearAlgebra, Plots
const PALC = PseudoArcLengthContinuation

# the following struct encodes the operator L1
# Making the linear operator a subtype of PALC.AbstractLinearSolver is handy as it will be used
# in the Newton iterations.
struct SHLinearOp{Treal, Tcomp, Tl1, Tplan, Tiplan} &lt;: PALC.AbstractLinearSolver
	tmp_real::Treal         # temporary
	tmp_complex::Tcomp      # temporary
	l1::Tl1
	fftplan::Tplan
	ifftplan::Tiplan
end

# this is a constructor for the above struct
function SHLinearOp(Nx, lx, Ny, ly; AF = Array{TY})
	# AF is a type, it could be CuArray{TY} to run the following on GPU
	k1 = vcat(collect(0:Nx/2), collect(Nx/2+1:Nx-1) .- Nx)
	k2 = vcat(collect(0:Ny/2), collect(Ny/2+1:Ny-1) .- Ny)
	d2 = [(1-(pi/lx * kx)^2 - (pi/ly * ky)^2)^2 + 1. for kx in k1, ky in k2]
	tmpc = Complex.(AF(zeros(Nx, Ny)))
	return SHLinearOp(AF(zeros(Nx, Ny)), tmpc, AF(d2), plan_fft!(tmpc), plan_ifft!(tmpc))
end

import Base: *, \

# action of L
function *(c::SHLinearOp, u)
	c.tmp_complex .= Complex.(u)
	c.fftplan * c.tmp_complex
	c.tmp_complex .= c.l1 .* c.tmp_complex
	c.ifftplan * c.tmp_complex
	c.tmp_real .= real.(c.tmp_complex)
	return copy(c.tmp_real)
end

# inverse of L
function \(c::SHLinearOp, u)
	c.tmp_complex .= Complex.(u)
	c.fftplan * c.tmp_complex
	c.tmp_complex .=  c.tmp_complex ./ c.l1
	c.ifftplan * c.tmp_complex
	c.tmp_real .= real.(c.tmp_complex)
	return copy(c.tmp_real)
end</code></pre><p>Before applying a Newton solver, we need to tell how to solve the linear equation arising in the Newton Algorithm.</p><pre><code class="language-julia"># inverse of the jacobian of the PDE
function (sh::SHLinearOp)(J, rhs; shift = 0., tol =  1e-9)
	u, l, ν = J
	udiag = l .+ 1 .+ 2ν .* u .- 3 .* u.^2 .- shift
	res, info = KrylovKit.linsolve( du -&gt; -du .+ sh \ (udiag .* du), sh \ rhs, tol = tol, maxiter = 6)
	return res, true, info.numops
end</code></pre><p>Now that we have our operator <code>L</code>, we can encode our functional:</p><pre><code class="language-julia">function F_shfft(u, p)
	@unpack l, ν, L = p
	return -(L * u) .+ ((l+1) .* u .+ ν .* u.^2 .- u.^3)
end</code></pre><h2 id="Linear-Algebra-on-the-GPU-1"><a class="docs-heading-anchor" href="#Linear-Algebra-on-the-GPU-1">Linear Algebra on the GPU</a><a class="docs-heading-anchor-permalink" href="#Linear-Algebra-on-the-GPU-1" title="Permalink"></a></h2><p>We plan to use <code>KrylovKit</code> on the GPU. For this to work, we need to redefine some functions for <code>CuArrays.jl</code>.</p><div class="admonition is-info"><header class="admonition-header">Overloading specific functions for CuArrays.jl</header><div class="admonition-body"><p>Note that the following code will not be needed in the future when <code>CuArrays</code> improves.</p></div></div><pre><code class="language-julia">using CuArrays
CuArrays.allowscalar(false)
import LinearAlgebra: mul!, axpby!
mul!(x::CuArray, y::CuArray, α::T) where {T &lt;: Number} = (x .= α .* y)
mul!(x::CuArray, α::T, y::CuArray) where {T &lt;: Number} = (x .= α .* y)
axpby!(a::T, X::CuArray, b::T, Y::CuArray) where {T &lt;: Number} = (Y .= a .* X .+ b .* Y)

# type used for the arrays, can be Float32 is GPU requires it
TY = Float64
# put the AF = Array{TY} instead to make the code on the CPU
AF = CuArray{TY}</code></pre><p>We can now define our operator <code>L</code> and an initial guess <code>sol0</code>.</p><pre><code class="language-julia">using LinearAlgebra, Plots

# to simplify plotting of the solution
heatmapsol(x) = heatmap(reshape(Array(x), Nx, Ny)&#39;, color=:viridis)

# norm compatible with CuArrays
norminf(x) = maximum(abs.(x))

Nx = 2^10
Ny = 2^10
lx = 8pi * 2
ly = 2*2pi/sqrt(3) * 2

X = -lx .+ 2lx/(Nx) * collect(0:Nx-1)
Y = -ly .+ 2ly/(Ny) * collect(0:Ny-1)

sol0 = [(cos(x) .+ cos(x/2) * cos(sqrt(3) * y/2) ) for x in X, y in Y]
		sol0 .= sol0 .- minimum(vec(sol0))
		sol0 ./= maximum(vec(sol0))
		sol0 = sol0 .- 0.25
		sol0 .*= 1.7

L = SHLinearOp(Nx, lx, Ny, ly, AF = AF)
# parameters of the PDE
par = (l = -0.15, ν = 1.3, L = L)</code></pre><h2 id="Newton-iterations-and-deflation-1"><a class="docs-heading-anchor" href="#Newton-iterations-and-deflation-1">Newton iterations and deflation</a><a class="docs-heading-anchor-permalink" href="#Newton-iterations-and-deflation-1" title="Permalink"></a></h2><p>We are now ready to perform Newton iterations:</p><pre><code class="language-julia">opt_new = NewtonPar(verbose = true, tol = 1e-6, maxIter = 100, linsolver = L)
	sol_hexa, hist, flag = @time PALC.newton(
		x -&gt; F_shfft(x, par),
		u -&gt; (u, par.l, par.ν),
		AF(sol0),
		opt_new, normN = norminf)
				
	println(&quot;--&gt; norm(sol) = &quot;, maximum(abs.(sol_hexa)))
	heatmapsol(sol_hexa)</code></pre><p>You should see this:</p><pre><code class="language-julia"> Newton Iterations
   Iterations      Func-count      f(x)      Linear-Iterations

        0                1     2.7383e-01         0
        1                2     1.2891e+02        14
        2                3     3.8139e+01        70
        3                4     1.0740e+01        37
        4                5     2.8787e+00        22
        5                6     7.7522e-01        17
        6                7     1.9542e-01        13
        7                8     3.0292e-02        13
        8                9     1.1594e-03        12
        9               10     1.8842e-06        11
       10               11     4.2642e-08        10
  2.261527 seconds (555.45 k allocations: 44.849 MiB, 1.61% gc time)
--&gt; norm(sol) = 1.26017611779702</code></pre><p><strong>Note that this is about the same computation time as in Example 2 but for a problem almost 100x larger!</strong></p><p>The solution is:</p><p><img src="../SH-GPU.png" alt/></p><p>We can also use the deflation technique (see <a href="../library/#PseudoArcLengthContinuation.DeflationOperator"><code>DeflationOperator</code></a> and <a href="../library/#PseudoArcLengthContinuation.DeflatedProblem"><code>DeflatedProblem</code></a> for more information) on the GPU as follows</p><pre><code class="language-julia">deflationOp = DeflationOperator(2.0, (x, y)-&gt;dot(x, y), 1.0, [sol_hexa])

opt_new = @set opt_new.maxIter = 250
outdef, _, flag, _ = @time newton(
		x -&gt; F_shfft(x, par),
		u -&gt; (u, par.l, par.ν),
		0.4 .* sol_hexa .* AF([exp(-1(x+0lx)^2/25) for x in X, y in Y]),
		opt_new, deflationOp, normN = x-&gt; maximum(abs.(x)))
	println(&quot;--&gt; norm(sol) = &quot;, norm(outdef))
	heatmapsol(outdef) |&gt; display
	flag &amp;&amp; push!(deflationOp, outdef)</code></pre><p>and get:</p><p><img src="../SH-GPU-deflation.png" alt/></p><h2 id="Computation-of-the-branches-1"><a class="docs-heading-anchor" href="#Computation-of-the-branches-1">Computation of the branches</a><a class="docs-heading-anchor-permalink" href="#Computation-of-the-branches-1" title="Permalink"></a></h2><p>Finally, we can perform continuation of the branches on the GPU:</p><pre><code class="language-julia">opts_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.007, ds= -0.005, pMax = 0.2, pMin = -1.0, theta = 0.5, plotEveryNsteps = 5, 
	newtonOptions = setproperties(opt_new; tol = 1e-6, maxIter = 15), maxSteps = 100)

	br, _ = @time continuation(
		(u, p) -&gt; F_shfft(u, @set par.l = p),
		(u, p) -&gt; (u, p, par.ν),
		deflationOp[1],
		-0.1,
		opts_cont, plot = true,
		plotSolution = (x;kwargs...)-&gt;heatmap!(reshape(Array(x), Nx, Ny)&#39;; color=:viridis, kwargs...), normC = x-&gt;maximum(abs.(x)))</code></pre><p>We did not detail how to compute the eigenvalues on the GPU and detect the bifurcations. It is based on a simple Shift-Invert strategy, please look at <code>examples/SH2d-fronts-cuda.jl</code>.</p><p><img src="GPUBranch.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials2/">« 3/ Swift-Hohenberg</a><a class="docs-footer-nextpage" href="../tutorials3/">5/ Brusselator 1d »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 12 February 2020 21:18">Wednesday 12 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
