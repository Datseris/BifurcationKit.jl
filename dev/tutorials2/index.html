<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Snaking in the 2d Swift-Hohenberg equation · Bifurcation Analysis in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Bifurcation Analysis in Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guidelines/">Overview</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (codim 2)</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf point</a></li></ul></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problem</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><input class="collapse-toggle" id="menuitem-4-9" type="checkbox"/><label class="tocitem" for="menuitem-4-9"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitFD/">Finite Differences</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear / Eigen Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Snaking in the 2d Swift-Hohenberg equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Snaking in the 2d Swift-Hohenberg equation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/BifurcationKit.jl/blob/master/docs/src/tutorials2.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Snaking-in-the-2d-Swift-Hohenberg-equation-1"><a class="docs-heading-anchor" href="#Snaking-in-the-2d-Swift-Hohenberg-equation-1">Snaking in the 2d Swift-Hohenberg equation</a><a class="docs-heading-anchor-permalink" href="#Snaking-in-the-2d-Swift-Hohenberg-equation-1" title="Permalink"></a></h1><ul><li><a href="#Snaking-in-the-2d-Swift-Hohenberg-equation-1">Snaking in the 2d Swift-Hohenberg equation</a></li><ul><li><a href="#Continuation-and-bifurcation-points-1">Continuation and bifurcation points</a></li><li><a href="#Snaking-computed-with-deflation-1">Snaking computed with deflation</a></li></ul></ul><p>We study the following PDE</p><div>\[-(I+\Delta)^2 u+l\cdot u +\nu u^2-u^3 = 0\]</div><p>with Neumann boundary conditions. This full example is in the file <code>example/SH2d-fronts.jl</code>. This example is also treated in the MATLAB package <a href="http://www.staff.uni-oldenburg.de/hannes.uecker/pde2path/">pde2path</a>. We use a Sparse Matrix to express the operator <span>$L_1=(I+\Delta)^2$</span></p><pre><code class="language-julia">using DiffEqOperators, Setfield, Parameters
using BifurcationKit, LinearAlgebra, Plots, SparseArrays
const BK = BifurcationKit

# helper function to plot solution
heatmapsol(x) = heatmap(reshape(x,Nx,Ny)&#39;,color=:viridis)

Nx = 151
Ny = 100
lx = 4*2pi
ly = 2*2pi/sqrt(3)

# we use DiffEqOperators to compute the Laplacian operator
function Laplacian2D(Nx, Ny, lx, ly)
	hx = 2lx/Nx
	hy = 2ly/Ny
	D2x = CenteredDifference(2, 2, hx, Nx)
	D2y = CenteredDifference(2, 2, hy, Ny)
	Qx = Neumann0BC(hx)
	Qy = Neumann0BC(hy)
	
	A = kron(sparse(I, Ny, Ny), sparse(D2x * Qx)[1]) + kron(sparse(D2y * Qy)[1], sparse(I, Nx, Nx))
	return A, D2x
end</code></pre><p>We also write the functional and its Jacobian which is a Sparse Matrix</p><pre><code class="language-julia">function F_sh(u, p)
	@unpack l, ν, L1 = p
	return -L1 * u .+ (l .* u .+ ν .* u.^2 .- u.^3)
end

function dF_sh(u, p)
	@unpack l, ν, L1 = p
	return -L1 .+ spdiagm(0 =&gt; l .+ 2 .* ν .* u .- 3 .* u.^2)
end</code></pre><p>We first look for hexagonal patterns. This is done with</p><pre><code class="language-julia">X = -lx .+ 2lx/(Nx) * collect(0:Nx-1)
Y = -ly .+ 2ly/(Ny) * collect(0:Ny-1)

# initial guess for hexagons
sol0 = [(cos(x) + cos(x/2) * cos(sqrt(3) * y/2) ) for x in X, y in Y]
	sol0 .= sol0 .- minimum(vec(sol0))
	sol0 ./= maximum(vec(sol0))
	sol0 = sol0 .- 0.25
	sol0 .*= 1.7
	heatmap(sol0&#39;,color=:viridis)

# define parameters for the PDE
Δ, _ = Laplacian2D(Nx, Ny, lx, ly)
L1 = (I + Δ)^2
par = (l = -0.1, ν = 1.3, L1 = L1)

# newton corrections of the initial guess
optnewton = NewtonPar(verbose = true, tol = 1e-8, maxIter = 20)
	sol_hexa, _, _ = @time newton(F_sh, dF_sh, vec(sol0), par, optnewton)
	println(&quot;--&gt; norm(sol) = &quot;,norm(sol_hexa,Inf64))
	heatmapsol(sol_hexa)</code></pre><p>which produces the results</p><pre><code class="language-julia"> Newton Iterations 
   Iterations      Func-count      f(x)      Linear-Iterations

        0                1     1.7391e+02         0
        1                2     5.0465e+03         1
        2                3     1.4878e+03         1
        3                4     4.3529e+02         1
        4                5     1.2560e+02         1
        5                6     3.5512e+01         1
        6                7     9.5447e+00         1
        7                8     2.1763e+00         1
        8                9     3.3503e-01         1
        9               10     7.7259e-02         1
       10               11     7.4767e-03         1
       11               12     7.9505e-05         1
       12               13     8.8395e-09         1
  1.480938 seconds (3.55 k allocations: 659.404 MiB)</code></pre><p>with <code>sol_hexa</code> being</p><p><img src="../sh2dhexa.png" alt/></p><h2 id="Continuation-and-bifurcation-points-1"><a class="docs-heading-anchor" href="#Continuation-and-bifurcation-points-1">Continuation and bifurcation points</a><a class="docs-heading-anchor-permalink" href="#Continuation-and-bifurcation-points-1" title="Permalink"></a></h2><p>We can now continue this solution as follows. We want to detect bifurcations along the branches. We thus need an eigensolver. However, if we use an iterative eigensolver, like <code>eig = EigArpack()</code>, it has trouble computing the eigenvalues. One can see that using </p><pre><code class="language-julia"># compute the jacobian
J0 = dF_sh(sol_hexa, par)

# compute 10 eigenvalues
eig(J0, 10)</code></pre><p>The reason is that the jacobian operator is not very well conditioned unlike its inverse. We thus opt for the <em>shift-invert</em> method (see <a href="../linearsolver/#Eigen-solvers-1">Eigen solvers</a> for more information) with shift <code>0.1</code>:</p><pre><code class="language-julia">eig = EigArpack(0.1, :LM)</code></pre><p>If we want to compute the bifurcation points along the branches, we have to tell the solver by setting <code>detectBifurcation = 2</code>. However, this won&#39;t be very precise and each bifurcation point will be located at best at the step size precision. We can use bisection to locate this points more precisely using the option <code>detectBifurcation = 3</code> (see <a href="../detectionBifurcation/#Detection-of-bifurcation-points-1">Detection of bifurcation points</a> for more information).</p><p>We are now ready to compute the branches:</p><pre><code class="language-julia">optcont = ContinuationPar(dsmin = 0.0001, dsmax = 0.005, ds= -0.001, pMax = 0.00, pMin = -1.0,
	newtonOptions = setproperties(optnewton; tol = 1e-9, maxIter = 15), maxSteps = 125,
	detectBifurcation = 3, nev = 40, detectFold = false, 
	dsminBisection =1e-7, saveSolEveryStep = 4)
	optcont = @set optcont.newtonOptions.eigsolver = EigArpack(0.1, :LM)

	br, u1 = @time BK.continuation(F_sh, dF_sh,
		sol_hexa, par, (@lens _.l), optcont;		plot = true, verbosity = 3,
		tangentAlgo = BorderedPred(),
		plotSolution = (x, p; kwargs...) -&gt; (heatmap!(X, Y, reshape(x, Nx, Ny)&#39;; color=:viridis, label=&quot;&quot;, kwargs...);ylims!(-1,1,subplot=4);xlims!(-.5,.3,subplot=4)),
		printSolution = (x, p) -&gt; norm(x),
		normC = x -&gt; norm(x, Inf))</code></pre><p>Note that we can get some information about the branch as follows. The <code>[converged]</code> indicates if the bisection routine was successful, otherwise it shows <code>[guess]</code>. Finally <code>δ = ( 2,  0)</code> says that the bifurcation point has been detected by 2 new eigenvalues with zero real part among which zero have non zero imaginary part. A Hopf bifurcation point would thus have <code>δ = ( 2,  2)</code> or <code>δ = ( -2,  2)</code>.</p><pre><code class="language-julia">julia&gt; br
Branch number of points: 98
Branch of Equilibrium
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,      bp at p ≈ -0.21554724 ± 3e-07, step =  35, eigenelements in eig[ 36], ind_ev =   1 [converged], δ = ( 1,  0)
- #  2,      bp at p ≈ -0.21551263 ± 9e-06, step =  36, eigenelements in eig[ 37], ind_ev =   2 [converged], δ = ( 1,  0)
- #  3,      bp at p ≈ -0.21499087 ± 7e-05, step =  38, eigenelements in eig[ 39], ind_ev =   3 [converged], δ = ( 1,  0)
- #  4,      bp at p ≈ -0.21289710 ± 8e-05, step =  41, eigenelements in eig[ 42], ind_ev =   4 [converged], δ = ( 1,  0)
- #  5,      nd at p ≈ -0.20993438 ± 2e-04, step =  43, eigenelements in eig[ 44], ind_ev =   6 [converged], δ = ( 2,  0)
- #  6,      nd at p ≈ -0.20628011 ± 6e-04, step =  45, eigenelements in eig[ 46], ind_ev =   8 [converged], δ = ( 2,  0)
- #  7,      bp at p ≈ -0.19981594 ± 9e-05, step =  48, eigenelements in eig[ 49], ind_ev =   9 [converged], δ = ( 1,  0)
- #  8,      bp at p ≈ -0.18868881 ± 2e-04, step =  52, eigenelements in eig[ 53], ind_ev =  10 [converged], δ = ( 1,  0)
- #  9,      bp at p ≈ -0.18103471 ± 8e-06, step =  55, eigenelements in eig[ 56], ind_ev =  11 [converged], δ = ( 1,  0)
- # 10,      bp at p ≈ -0.14472469 ± 6e-04, step =  64, eigenelements in eig[ 65], ind_ev =  11 [converged], δ = (-1,  0)
- # 11,      bp at p ≈ -0.13818751 ± 6e-04, step =  66, eigenelements in eig[ 67], ind_ev =  10 [converged], δ = (-1,  0)</code></pre><p>We get the following plot during computation:</p><p><img src="../sh2dbrhexa.png" alt/></p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We don&#39;t need to call <code>newton</code> first in order to use <code>continuation</code>.</p></div></div><h2 id="Snaking-computed-with-deflation-1"><a class="docs-heading-anchor" href="#Snaking-computed-with-deflation-1">Snaking computed with deflation</a><a class="docs-heading-anchor-permalink" href="#Snaking-computed-with-deflation-1" title="Permalink"></a></h2><p>We know that there is snaking near the left fold. Let us look for other solutions like fronts. The problem is that if the guess is not precise enough, the newton iterations will converge to the solution with hexagons <code>sol_hexa</code>. We appeal to the technique initiated by P. Farrell and use a <strong>deflated problem</strong> (see <a href="../library/#BifurcationKit.DeflationOperator"><code>DeflationOperator</code></a> and <a href="../library/#BifurcationKit.DeflatedProblem"><code>DeflatedProblem</code></a> for more information). More precisely, we apply the newton iterations to the following functional <span>$u\to \frac{F_{sh}(u)}{\Pi_{i=1}^{n_s} \|u-sol_{hexa,i}\|^p + \sigma}$</span> which penalizes <code>sol_hexa</code>.</p><pre><code class="language-julia"># this define the above penalizing factor with p=2, sigma=1, norm associated to dot
# and the set of sol_{hexa} is of length ns=1
deflationOp = DeflationOperator(2.0,dot,1.0,[sol_hexa])
optnewton = @set optnewton.maxIter = 250
outdef, _, flag, _ = @time newton(F_sh, dF_sh,
				0.2vec(sol_hexa) .* vec([exp.(-(x+lx)^2/25) for x in X, y in Y]),
				par, optnewton, deflationOp, normN = x -&gt; norm(x,Inf64))
		heatmapsol(outdef) |&gt; display
		flag &amp;&amp; push!(deflationOp, outdef)</code></pre><p>which gives:</p><p><img src="../sh2dfrontleft.png" alt/></p><p>Note that <code>push!(deflationOp, outdef)</code> deflates the newly found solution so that by repeating the process we find another one:</p><pre><code class="language-julia">outdef, _, flag, _ = @time newton(F_sh, dF_sh,
				0.2vec(sol_hexa) .* vec([exp.(-(x)^2/25) for x in X, y in Y]),
				par, optnewton, deflationOp, normN = x -&gt; norm(x,Inf64))
		heatmapsol(outdef) |&gt; display
		flag &amp;&amp; push!(deflationOp, outdef)</code></pre><p><img src="../sh2dfrontmiddle.png" alt/></p><p>Again, repeating this from random guesses, we find several more solutions, like for example</p><p><img src="../sh2dsol4.png" alt/></p><p><img src="../sh2dsol5.png" alt/></p><p>We can now continue the solutions located in <code>deflationOp.roots</code></p><pre><code class="language-julia">br, _ = @time continuation(F_sh, dF_sh,
	deflationOp[2], par, (@lens _.l), optcont;
	plot = true, 
	plotSolution = (x, p; kwargs...) -&gt; (heatmap!(X,Y,reshape(x,Nx,Ny)&#39;; color=:viridis, label=&quot;&quot;, kwargs...)))</code></pre><p>and using <code>plot(br)</code>, we obtain:</p><p><img src="../sh2dbranches.png" alt/></p><p>Note that the plot provides the stability of solutions and bifurcation points. Interested readers should consult the associated file <code>example/SH2d-fronts.jl</code> in the <code>example</code> folder.</p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 5 July 2020 20:09">Sunday 5 July 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
