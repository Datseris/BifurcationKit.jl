<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fold / Hopf Continuation (codim 2) · Bifurcation Analysis in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Bifurcation Analysis in Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guidelines/">Overview</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection</a></li><li class="is-active"><a class="tocitem" href>Fold / Hopf Continuation (codim 2)</a><ul class="internal"><li><a class="tocitem" href="#Newton-refinement-1"><span>Newton refinement</span></a></li><li><a class="tocitem" href="#Codim-2-continuation-1"><span>Codim 2 continuation</span></a></li><li><a class="tocitem" href="#Advanced-use-1"><span>Advanced use</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf point</a></li></ul></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated Continuation</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problem</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><input class="collapse-toggle" id="menuitem-4-11" type="checkbox"/><label class="tocitem" for="menuitem-4-11"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitFD/">Finite Differences</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear / Eigen Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functionalities</a></li><li class="is-active"><a href>Fold / Hopf Continuation (codim 2)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fold / Hopf Continuation (codim 2)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/BifurcationKit.jl/blob/master/docs/src/codim2Continuation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Fold-/-Hopf-Continuation-1"><a class="docs-heading-anchor" href="#Fold-/-Hopf-Continuation-1">Fold / Hopf Continuation</a><a class="docs-heading-anchor-permalink" href="#Fold-/-Hopf-Continuation-1" title="Permalink"></a></h1><p>For this to work, it is important to have an analytical expression for the jacobian. See the tutorial <a href="../tutorials1/#Temperature-model-(simplest-example-for-equilibria)-1">Temperature model (simplest example for equilibria)</a> for more details.</p><h2 id="Newton-refinement-1"><a class="docs-heading-anchor" href="#Newton-refinement-1">Newton refinement</a><a class="docs-heading-anchor-permalink" href="#Newton-refinement-1" title="Permalink"></a></h2><p>Once a Fold/Hopf point has been detected after a call to <code>br, _ = continuation(...)</code>, it can be refined using <code>newton</code> iterations. We have implemented a <strong>Minimally Augmented</strong> formulation. A simplified interface is provided.</p><p>Let us say that <code>ind_bif</code> is the index in <code>br.bifpoint</code> of a Fold/Hopf point. This guess can be refined by newton iterations by doing </p><pre><code class="language-julia">outfold, hist, flag = newton(F, J, br::ContResult, ind_bif::Int64, 
	par, lens::Lens; Jt = nothing, d2F = nothing, normN = norm, 
	options = br.contparams.newtonOptions, kwargs...)</code></pre><p>where <code>par</code> is the set of parameters used in the call to <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a> to get <code>br</code> and <code>lens</code> is the parameter axis which is used to find the Fold/Hopf point. For the options parameters, we refer to <a href="../library/#Newton-1">Newton</a>.</p><p>It is important to note that for improved performances, a function implementing the expression of the <strong>hessian</strong> should be provided. This is by far the fastest. Reader interested in this advanced usage should look at the code <code>example/chan.jl</code> of the tutorial <a href="../tutorials1/#Temperature-model-(simplest-example-for-equilibria)-1">Temperature model (simplest example for equilibria)</a>. </p><h2 id="Codim-2-continuation-1"><a class="docs-heading-anchor" href="#Codim-2-continuation-1">Codim 2 continuation</a><a class="docs-heading-anchor-permalink" href="#Codim-2-continuation-1" title="Permalink"></a></h2><p>To compute the codim 2 curve of Fold/Hopf points, one can call <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a> with the following options</p><pre><code class="language-julia">br_codim2, _ = continuation(F, J, br, ind_bif, 
	par, lens1::Lens, lens2::Lens, options_cont::ContinuationPar ;
	Jt = nothing, d2F = nothing, kwargs...)</code></pre><p>where the options are as above except with have two parameter axis <code>lens1, lens2</code> which are used to locate the bifurcation points. See <a href="../tutorials1/#Temperature-model-(simplest-example-for-equilibria)-1">Temperature model (simplest example for equilibria)</a> for an example of use. </p><h2 id="Advanced-use-1"><a class="docs-heading-anchor" href="#Advanced-use-1">Advanced use</a><a class="docs-heading-anchor-permalink" href="#Advanced-use-1" title="Permalink"></a></h2><p>Here, we expose the solvers that are used to perform newton refinement or codim 2 continuation in case the above methods fails. This is useful in case it is too involved to expose the linear solver options. An example of advanced use is the continuation of Folds of periodic orbits, see <a href="../tutorialsCGL/#Continuation-of-Fold-of-periodic-orbits-1">Continuation of Fold of periodic orbits</a>.</p><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.newtonFold" href="#BifurcationKit.newtonFold"><code>BifurcationKit.newtonFold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">newtonFold(F, J, foldpointguess, par, lens::Lens, eigenvec, options::NewtonPar; Jt = nothing, d2F = nothing, normN = norm, kwargs...)</code></pre><p>This function turns an initial guess for a Fold point into a solution to the Fold problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F   = (x, p) -&gt; F(x, p)</code> where <code>p</code> is a set of parameters.</li><li><code>dF  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>foldpointguess</code> initial guess (x<em>0, p</em>0) for the Fold point. It should be a <code>BorderedArray</code> as returned by the function <code>FoldPoint</code></li><li><code>par</code> parameters used for the vector field</li><li><code>lens</code> parameter axis used to locate the Fold point.</li><li><code>eigenvec</code> guess for the 0 eigenvector</li><li><code>options::NewtonPar</code> options for the Newton-Krylov algorithm, see <a href="../library/#BifurcationKit.NewtonPar"><code>NewtonPar</code></a>.</li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, <code>Jt</code> should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass <code>Jt = (x, p) -&gt; transpose(dF(x, p))</code></li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x,p)[v1,v2]</code>.</li><li><code>normN = norm</code></li><li><code>kwargs</code> keywords arguments to be passed to the regular Newton-Krylov solver</li></ul><p><strong>Simplified call</strong></p><p>Simplified call to refine an initial guess for a Fold point. More precisely, the call is as follows</p><pre><code class="language-none">newtonFold(F, J, br::ContResult, ind_fold::Int64, par, lens::Lens; Jt = nothing, d2F = nothing, options = br.contparams.newtonOptions, kwargs...)</code></pre><p>where the optional argument <code>Jt</code> is the jacobian transpose and the Hessian is <code>d2F</code>. The parameters / options are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine. You can pass newton parameters different from the ones stored in <code>br</code> by using the argument <code>options</code>.</p><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/8b25e43a9f773561ad5ede3833d04afc00139265/src/codim2/FoldCont.jl#L173-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.newtonHopf" href="#BifurcationKit.newtonHopf"><code>BifurcationKit.newtonHopf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">newtonHopf(F, J, hopfpointguess::BorderedArray{vectypeR, T}, par, lens::Lens, eigenvec, eigenvec_ad, options::NewtonPar; Jt = nothing, d2F = nothing, normN = norm) where {vectypeR, T}</code></pre><p>This function turns an initial guess for a Hopf point into a solution to the Hopf problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F   = (x, p) -&gt; F(x, p)</code> where <code>p</code> is a set of parameters.</li><li><code>dF  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>hopfpointguess</code> initial guess (x<em>0, p</em>0) for the Hopf point. It should a <code>BorderedArray</code> as returned by the function <code>HopfPoint</code>.</li><li><code>par</code> parameters used for the vector field</li><li><code>lens</code> parameter axis used to locate the Hopf point.</li><li><code>eigenvec</code> guess for the  iω eigenvector</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector</li><li><code>options::NewtonPar</code> options for the Newton-Krylov algorithm, see <a href="../library/#BifurcationKit.NewtonPar"><code>NewtonPar</code></a>.</li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, <code>Jt</code> should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass <code>Jt = (x, p) -&gt; transpose(dF(x, p))</code></li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x,p)[v1,v2]</code>.</li><li><code>normN = norm</code></li><li><code>kwargs</code> keywords arguments to be passed to the regular Newton-Krylov solver</li></ul><p><strong>Simplified call:</strong></p><p>Simplified call to refine an initial guess for a Hopf point. More precisely, the call is as follows</p><pre><code class="language-none">newtonHopf(F, J, br::ContResult, ind_hopf::Int64, par, lens::Lens; Jt = nothing, d2F = nothing, normN = norm, options = br.contparams.newtonOptions, kwargs...)</code></pre><p>where the optional argument <code>Jt</code> is the jacobian transpose and the Hessian is <code>d2F</code>. The parameters / options are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine. You can pass newton parameters different from the ones stored in <code>br</code> by using the argument <code>options</code>.</p><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/8b25e43a9f773561ad5ede3833d04afc00139265/src/codim2/HopfCont.jl#L177-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuationFold" href="#BifurcationKit.continuationFold"><code>BifurcationKit.continuationFold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">continuationFold(F, J, foldpointguess, par, lens1, lens2, eigenvec, options_cont; Jt, d2F, kwargs...)
</code></pre><p>Codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p) -&gt;	F(x, p)</code> where <code>p</code> is a set of parameters</li><li><code>J = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>foldpointguess</code> initial guess (x<em>0, p1</em>0) for the Fold point. It should be a <code>BorderedArray</code> as returned by the function <code>FoldPoint</code></li><li><code>par</code> set of parameters</li><li><code>lens1</code> parameter axis for parameter 1</li><li><code>lens2</code> parameter axis for parameter 2</li><li><code>eigenvec</code> guess for the 0 eigenvector at p1_0</li><li><code>options_cont</code> arguments to be passed to the regular <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian transpose</li><li><code>d2F = p -&gt; ((x, p, v1, v2) -&gt; d2F(x, p, v1, v2))</code> this is the hessian of <code>F</code> computed at <code>(x, p)</code> and evaluated at <code>(v1, v2)</code>.</li><li><code>kwargs</code> keywords arguments to be passed to the regular <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Simplified call</strong></p><p>The call is as follows</p><pre><code class="language-none">continuationFold(F, J, br::ContResult, ind_fold::Int64, par, lens1::Lens, lens2::Lens, options_cont::ContinuationPar ; Jt = nothing, d2F = nothing, kwargs...)</code></pre><p>where the parameters are as above except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of Fold point in <code>br</code> you want to continue.</p><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian would be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/8b25e43a9f773561ad5ede3833d04afc00139265/src/codim2/FoldCont.jl#L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuationHopf" href="#BifurcationKit.continuationHopf"><code>BifurcationKit.continuationHopf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">continuationHopf(F, J, hopfpointguess, par, lens1, lens2, eigenvec, eigenvec_ad, options_cont; Jt, d2F, kwargs...)
</code></pre><p>codim 2 continuation of Hopf points. This function turns an initial guess for a Hopf point into a curve of Hopf points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p) -&gt;	F(x, p)</code> where <code>p</code> is a set of parameters</li><li><code>J = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>hopfpointguess</code> initial guess (x<em>0, p1</em>0) for the Hopf point. It should be a <code>Vector</code> or a <code>BorderedArray</code></li><li><code>par</code> set of parameters</li><li><code>lens1</code> parameter axis for parameter 1</li><li><code>lens2</code> parameter axis for parameter 2</li><li><code>eigenvec</code> guess for the iω eigenvector at p1_0</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector at p1_0</li><li><code>options_cont</code> keywords arguments to be passed to the regular <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>Jt = (x, p) -&gt; adjoint(d_xF(x, p))</code> associated jacobian adjoint</li><li><code>d2F = p -&gt; ((x, p, v1, v2) -&gt; d2F(x, p, v1, v2))</code> this is the hessian of <code>F</code> computed at <code>(x, p)</code> and evaluated at <code>(v1, v2)</code>.</li><li><code>kwargs</code> keywords arguments to be passed to the regular <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Simplified call:</strong></p><p>The call is as follows</p><pre><code class="language-none">continuationHopf(F, J, br::ContResult, ind_hopf::Int64, par, lens1::Lens, lens2::Lens, options_cont::ContinuationPar ;  Jt = nothing, d2F = nothing, kwargs...)</code></pre><p>where the parameters are as above except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of Hopf point in <code>br</code> you want to refine.</p><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian would be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/BifurcationKit.jl/blob/8b25e43a9f773561ad5ede3833d04afc00139265/src/codim2/HopfCont.jl#L238">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../detectionBifurcation/">« Bifurcation detection</a><a class="docs-footer-nextpage" href="../simplebp/">Simple branch point »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 27 September 2020 20:30">Sunday 27 September 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
