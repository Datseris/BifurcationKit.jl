<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fold / Hopf Continuation · Pseudo Arc Length Continuation in Julia</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Pseudo Arc Length Continuation in Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Advanced Usage</span><ul><li><a class="toctext" href="../linearsolver/">Linear Solvers</a></li><li><a class="toctext" href="../detectionBifurcation/">Bifurcations</a></li><li class="current"><a class="toctext" href>Fold / Hopf Continuation</a><ul class="internal"><li><a class="toctext" href="#The-case-of-the-Fold-point-1">The case of the Fold point</a></li><li><a class="toctext" href="#The-case-of-the-Hopf-point-1">The case of the Hopf point</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li></ul></li><li><a class="toctext" href="../periodicOrbitCont/">Periodic Orbits</a></li></ul></li><li><a class="toctext" href="../faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../library/">Library</a></li></ul></nav><article id="docs"><header><nav><ul><li>Advanced Usage</li><li><a href>Fold / Hopf Continuation</a></li></ul><a class="edit-page" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/master/docs/src/codim2Continuation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Fold / Hopf Continuation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Fold-/-Hopf-Continuation-1" href="#Fold-/-Hopf-Continuation-1">Fold / Hopf Continuation</a></h1><p>For this to work, it is important to have an analytical expression for the jacobian. See the example <code>Chan</code> for more details.</p><h2><a class="nav-anchor" id="The-case-of-the-Fold-point-1" href="#The-case-of-the-Fold-point-1">The case of the Fold point</a></h2><p>One a Fold point have been detected after a call to <code>br, _ = continuation(...)</code>, it can be refined with the use of <code>newton</code> iterations. Several methods have been implemented namely <strong>Moore Spence</strong> and <strong>Minimally Augmented</strong>. A simplified interface is provided for the use of the later but the former one is fully functional.</p><h3><a class="nav-anchor" id="Newton-refinement-1" href="#Newton-refinement-1">Newton refinement</a></h3><p>Let us say that <code>ind_fold</code> is the index in <code>br.bifpoint</code> of a Fold point. This guess can be refined by calling the simplified interface. More precisions are provided below for an advanced usage.</p><pre><code class="language-julia">outfold, hist, flag = @time Cont.newtonFold((x,p) -&gt; F(x, p),
							(x, p) -&gt; Jac(x, p),
							br, ind_fold,
							opt_newton)</code></pre><h2><a class="nav-anchor" id="The-case-of-the-Hopf-point-1" href="#The-case-of-the-Hopf-point-1">The case of the Hopf point</a></h2><p>One a Hopf point have been detected after a call to <code>br, _ = continuation(...)</code>, it can be refined with the use of <code>newton</code> iterations. Several method have been implemented but we focus on the <strong>Minimally Augmented</strong> one. A simplified interface is provided for the use of this method.</p><h3><a class="nav-anchor" id="Newton-refinement-2" href="#Newton-refinement-2">Newton refinement</a></h3><p>Let us say that <code>ind_hopf</code> is the index in <code>br.bifpoint</code> of a Hopf point. This guess can be refined by calling the simplified interface. More precisions are provided below for an advanced usage.</p><pre><code class="language-julia">outfold, hist, flag = @time Cont.newtonHopf((x,p) -&gt; F(x, p),
							(x, p) -&gt; Jac(x, p),
							br, ind_hopf,
							opt_newton)</code></pre><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonFold" href="#PseudoArcLengthContinuation.newtonFold"><code>PseudoArcLengthContinuation.newtonFold</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function turns an initial guess for a Fold point into a solution to the Fold problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>(x, p)-&gt; F(x, p)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>J = (x, p)-&gt; d_xF(x, p)</code> associated jacobian</li><li><code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian, it should be implenented otherwise</li><li><code>foldpointguess</code> initial guess (x<em>0, p</em>0) for the Fold point. It should be a <code>Vector</code></li><li><code>eigenvec</code> guess for the 0 eigenvector</li><li><code>options::NewtonPar</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/331941503e52375e3eedf8594cbbd7d4e16e308d/src/FoldCont.jl#L217-L225">source</a><div><div><p>Simplified call to refine an initial guess for a Fold point. More precisely, the call is as follows <code>newtonFold(F, J, Jt, br::ContResult, index::Int64, options)</code> where the parameters are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/331941503e52375e3eedf8594cbbd7d4e16e308d/src/FoldCont.jl#L252-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonHopf" href="#PseudoArcLengthContinuation.newtonHopf"><code>PseudoArcLengthContinuation.newtonHopf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function turns an initial guess for a Hopf point into a solution to the Hopf problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F  = (x, p) -&gt; F(x, p)</code> where <code>p</code> is the parameter associated to the Hopf point</li><li><code>J  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian</li><li><code>hopfpointguess</code> initial guess (x<em>0, p</em>0) for the Hopf point. It should be a <code>AbstractVector</code> or a <code>BorderedVector</code>.</li><li><code>eigenvec</code> guess for the  iω eigenvector</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector</li><li><code>options::NewtonPar</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/331941503e52375e3eedf8594cbbd7d4e16e308d/src/HopfCont.jl#L120-L129">source</a><div><div><p>Simplified call to refine an initial guess for a Hopf point. More precisely, the call is as follows <code>newtonHopf(F, J, Jt, br::ContResult, index::Int64, options)</code> where the parameters are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><div class="admonition warning"><div class="admonition-title">Eigenvectors`</div><div class="admonition-text"><p>This simplified call has been written when the eigenvectors are organised in a 2d Array <code>evec</code> where <code>evec[:,2]</code> is the second eigenvector in the list.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/331941503e52375e3eedf8594cbbd7d4e16e308d/src/HopfCont.jl#L153-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationFold" href="#PseudoArcLengthContinuation.continuationFold"><code>PseudoArcLengthContinuation.continuationFold</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>(x, p1, p2)-&gt; F(x, p1, p2)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>J = (x, p1, p2)-&gt; d_xF(x, p1, p2)</code> associated jacobian</li><li><code>foldpointguess</code> initial guess (x<em>0, p1</em>0) for the Fold point. It should be a <code>Vector</code></li><li><code>p2</code> parameter p2 for which foldpointguess is a good guess</li><li><code>eigenvec</code> guess for the 0 eigenvector at p1_0</li><li><code>options::NewtonPar</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/331941503e52375e3eedf8594cbbd7d4e16e308d/src/FoldCont.jl#L271-L279">source</a><div><div><p>Simplified call for continuation of Fold point. More precisely, the call is as follows <code>continuationFold(F, J, Jt, br::ContResult, index::Int64, options)</code> where the parameters are as for <code>continuationFold</code> except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/331941503e52375e3eedf8594cbbd7d4e16e308d/src/FoldCont.jl#L319-L321">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationHopf" href="#PseudoArcLengthContinuation.continuationHopf"><code>PseudoArcLengthContinuation.continuationHopf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>codim 2 continuation of Hopf points. This function turns an initial guess for a Hopf point into a curve of Hopf points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>(x, p1, p2)-&gt; F(x, p1, p2)</code> where <code>p</code> is the parameter associated to the hopf point</li><li><code>J = (x, p1, p2)-&gt; d_xF(x, p1, p2)</code> associated jacobian</li><li><code>hopfpointguess</code> initial guess (x<em>0, p1</em>0) for the Hopf point. It should be a <code>Vector</code> or a <code>BorderedVector</code></li><li><code>p2</code> parameter p2 for which hopfpointguess is a good guess</li><li><code>eigenvec</code> guess for the iω eigenvector at p1_0</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector at p1_0</li><li><code>options::NewtonPar</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/331941503e52375e3eedf8594cbbd7d4e16e308d/src/HopfCont.jl#L174-L183">source</a><div><div><p>Simplified call for continuation of Hopf point. More precisely, the call is as follows <code>continuationHopf(F, J, Jt, br::ContResult, index::Int64, options)</code> where the parameters are as for <code>continuationHopf</code> except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><div class="admonition warning"><div class="admonition-title">Eigenvectors`</div><div class="admonition-text"><p>This simplified call has been written when the eigenvectors are organised in a 2d Array <code>evec</code> where <code>evec[:,2]</code> is the second eigenvector in the list.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/331941503e52375e3eedf8594cbbd7d4e16e308d/src/HopfCont.jl#L216-L221">source</a></section><footer><hr/><a class="previous" href="../detectionBifurcation/"><span class="direction">Previous</span><span class="title">Bifurcations</span></a><a class="next" href="../periodicOrbitCont/"><span class="direction">Next</span><span class="title">Periodic Orbits</span></a></footer></article></body></html>
