<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fold / Hopf Continuation · Pseudo Arc Length Continuation in Julia</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Pseudo Arc Length Continuation in Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../tutorials/">Tutorials</a></li><li><span class="toctext">Advanced Usage</span><ul><li><a class="toctext" href="../linearsolver/">Linear Solvers</a></li><li><a class="toctext" href="../detectionBifurcation/">Bifurcations</a></li><li class="current"><a class="toctext" href>Fold / Hopf Continuation</a><ul class="internal"><li><a class="toctext" href="#The-case-of-the-Fold-point-1">The case of the Fold point</a></li><li><a class="toctext" href="#The-case-of-the-Hopf-point-1">The case of the Hopf point</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li></ul></li><li><a class="toctext" href="../periodicOrbitCont/">Periodic Orbits</a></li></ul></li><li><a class="toctext" href="../faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../library/">Library</a></li></ul></nav><article id="docs"><header><nav><ul><li>Advanced Usage</li><li><a href>Fold / Hopf Continuation</a></li></ul><a class="edit-page" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/master/docs/src/codim2Continuation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Fold / Hopf Continuation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Fold-/-Hopf-Continuation-1" href="#Fold-/-Hopf-Continuation-1">Fold / Hopf Continuation</a></h1><p>For this to work, it is important to have an analytical expression for the jacobian. See the example <code>Chan</code> for more details.</p><h2><a class="nav-anchor" id="The-case-of-the-Fold-point-1" href="#The-case-of-the-Fold-point-1">The case of the Fold point</a></h2><p>Once a Fold point have been detected after a call to <code>br, _ = continuation(...)</code>, it can be refined with the use of <code>newton</code> iterations. We have implemented a <strong>Minimally Augmented</strong> formulation. A simplified interface is provided.</p><h3><a class="nav-anchor" id="Newton-refinement-1" href="#Newton-refinement-1">Newton refinement</a></h3><p>Let us say that <code>ind_fold</code> is the index in <code>br.bifpoint</code> of a Fold point. This guess can be refined by calling the simplified interface. More precisions are provided below for an advanced usage.</p><pre><code class="language-julia">outfold, hist, flag = @time Cont.newtonFold((x,p) -&gt; F(x, p),
							(x, p) -&gt; Jac(x, p),
							br, ind_fold,
							opt_newton)</code></pre><p>It is important to note that for improved performance, a function implementing the expression of the <strong>hessian</strong> should be provided. This is by far the fastest for the computations. Reader interested in this advanced usage should look at the example <code>example/chan.jl</code>. Although it is a simple problem, many different use case are shown in a simple setting.</p><h2><a class="nav-anchor" id="The-case-of-the-Hopf-point-1" href="#The-case-of-the-Hopf-point-1">The case of the Hopf point</a></h2><p>One a Hopf point have been detected after a call to <code>br, _ = continuation(...)</code>, it can be refined with the use of <code>newton</code> iterations. We have implemented a <strong>Minimally Augmented</strong> formulation. A simplified interface is provided as for the Fold case.</p><h3><a class="nav-anchor" id="Newton-refinement-2" href="#Newton-refinement-2">Newton refinement</a></h3><p>Let us say that <code>ind_hopf</code> is the index in <code>br.bifpoint</code> of a Hopf point. This guess can be refined by calling the simplified interface. More precisions are provided below for an advanced usage.</p><pre><code class="language-julia">outfold, hist, flag = @time Cont.newtonHopf((x,p) -&gt; F(x, p),
							(x, p) -&gt; Jac(x, p),
							br, ind_hopf,
							opt_newton)</code></pre><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><pre><code class="language-none">newtonFold(F, J, Jt, foldpointguess::BorderedArray{vectype, T}, eigenvec, options::NewtonPar; normN = norm) where {T,vectype}</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonFold" href="#PseudoArcLengthContinuation.newtonFold"><code>PseudoArcLengthContinuation.newtonFold</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function turns an initial guess for a Fold point into a solution to the Fold problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F   = (x, p) -&gt; F(x, p)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>dF  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>dFt = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian, it should be implemented in an efficient manner. For matrix-free methods, <code>tranpose</code> is not readily available.</li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x,p)[v1,v2]</code>.</li><li><code>foldpointguess</code> initial guess (x<em>0, p</em>0) for the Fold point. It should be a <code>BorderedArray</code> as given by the function FoldPoint</li><li><code>eigenvec</code> guess for the 0 eigenvector</li><li><code>options::NewtonPar</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/8e3c687b6615fc6899bd218680af08d741121128/src/FoldCont.jl#L152-L161">source</a><div><div><p>Simplified call to refine an initial guess for a Fold point. More precisely, the call is as follows</p><pre><code class="language-none">`newtonFold(F, J, Jt, br::ContResult, index::Int64, options::NewtonPar)`</code></pre><p>or</p><pre><code class="language-none">`newtonFold(F, J, Jt, d2F, br::ContResult, index::Int64, options::NewtonPar)`</code></pre><p>whether the Hessian d2F is known analytically or not. The parameters / options are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/8e3c687b6615fc6899bd218680af08d741121128/src/FoldCont.jl#L193-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonHopf" href="#PseudoArcLengthContinuation.newtonHopf"><code>PseudoArcLengthContinuation.newtonHopf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function turns an initial guess for a Hopf point into a solution to the Hopf problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F  = (x, p) -&gt; F(x, p)</code> where <code>p</code> is the parameter associated to the Hopf point</li><li><code>J  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian</li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x,p)[v1,v2]</code>.</li><li><code>hopfpointguess</code> initial guess (x<em>0, p</em>0) for the Hopf point. It should a <code>BorderedArray</code> as given by the function HopfPoint.</li><li><code>eigenvec</code> guess for the  iω eigenvector</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector</li><li><code>options::NewtonPar</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/8e3c687b6615fc6899bd218680af08d741121128/src/HopfCont.jl#L161-L171">source</a><div><div><p>call when hessian is unknown, finite differences are then used</p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/8e3c687b6615fc6899bd218680af08d741121128/src/HopfCont.jl#L195-L197">source</a><div><div><p>Simplified call to refine an initial guess for a Hopf point. More precisely, the call is as follows</p><pre><code class="language-none">`newtonHopf(F, J, Jt, br::ContResult, index::Int64, options)`</code></pre><p>or</p><pre><code class="language-none">`newtonHopf(F, J, Jt, d2F, br::ContResult, index::Int64, options)`</code></pre><p>when the Hessian d2F is known. The parameters are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><div class="admonition warning"><div class="admonition-title">Eigenvectors</div><div class="admonition-text"><p>This simplified call has been written when the eigenvectors are organised in a 2d Array <code>evec</code> where <code>evec[:,2]</code> is the second eigenvector in the list.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/8e3c687b6615fc6899bd218680af08d741121128/src/HopfCont.jl#L202-L215">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationFold" href="#PseudoArcLengthContinuation.continuationFold"><code>PseudoArcLengthContinuation.continuationFold</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p1, p2) -&gt;	F(x, p1, p2)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>J = (x, p1, p2) -&gt; d_xF(x, p1, p2)</code> associated jacobian</li><li><code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> associated jacobian</li><li><code>d2F = (x, p1, p2, v1, v2) -&gt; d2F(x, p1, p2, v1, v2)</code> this is the hessian of <code>F</code> computed at <code>(x, p1, p2)</code> and evaluated at <code>(v1, v2)</code>.</li><li><code>foldpointguess</code> initial guess (x<em>0, p1</em>0) for the Fold point. It should be a <code>BorderedArray</code> as given by the function FoldPoint</li><li><code>p2</code> parameter p2 for which <code>foldpointguess</code> is a good guess</li><li><code>eigenvec</code> guess for the 0 eigenvector at p1_0</li><li><code>options::NewtonPar</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/8e3c687b6615fc6899bd218680af08d741121128/src/FoldCont.jl#L231-L241">source</a><div><div><p>codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p1, p2) -&gt; F(x, p1, p2)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>J = (x, p1, p2) -&gt; d_xF(x, p1, p2)</code> associated jacobian</li><li><code>foldpointguess</code> initial guess (x<em>0, p1</em>0) for the Fold point. It should be a <code>BorderedArray</code> as given by the function FoldPoint</li><li><code>p2</code> parameter p2 for which foldpointguess is a good guess</li><li><code>eigenvec</code> guess for the 0 eigenvector at p1_0</li><li><code>options::NewtonPar</code></li></ul><div class="admonition warning"><div class="admonition-title">Hessian</div><div class="admonition-text"></div></div><pre><code class="language-none">The hessian of `F` in this case is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/8e3c687b6615fc6899bd218680af08d741121128/src/FoldCont.jl#L271-L283">source</a><div><div><p>Simplified call for continuation of Fold point. More precisely, the call is as follows <code>continuationFold(F, J, Jt, d2F, br::ContResult, index::Int64, options)</code> where the parameters are as for <code>continuationFold</code> except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><p>Simplified calls are also provided but at the cost of using finite differences.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/8e3c687b6615fc6899bd218680af08d741121128/src/FoldCont.jl#L297-L301">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationHopf" href="#PseudoArcLengthContinuation.continuationHopf"><code>PseudoArcLengthContinuation.continuationHopf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>codim 2 continuation of Hopf points. This function turns an initial guess for a Hopf point into a curve of Hopf points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>(x, p1, p2)-&gt; F(x, p1, p2)</code> where <code>p</code> is the parameter associated to the hopf point</li><li><code>J = (x, p1, p2)-&gt; d_xF(x, p1, p2)</code> associated jacobian</li><li><code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> associated jacobian</li><li><code>d2F = (x, p1, p2, v1, v2) -&gt; d2F(x, p1, p2, v1, v2)</code> this is the hessian of <code>F</code> computed at <code>(x, p1, p2)</code> and evaluated at <code>(v1, v2)</code>.</li><li><code>hopfpointguess</code> initial guess (x<em>0, p1</em>0) for the Hopf point. It should be a <code>Vector</code> or a <code>BorderedArray</code></li><li><code>p2</code> parameter p2 for which hopfpointguess is a good guess</li><li><code>eigenvec</code> guess for the iω eigenvector at p1_0</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector at p1_0</li><li><code>options::NewtonPar</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/8e3c687b6615fc6899bd218680af08d741121128/src/HopfCont.jl#L232-L243">source</a><div><div><p>Simplified call for continuation of Hopf point. More precisely, the call is as follows <code>continuationHopf(F, J, Jt, d2F, br::ContResult, index::Int64, options)</code> where the parameters are as for <code>continuationHopf</code> except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><p>Simplified calls are also provided but at the cost of using finite differences.</p><div class="admonition warning"><div class="admonition-title">Eigenvectors</div><div class="admonition-text"><p>This simplified call has been written when the eigenvectors are organised in a 2d Array <code>evec</code> where <code>evec[:,2]</code> is the second eigenvector in the list.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/8e3c687b6615fc6899bd218680af08d741121128/src/HopfCont.jl#L279-L286">source</a></section><footer><hr/><a class="previous" href="../detectionBifurcation/"><span class="direction">Previous</span><span class="title">Bifurcations</span></a><a class="next" href="../periodicOrbitCont/"><span class="direction">Next</span><span class="title">Periodic Orbits</span></a></footer></article></body></html>
