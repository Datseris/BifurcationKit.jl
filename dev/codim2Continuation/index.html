<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fold / Hopf Continuation · Pseudo Arc Length Continuation in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Pseudo Arc Length Continuation in Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials1/">1/ Temperature model</a></li><li><a class="tocitem" href="../tutorials1b/">2/ Temperature model with Spectral Collocation</a></li><li><a class="tocitem" href="../tutorials2/">3/ Swift-Hohenberg</a></li><li><a class="tocitem" href="../tutorials2b/">4/ The Swift-Hohenberg on the GPU (non-local)</a></li><li><a class="tocitem" href="../tutorials3/">5/ Brusselator 1d</a></li><li><a class="tocitem" href="../tutorialsPD/">6/ Period Doubling in BVAM model</a></li><li><a class="tocitem" href="../tutorialsCGL/">7/ Ginzburg-Landau 2d (GPU)</a></li><li><a class="tocitem" href="../tutorialsCGLShoot/">8/ Ginzburg-Landau 2d (Shooting)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../linearsolver/">Linear / Eigen Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../detectionBifurcation/">Bifurcations</a></li><li class="is-active"><a class="tocitem" href>Fold / Hopf Continuation</a><ul class="internal"><li><a class="tocitem" href="#The-case-of-the-Fold-point-1"><span>The case of the Fold point</span></a></li><li><a class="tocitem" href="#The-case-of-the-Hopf-point-1"><span>The case of the Hopf point</span></a></li><li><a class="tocitem" href="#Methods-1"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problem</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitFD/">Finite Differences</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functionalities</a></li><li class="is-active"><a href>Fold / Hopf Continuation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fold / Hopf Continuation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/master/docs/src/codim2Continuation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Fold-/-Hopf-Continuation-1"><a class="docs-heading-anchor" href="#Fold-/-Hopf-Continuation-1">Fold / Hopf Continuation</a><a class="docs-heading-anchor-permalink" href="#Fold-/-Hopf-Continuation-1" title="Permalink"></a></h1><p>For this to work, it is important to have an analytical expression for the jacobian. See the tutorial <a href="../tutorials1/#Temperature-model-1">Temperature model</a> for more details.</p><h2 id="The-case-of-the-Fold-point-1"><a class="docs-heading-anchor" href="#The-case-of-the-Fold-point-1">The case of the Fold point</a><a class="docs-heading-anchor-permalink" href="#The-case-of-the-Fold-point-1" title="Permalink"></a></h2><p>Once a Fold point has been detected after a call to <code>br, _ = continuation(...)</code>, it can be refined using <code>newton</code> iterations. We have implemented a <strong>Minimally Augmented</strong> formulation. A simplified interface is provided.</p><h3 id="Newton-refinement-1"><a class="docs-heading-anchor" href="#Newton-refinement-1">Newton refinement</a><a class="docs-heading-anchor-permalink" href="#Newton-refinement-1" title="Permalink"></a></h3><p>Let us say that <code>ind_fold</code> is the index in <code>br.bifpoint</code> of a Fold point. This guess can be refined by calling the following simplified interface. More precisions are provided below for an advanced usage.</p><pre><code class="language-julia">outfold, hist, flag = @time newtonFold(
					(x, p) -&gt;   F(x, p),
					(x, p) -&gt; Jac(x, p),
					br, ind_fold,
					opt_newton)</code></pre><p>It is important to note that for improved performances, a function implementing the expression of the <strong>hessian</strong> should be provided. This is by far the fastest. Reader interested in this advanced usage should look at the code <code>example/chan.jl</code> of the tutorial <a href="../tutorials1/#Temperature-model-1">Temperature model</a>. Although it is a simple problem, many different use case are shown in a simple setting. See also <a href="#PseudoArcLengthContinuation.newtonFold"><code>newtonFold</code></a>.</p><h2 id="The-case-of-the-Hopf-point-1"><a class="docs-heading-anchor" href="#The-case-of-the-Hopf-point-1">The case of the Hopf point</a><a class="docs-heading-anchor-permalink" href="#The-case-of-the-Hopf-point-1" title="Permalink"></a></h2><p>One a Hopf point have been detected after a call to <code>br, _ = continuation(...)</code>, it can be refined using <code>newton</code> iterations. We have implemented a <strong>Minimally Augmented</strong> formulation. A simplified interface is provided as for the Fold case.</p><h3 id="Newton-refinement-2"><a class="docs-heading-anchor" href="#Newton-refinement-2">Newton refinement</a><a class="docs-heading-anchor-permalink" href="#Newton-refinement-2" title="Permalink"></a></h3><p>Let us say that <code>ind_hopf</code> is the index in <code>br.bifpoint</code> of a Hopf point. This guess can be refined by calling the simplified interface. More precisions are provided below for an advanced usage. See also <a href="#PseudoArcLengthContinuation.newtonHopf"><code>newtonHopf</code></a>.</p><pre><code class="language-julia">outfold, hist, flag = @time newtonHopf(
					(x, p) -&gt;   F(x, p),
					(x, p) -&gt; Jac(x, p),
					br, ind_hopf,
					opt_newton)</code></pre><h2 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonFold" href="#PseudoArcLengthContinuation.newtonFold"><code>PseudoArcLengthContinuation.newtonFold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">`newtonFold(F, J, foldpointguess::BorderedArray{vectype, T}, eigenvec, options::NewtonPar; Jt = nothing, d2F = nothing, normN = norm)`</code></pre><p>This function turns an initial guess for a Fold point into a solution to the Fold problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F   = (x, p) -&gt; F(x, p)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>dF  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>foldpointguess</code> initial guess (x<em>0, p</em>0) for the Fold point. It should be a <code>BorderedArray</code> as given by the function FoldPoint</li><li><code>eigenvec</code> guess for the 0 eigenvector</li><li><code>options::NewtonPar</code></li></ul><p>Optional arguments:</p><ul><li><code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian transpose, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method.</li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x,p)[v1,v2]</code>.</li><li><code>normN = norm</code></li></ul><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/888268b9c782be45e5f26aca6ff7d7e7b0f6496e/src/FoldCont.jl#L167-L187">source</a></section><section><div><p>Simplified call to refine an initial guess for a Fold point. More precisely, the call is as follows</p><pre><code class="language-none">`newtonFold(F, J, br::ContResult, index::Int64, options::NewtonPar; Jt = nothing, d2F = nothing)`</code></pre><p>where the optional argument <code>Jt</code> is the jacobian transpose and the Hessian is <code>d2F</code>. The parameters / options are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/888268b9c782be45e5f26aca6ff7d7e7b0f6496e/src/FoldCont.jl#L212-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonHopf" href="#PseudoArcLengthContinuation.newtonHopf"><code>PseudoArcLengthContinuation.newtonHopf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">`newtonHopf(F, J, hopfpointguess::BorderedArray{vectypeR, T}, eigenvec, eigenvec_ad, options::NewtonPar; Jt = nothing, d2F = nothing, normN = norm)`</code></pre><p>This function turns an initial guess for a Hopf point into a solution to the Hopf problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F  = (x, p) -&gt; F(x, p)</code> where <code>p</code> is the parameter associated to the Hopf point</li><li><code>J  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>hopfpointguess</code> initial guess (x<em>0, p</em>0) for the Hopf point. It should a <code>BorderedArray</code> as given by the function HopfPoint.</li><li><code>eigenvec</code> guess for the  iω eigenvector</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector</li><li><code>options::NewtonPar</code></li></ul><p>Optional arguments:</p><ul><li><code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian transpose</li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x,p)[v1, v2]</code>.</li><li><code>normN = norm</code></li></ul><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/888268b9c782be45e5f26aca6ff7d7e7b0f6496e/src/HopfCont.jl#L172-L193">source</a></section><section><div><p>Simplified call to refine an initial guess for a Hopf point. More precisely, the call is as follows</p><pre><code class="language-none">`newtonHopf(F, J, br::ContResult, index::Int64, options; Jt = nothing, d2F = nothing, normN = norm)`</code></pre><p>where the optional argument <code>Jt</code> is the jacobian transpose and the Hessian is <code>d2F</code>. The parameters are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><div class="admonition is-warning"><header class="admonition-header">Eigenvectors</header><div class="admonition-body"><p>This simplified call has been written when the eigenvectors are organised in a 2d Array <code>evec</code> where <code>evec[:,2]</code> is the second eigenvector in the list.</p></div></div><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/888268b9c782be45e5f26aca6ff7d7e7b0f6496e/src/HopfCont.jl#L218-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationFold" href="#PseudoArcLengthContinuation.continuationFold"><code>PseudoArcLengthContinuation.continuationFold</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p1, p2) -&gt;	F(x, p1, p2)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>J = (x, p1, p2) -&gt; d_xF(x, p1, p2)</code> associated jacobian</li><li><code>foldpointguess</code> initial guess (x<em>0, p1</em>0) for the Fold point. It should be a <code>BorderedArray</code> as given by the function FoldPoint</li><li><code>p2</code> parameter p2 for which <code>foldpointguess</code> is a good guess</li><li><code>eigenvec</code> guess for the 0 eigenvector at p1_0</li><li><code>options::NewtonPar</code></li></ul><p>Optional arguments:</p><ul><li><code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> associated jacobian transpose</li><li><code>d2F = p2 -&gt; ((x, p1, v1, v2) -&gt; d2F(x, p1, p2, v1, v2))</code> this is the hessian of <code>F</code> computed at <code>(x, p1, p2)</code> and evaluated at <code>(v1, v2)</code>.</li></ul><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/888268b9c782be45e5f26aca6ff7d7e7b0f6496e/src/FoldCont.jl#L235-L254">source</a></section><section><div><p>Simplified call for continuation of Fold point. More precisely, the call is as follows <code>continuationFold(F, J, br::ContResult, index::Int64, options; Jt = nothing, d2F = p2 -&gt; nothing)</code> where the parameters are as for <code>continuationFold</code> except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/888268b9c782be45e5f26aca6ff7d7e7b0f6496e/src/FoldCont.jl#L297-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationHopf" href="#PseudoArcLengthContinuation.continuationHopf"><code>PseudoArcLengthContinuation.continuationHopf</code></a> — <span class="docstring-category">Function</span></header><section><div><p>codim 2 continuation of Hopf points. This function turns an initial guess for a Hopf point into a curve of Hopf points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>(x, p1, p2)-&gt; F(x, p1, p2)</code> where <code>p</code> is the parameter associated to the hopf point</li><li><code>J = (x, p1, p2)-&gt; d_xF(x, p1, p2)</code> associated jacobian</li><li><code>hopfpointguess</code> initial guess (x<em>0, p1</em>0) for the Hopf point. It should be a <code>Vector</code> or a <code>BorderedArray</code></li><li><code>p2</code> parameter p2 for which hopfpointguess is a good guess</li><li><code>eigenvec</code> guess for the iω eigenvector at p1_0</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector at p1_0</li><li><code>options::NewtonPar</code></li></ul><p>Optional arguments:</p><ul><li><code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> associated jacobian transpose</li><li><code>d2F = p2 -&gt; ((x, p1, v1, v2) -&gt; d2F(x, p1, p2, v1, v2))</code> this is the hessian of <code>F</code> computed at <code>(x, p1, p2)</code> and evaluated at <code>(v1, v2)</code>.</li></ul><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/888268b9c782be45e5f26aca6ff7d7e7b0f6496e/src/HopfCont.jl#L247-L270">source</a></section><section><div><p>Simplified call for continuation of Hopf point. More precisely, the call is as follows <code>continuationHopf(F, J, br::ContResult, index::Int64, options; Jt = nothing, d2F = p2 -&gt; nothing)</code> where the parameters are as for <code>continuationHopf</code> except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><p>Simplified calls are also provided but at the cost of using finite differences.</p><div class="admonition is-warning"><header class="admonition-header">Eigenvectors</header><div class="admonition-body"><p>This simplified call has been written when the eigenvectors are organised in a 2d Array <code>evec</code> where <code>evec[:,2]</code> is the second eigenvector in the list.</p></div></div><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/888268b9c782be45e5f26aca6ff7d7e7b0f6496e/src/HopfCont.jl#L314-L327">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../detectionBifurcation/">« Bifurcations</a><a class="docs-footer-nextpage" href="../deflatedproblem/">Deflated problem »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 15 April 2020 15:04">Wednesday 15 April 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
