<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Pseudo Arc Length Continuation in Julia</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Pseudo Arc Length Continuation in Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Advanced Usage</span><ul><li><a class="toctext" href="../linearsolver/">Linear Solvers</a></li><li><a class="toctext" href="../detectionBifurcation/">Bifurcations</a></li><li><a class="toctext" href="../codim2Continuation/">Fold / Hopf Continuation</a></li><li><a class="toctext" href="../periodicOrbitCont/">Periodic Orbits</a></li></ul></li><li><a class="toctext" href="../faq/">Frequently Asked Questions</a></li><li class="current"><a class="toctext" href>Library</a><ul class="internal"><li><a class="toctext" href="#Structs-1">Structs</a></li><li><a class="toctext" href="#Newton-1">Newton</a></li><li><a class="toctext" href="#Newton-for-Fold-/-Hopf-1">Newton for Fold / Hopf</a></li><li><a class="toctext" href="#Continuation-1">Continuation</a></li><li><a class="toctext" href="#Continuation-for-Fold-/-Hopf-1">Continuation for Fold / Hopf</a></li><li><a class="toctext" href="#Plotting-1">Plotting</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Library</a></li></ul><a class="edit-page" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/master/docs/src/library.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Library</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><h2><a class="nav-anchor" id="Structs-1" href="#Structs-1">Structs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.PeriodicOrbitTrap" href="#PseudoArcLengthContinuation.PeriodicOrbitTrap"><code>PseudoArcLengthContinuation.PeriodicOrbitTrap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">pb = PeriodicOrbitTrap(F, J, ϕ, xπ, M::Int, linsolve)</code></pre><p>This structure implements Finite Differences based on Trapezoidal rule to locate periodic orbits. The arguements are as follows</p><ul><li>F vector field</li><li>J jacobian of the vector field</li><li>ϕ used for the Poincare section</li><li>xπ used for the Poincare section</li><li>M::Int number of slices in [0,2π]</li><li>linsolve &lt;: LinearSolver  linear solver</li></ul><p>You can then call pb(orbitguess) to apply the functional to a guess. Note that orbitguess must be of size M * N + 1 where N is the number of unknowns in the state space and <code>orbitguess[M*N+1]</code> is an estimate of the period of the limit cycle.</p><p>The scheme is as follows, one look for <code>T = x[end]</code> and  <span>$x_{i+1} - x_{i} - \frac{h}{2} \left(F(x_{i+1}) + F(x_i)\right) = 0$</span></p><p>where <code>h = T/M</code>. Finally, the phase of the periodic orbit is constraint by</p><p><span>$\langle x[1] - x\pi, \phi\rangle.$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/38e9fb7f809621e27c9a650be473e26b4c871465/base/#L0-L19">source</a></section><h2><a class="nav-anchor" id="Newton-1" href="#Newton-1">Newton</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.newton" href="#PseudoArcLengthContinuation.newton"><code>PseudoArcLengthContinuation.newton</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">	newton(F, J, x0, options, normN = norm)</code></pre><p>This is the Newton Solver for <code>F(x) = 0</code> with Jacobian <code>J</code> and initial guess <code>x0</code>. The function <code>normN</code> allows to specify a norm for the convergence criteria. It is important to set the linear solver <code>options.linsolve</code> properly depending on your problem. This solver is used to solve <span>$J(x)u = -F(x)$</span> in the Newton step. You can for example use <code>linsolve = Default()</code> which is the operator backslash: it works well for Sparse / Dense matrices. Iterative solver (GMRES) are also provided. You should implement your own solver for maximal efficiency. This is quite easy to do, have a look at <code>src/LinearSolver.jl</code>. The functions or callable which need to be passed are as follows:</p><ul><li><code>x -&gt; F(x)</code> functional whose zeros are looked for. In particular, it is not <strong>inplace</strong>,</li><li><code>dF(x) = x -&gt; J(x)</code> compute the jacobian of <code>F</code> at <code>x</code>. It is then passed to <code>options.linsolve</code>. The Jacobian can be a matrix or an out of place function.</li></ul><p>Simplified calls are provided, for example when <code>J</code> is not passed. It then computed with finite differences.</p><p><strong>Output:</strong></p><ul><li>solution:</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/35265e50000807af053fbaa85fc7baa69234bc60/src/Newton.jl#L88-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonDeflated" href="#PseudoArcLengthContinuation.newtonDeflated"><code>PseudoArcLengthContinuation.newtonDeflated</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">newtonDeflated(Fhandle::Function, Jhandle, x0, options:: NewtonPar{T}, defOp::DeflationOperator{T, vectype})</code></pre><p>This is the deflated version of the Newton Solver. It penalises the roots saved in <code>defOp.roots</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/35265e50000807af053fbaa85fc7baa69234bc60/src/Newton.jl#L150-L154">source</a></section><h2><a class="nav-anchor" id="Newton-for-Fold-/-Hopf-1" href="#Newton-for-Fold-/-Hopf-1">Newton for Fold / Hopf</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,Any,Any,BorderedArray{vectype,T},Any,NewtonPar}} where vectype where T" href="#PseudoArcLengthContinuation.newtonFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,Any,Any,BorderedArray{vectype,T},Any,NewtonPar}} where vectype where T"><code>PseudoArcLengthContinuation.newtonFold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function turns an initial guess for a Fold point into a solution to the Fold problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F   = (x, p) -&gt; F(x, p)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>dF  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>dFt = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian, it should be implemented in an efficient manner. For matrix-free methods, <code>tranpose</code> is not readily available.</li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x,p)[v1,v2]</code>.</li><li><code>foldpointguess</code> initial guess (x<em>0, p</em>0) for the Fold point. It should be a <code>BorderedArray</code> as given by the function FoldPoint</li><li><code>eigenvec</code> guess for the 0 eigenvector</li><li><code>options::NewtonPar</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/35265e50000807af053fbaa85fc7baa69234bc60/src/FoldCont.jl#L148-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonFold-Tuple{Any,Any,Any,Any,ContResult,Int64,NewtonPar}" href="#PseudoArcLengthContinuation.newtonFold-Tuple{Any,Any,Any,Any,ContResult,Int64,NewtonPar}"><code>PseudoArcLengthContinuation.newtonFold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Simplified call to refine an initial guess for a Fold point. More precisely, the call is as follows</p><pre><code class="language-none">`newtonFold(F, J, Jt, br::ContResult, index::Int64, options)`</code></pre><p>or</p><pre><code class="language-none">`newtonFold(F, J, Jt, d2F, br::ContResult, index::Int64, options)`</code></pre><p>when the Hessian d2F is known. The parameters are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/35265e50000807af053fbaa85fc7baa69234bc60/src/FoldCont.jl#L190-L200">source</a></section><h2><a class="nav-anchor" id="Continuation-1" href="#Continuation-1">Continuation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.continuation" href="#PseudoArcLengthContinuation.continuation"><code>PseudoArcLengthContinuation.continuation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">continuation(F, J, u0, p0::Real, contParams::ContinuationPar; plot = false, normC = norm, printsolution = norm, plotsolution::Function = (x; kwargs...)-&gt;nothing, finaliseSolution::Function = (z, tau, step, contResult) -&gt; true, linearalgo = :bordering, verbosity = 2)</code></pre><p>Compute the continuation curve associated to the functional <code>F</code> and its jacobian <code>J</code>. The parameters are as follows</p><ul><li><code>F = (x, p) -&gt; F(x, p)</code> where <code>p</code> is the parameter for the continuation</li><li><code>J = (x, p) -&gt; d_xF(x, p)</code> its associated jacobian. It can be a matrix, a function or a callable struct.</li><li><code>u0</code> initial guess</li><li><code>contParams</code> parameters for continuation, with struct <code>ContinuationPar</code></li><li><code>plot = false</code> whether to plot the solution while computing</li><li><code>printsolution::Function = norm</code> function used to plot in the continuation curve, e.g. <code>norm</code> or <code>x -&gt; x[1]</code></li><li><code>plotsolution::Function = (x; kwargs...) -&gt; nothing</code> function implementing the plot of the solution.</li><li><code>finaliseSolution::Function = (z, tau, step, contResult) -&gt; true</code> Function called at the end of each continuation step. Can be used to alter the continuation step (stop it by returning false) or saving personal data...</li><li><code>linearalgo = :bordering</code>. Must belong to <code>[:bordering, :full]</code>. Used to control the way the extended linear system associated to the continuation problem is solved.</li><li><code>verbosity</code> controls the amount of information printed during the continuation process.</li><li><code>normC = norm</code> norm used in the different Newton solves</li></ul><p>The function outputs</p><ul><li><code>contres::ContResult</code> structure which contains the computed branch</li><li><code>u::BorderedArray</code> the last solution computed on the branch</li></ul><p><strong>Method</strong></p><p><strong>Bordered system of equations</strong></p><p>The pseudo arclength continuation method solves the equation <span>$F(x,p) = 0$</span> (or dimension N) together with the pseudo-arclength constraint <span>$N(x, p) = \frac{\theta}{length(x)} \langle x - x_0, \tau_0\rangle + (1 - \theta)\cdot(p - p_0)\cdot dp_0 - ds = 0$</span>. In practice, the curve is parametrised by <span>$s$</span> so that <span>$(x(s),p(s))$</span> is a curve of solutions to <span>$F(x,p)$</span>. This formulation allows to pass turning points (where the implicit theorem fails). In the previous formula, <span>$(x_0, p_0)$</span> is a solution for a given <span>$s_0$</span>, <span>$(\tau_0, dp_0)$</span> is the tangent to the curve at <span>$s_0$</span>. Hence, to compute the curve of solutions, we need solve an equation of dimension N+1 which is called a Bordered system.</p><div class="admonition warning"><div class="admonition-title">Parameter `theta`</div><div class="admonition-text"><p>The parameter <code>theta</code> in the struct <code>ContinuationPar</code>is very important. It should be tuned for the continuation to work properly especially in the case of large problems where the <span>$\langle x - x_0, \tau_0\rangle$</span> component in the constraint might be favoured too much.</p></div></div><p>The parameter ds is adjusted internally depending on the number of Newton iterations and other factors. See the function <code>stepSizeControl</code> for more information. An important parameter to adjust the magnitude of this adaptation is the parameter <code>a</code> in the struct <code>ContinuationPar</code>.</p><p><strong>Algorithm</strong></p><p>The algorithm works as follows:</p><ol><li>Start from a known solution <span>$(x_0,p_0,\tau_0,dp_0)$</span></li><li><strong>Predictor</strong> set <span>$(x_1,p_1) = (x_0,p_0) + ds\cdot (\tau_0,dp_0)$</span></li><li><strong>Corrector</strong> solve <span>$F(x,p)=0,\ N(x,p)=0$</span> with a (Bordered) Newton Solver.</li><li><strong>New tangent</strong> Compute <span>$(\tau_1,dp_1)$</span>, set <span>$(x_0,p_0,\tau_0,dp_0)=(x_1,p_1,\tau_1,dp_1)$</span> and return to step 2</li></ol><p><strong>Natural continuation</strong></p><p>We speak of <em>natural</em> continuation when we do not consider the constraint <span>$N(x,p)=0$</span>. Knowing <span>$(x_0,p_0)$</span>, we use <span>$x_0$</span> as a guess for solving <span>$F(x,p_1)=0$</span> with <span>$p_1$</span> close to <span>$p_0$</span>. Again, this will fail at Turning points but it can be faster to compute than the constrained case. This is set by the field <code>natural</code> in the struct <code>ContinuationPar</code></p><p><strong>Tangent computation (step 4)</strong></p><p>There are various ways to compute <span>$(\tau_1,p_1)$</span>. The first one is called secant and is parametrised by the field <code>secant</code> in the struct <code>ContinuationPar</code>. It is computed by <span>$(\tau_1,p_1) = (z_1,p_1) - (z_0,p_0)$</span> and normalised by the norm <span>$\|u,p\|^2_\theta = \frac{\theta}{length(u)} \langle u,u\rangle + (1 - \theta)\cdot p^2$</span>. If <code>secant</code> is set to <code>false</code>, another method is use computing <span>$(\tau_1,p_1)$</span> by solving a bordered linear system, see the function <code>getTangentBordered</code> for more information.</p><p><strong>Bordered linear solver</strong></p><p>When solving the Bordered system <span>$F(x,p) = 0,\ N(x, p)=0$</span>, one faces the issue of solving the Bordered linear system <span>$\begin{bmatrix} J &amp; a    ; b^T &amp; c\end{bmatrix}\begin{bmatrix}X ;  y\end{bmatrix} =\begin{bmatrix}R ; n\end{bmatrix}$</span>. This can be solved in many ways via bordering (which requires two Jacobian inverses) or by forming the bordered matrix (which works well for sparse matrices). The choice of method is set by the argument <code>linearalgo</code>. Have a look at the function <code>linearBorderedSolver</code> for more information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/35265e50000807af053fbaa85fc7baa69234bc60/src/PseudoArcLengthContinuation.jl#L131-L180">source</a></section><h2><a class="nav-anchor" id="Continuation-for-Fold-/-Hopf-1" href="#Continuation-for-Fold-/-Hopf-1">Continuation for Fold / Hopf</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,Any,Any,BorderedArray{vectype,T},T,Any,ContinuationPar}} where vectype where T" href="#PseudoArcLengthContinuation.continuationFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,Any,Any,BorderedArray{vectype,T},T,Any,ContinuationPar}} where vectype where T"><code>PseudoArcLengthContinuation.continuationFold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p1, p2) -&gt;	F(x, p1, p2)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>J = (x, p1, p2) -&gt; d_xF(x, p1, p2)</code> associated jacobian</li><li><code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> associated jacobian</li><li><code>d2F = (x, p1, p2, v1, v2) -&gt; d2F(x, p1, p2, v1, v2)</code> this is the hessian of <code>F</code> computed at <code>(x, p1, p2)</code> and evaluated at <code>(v1, v2)</code>.</li><li><code>foldpointguess</code> initial guess (x<em>0, p1</em>0) for the Fold point. It should be a <code>BorderedArray</code> as given by the function FoldPoint</li><li><code>p2</code> parameter p2 for which foldpointguess is a good guess</li><li><code>eigenvec</code> guess for the 0 eigenvector at p1_0</li><li><code>options::NewtonPar</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/35265e50000807af053fbaa85fc7baa69234bc60/src/FoldCont.jl#L228-L238">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,Any,BorderedArray{vectype,T},T,Any,ContinuationPar}} where vectype where T" href="#PseudoArcLengthContinuation.continuationFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,Any,BorderedArray{vectype,T},T,Any,ContinuationPar}} where vectype where T"><code>PseudoArcLengthContinuation.continuationFold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p1, p2) -&gt; F(x, p1, p2)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>J = (x, p1, p2) -&gt; d_xF(x, p1, p2)</code> associated jacobian</li><li><code>foldpointguess</code> initial guess (x<em>0, p1</em>0) for the Fold point. It should be a <code>BorderedArray</code> as given by the function FoldPoint</li><li><code>p2</code> parameter p2 for which foldpointguess is a good guess</li><li><code>eigenvec</code> guess for the 0 eigenvector at p1_0</li><li><code>options::NewtonPar</code></li></ul><div class="admonition warning"><div class="admonition-title">Hessian</div><div class="admonition-text"></div></div><pre><code class="language-none">The hessian of `F` in this case is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/35265e50000807af053fbaa85fc7baa69234bc60/src/FoldCont.jl#L269-L281">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationFold-Tuple{Any,Any,Any,Any,ContResult,Int64,Real,ContinuationPar}" href="#PseudoArcLengthContinuation.continuationFold-Tuple{Any,Any,Any,Any,ContResult,Int64,Real,ContinuationPar}"><code>PseudoArcLengthContinuation.continuationFold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Simplified call for continuation of Fold point. More precisely, the call is as follows <code>continuationFold(F, J, Jt, d2F, br::ContResult, index::Int64, options)</code> where the parameters are as for <code>continuationFold</code> except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><p>Simplified calls are also provided but at the cost of using finite differences.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/35265e50000807af053fbaa85fc7baa69234bc60/src/FoldCont.jl#L295-L299">source</a></section><h2><a class="nav-anchor" id="Plotting-1" href="#Plotting-1">Plotting</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.plotBranch-Tuple{ContResult}" href="#PseudoArcLengthContinuation.plotBranch-Tuple{ContResult}"><code>PseudoArcLengthContinuation.plotBranch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Plot the branch of solutions from a <code>ContResult</code>. You can also pass parameters like <code>plotBranch(br, marker = :dot)</code>. For the continuation diagram, the legend is as follows <code>(:fold =&gt; :black, :hopf =&gt; :red, :bp =&gt; :blue, :nd =&gt; :magenta, :none =&gt; :yellow)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/35265e50000807af053fbaa85fc7baa69234bc60/src/utils.jl#L85-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.plotBranch!-Tuple{ContResult}" href="#PseudoArcLengthContinuation.plotBranch!-Tuple{ContResult}"><code>PseudoArcLengthContinuation.plotBranch!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Append to the current plot the plot of the branch of solutions from a <code>ContResult</code>. You can also pass parameters like <code>plotBranch!(br, marker = :dot)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/35265e50000807af053fbaa85fc7baa69234bc60/src/utils.jl#L104-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.plotBranch-Tuple{Array{T,1} where T}" href="#PseudoArcLengthContinuation.plotBranch-Tuple{Array{T,1} where T}"><code>PseudoArcLengthContinuation.plotBranch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Plot all the branches contained in <code>brs</code> in a single figure. Convenient when many bifurcation diagram have been computed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/35265e50000807af053fbaa85fc7baa69234bc60/src/utils.jl#L94-L96">source</a></section><footer><hr/><a class="previous" href="../faq/"><span class="direction">Previous</span><span class="title">Frequently Asked Questions</span></a></footer></article></body></html>
