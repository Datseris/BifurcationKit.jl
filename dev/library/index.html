<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Pseudo Arc Length Continuation in Julia</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Pseudo Arc Length Continuation in Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Advanced Usage</span><ul><li><a class="toctext" href="../linearsolver/">Linear Solvers</a></li><li><a class="toctext" href="../detectionBifurcation/">Bifurcations</a></li><li><a class="toctext" href="../codim2Continuation/">Fold / Hopf Continuation</a></li><li><a class="toctext" href="../periodicOrbitCont/">Periodic Orbits</a></li></ul></li><li><a class="toctext" href="../faq/">Frequently Asked Questions</a></li><li class="current"><a class="toctext" href>Library</a><ul class="internal"><li><a class="toctext" href="#Functions-1">Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Library</a></li></ul><a class="edit-page" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/master/docs/src/library.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Library</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.newton" href="#PseudoArcLengthContinuation.newton"><code>PseudoArcLengthContinuation.newton</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">	newton(F, J, x0, options, normN = norm)</code></pre><p>This is the Newton Solver for <code>F(x) = 0</code> with Jacobian <code>J</code> and initial guess <code>x0</code>. The function <code>normN</code> allows to specify a norm for the convergence criteria. It is important to set the linear solver <code>options.linsolve</code> properly depending on your problem. This solver is used to solve <span>$J(x)u = -F(x)$</span> in the Newton step. You can for example use <code>Default()</code> which is the operator backslash which works well for Sparse / Dense matrices. Iterative solver (GMRES) are also implemented. You should implement your own for maximal efficiency. This is quite easy to do, have a look at <code>src/LinearSolver.jl</code></p><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/9f8caf255ff9d4768952202049074ceeadae3fed/src/Newton.jl#L87-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonDeflated" href="#PseudoArcLengthContinuation.newtonDeflated"><code>PseudoArcLengthContinuation.newtonDeflated</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">newtonDeflated(Fhandle::Function, Jhandle, x0, options:: NewtonPar{T}, defOp::DeflationOperator{T, vectype})</code></pre><p>This is the deflated version of the Newton Solver. It penalises the roots saved in <code>defOp.roots</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/9f8caf255ff9d4768952202049074ceeadae3fed/src/Newton.jl#L145-L149">source</a></section><pre><code class="language-none">newtonFold</code></pre><pre><code class="language-none">newtonHopf</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PseudoArcLengthContinuation.continuation" href="#PseudoArcLengthContinuation.continuation"><code>PseudoArcLengthContinuation.continuation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">continuation(F::Function, J, u0, p0::Real, contParams::ContinuationPar; plot = false, printsolution = norm, plotsolution::Function = (x;kwargs...)-&gt;nothing, finaliseSolution::Function = (x, y)-&gt; nothing, linearalgo   = :bordered, verbosity = 2)</code></pre><p>Compute the continuation curve associated to the functional <code>F</code> and its jacobian <code>J</code>. The parameters are as follows</p><ul><li><code>F = (x, p) -&gt; F(x, p)</code> where <code>p</code> is the parameter for the continuation</li><li><code>J = (x, p) -&gt; d_xF(x, p)</code> its associated jacobian</li><li><code>u0</code> initial guess</li><li><code>contParams</code> parameters for continuation, with type <code>ContinuationPar</code></li><li><code>plot = false</code> whether to plot the solution while computing</li><li><code>printsolution = norm</code> function used to plot in the continuation curve, e.g. <code>norm</code> or <code>x -&gt; x[1]</code></li><li><code>plotsolution::Function = (x; kwargs...)-&gt;nothing</code> function implementing the plotting of the solution.</li><li><code>finaliseSolution::Function = (z, tau, step, contResult) -&gt; nothing</code> Function called at the end of each continuation step</li><li><code>linearalgo   = :bordered</code></li><li><code>verbosity</code> controls the amount of information printed during the continuation process.</li></ul><p>The function outputs</p><ul><li><code>contres::ContResult</code> structure which contains the computed branch</li><li><code>u::BorderedVector</code> the last solution computed on the branch</li></ul><p><strong>Method</strong></p><p><strong>Bordered system of equations</strong></p><p>The pseudo arclength continuation method solve the equation <span>$F(x,p) = 0$</span> (or dimension N) together with the pseudo-arclength consraint <span>$N(x, p) = \frac{\theta}{length(u)} \langle x - x_0, \tau_0\rangle + (1 - \theta)\cdot(p - p_0)\cdot dp_0 - ds = 0$</span>. In practice, the curve is parametrised by <span>$s$</span> so that <span>$(x(s),p(s))$</span> is a curve of solution to <span>$F(x,p)$</span>. This formulation allows to pass turning points (where the implicit theorem fails). In the previous formula, <span>$(x_0, p_0)$</span> is a solution for a given <span>$s_0$</span>, <span>$(\tau_0, dp_0)$</span> is the tangent to the curve at <span>$s_0$</span>. Hence, to compute the solution curve, we solve an equation of dimension N+1 which is called a Bordered system.</p><div class="admonition warning"><div class="admonition-title">Parameter `theta`</div><div class="admonition-text"><p>The parameter <code>theta</code> in the type <code>ContinuationPar</code>is very important. It should be tuned for the continuation to work properly especially in the case of large problems in which cases the <span>$\langle x - x_0, \tau_0\rangle$</span> component in the constraint might be favoured to much.</p></div></div><p>The parameter ds is adjusted internally depending on the number of Newton iterations and other factors. See the function <code>stepSizeControl</code> for more information. An important parameter to adjust the magnitude of this adaptation is the parameter <code>a</code> in the type <code>ContinuationPar</code>.</p><p><strong>Algorithm</strong></p><p>The algorithm works as follows:</p><ol><li>Start from a known solution <span>$(x_0,p_0,\tau_0,dp_0)$</span></li><li><strong>Predictor</strong> set <span>$(x_1,p_1) = (x_0,p_0) + ds\cdot (\tau_0,dp_0)$</span></li><li><strong>Corrector</strong> solve <span>$F(x,p)=0,\ N(x,p)=0$</span> with a (Bordered) Newton Solver.</li><li><strong>New tangent</strong> Compute <span>$(\tau_1,dp_1)$</span>, set <span>$(x_0,p_0,\tau_0,dp_0)=(x_1,p_1,\tau_1,dp_1)$</span> and return to step 2</li></ol><p><strong>Natural continuation</strong></p><p>We speak of <em>natural</em> continuation when we do not consider the constraint <span>$N(x,p)=0$</span>. Knowing <span>$(x_0,p_0)$</span>, we use <span>$x_0$</span> as a guess for solving <span>$F(x,p_1)=0$</span> with <span>$p_1$</span> close to <span>$p_0$</span>. Again, this will fail at Turning Point but it can be faster to compute than the constrained case. This is set by the field <code>natural</code> in the type ContinuationPar`</p><p><strong>Tangent computation (step 4)</strong></p><p>There are various ways to compute <span>$(\tau_1,p_1)$</span>. The first one is called secant and is parametrised by the field <code>secant</code> in the type <code>ContinuationPar</code>. It is computed by <span>$(\tau_1,p_1) = (z_1,p_1) - (z_0,p_0)$</span> and normalised by the norm <span>$\|u,p\|^2_\theta = \frac{\theta}{length(u)} \langle u,u\rangle + (1 - \theta)\cdot p^2$</span>. If <code>secant</code> is set to <code>false</code>, another method is use computing <span>$(\tau_1,p_1)$</span> by solving a bordered linear system, see the function <code>getTangentBordered</code> for more information.</p><p><strong>Bordered linear solver</strong></p><p>When solving the Bordered system <span>$F(x,p) = 0,\ N(x, p)=0$</span>, one faces the issue of solving the Bordered linear system <span>$\begin{bmatrix} J &amp; a    ; b^T &amp; c\end{bmatrix}\begin{bmatrix}X ;  y\end{bmatrix} =\begin{bmatrix}R ; n\end{bmatrix}$</span>. This can be solved in many ways via bordering (which requires to Jacobian inverses) or by forming the bordered matrix (which works well for sparse matrices). The choice of method is set by the argument <code>linearalgo</code>. Have a look at the function <code>linearBorderedSolver</code> for more information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation/blob/9f8caf255ff9d4768952202049074ceeadae3fed/src/PseudoArcLengthContinuation.jl#L130-L178">source</a></section><pre><code class="language-none">continuationFold</code></pre><pre><code class="language-none">continuationHopf</code></pre><footer><hr/><a class="previous" href="../faq/"><span class="direction">Previous</span><span class="title">Frequently Asked Questions</span></a></footer></article></body></html>
