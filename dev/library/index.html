<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Pseudo Arc Length Continuation in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Pseudo Arc Length Continuation in Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials1/">1/ Temperature model</a></li><li><a class="tocitem" href="../tutorials1b/">2/ Temperature model with Spectral Collocation</a></li><li><a class="tocitem" href="../tutorials2/">3/ Swift-Hohenberg</a></li><li><a class="tocitem" href="../tutorials2b/">4/ The Swift-Hohenberg on the GPU (non-local)</a></li><li><a class="tocitem" href="../tutorials3/">5/ Brusselator 1d</a></li><li><a class="tocitem" href="../tutorialsPD/">6/ Period Doubling in BVAM model</a></li><li><a class="tocitem" href="../tutorialsCGL/">7/ Ginzburg-Landau 2d (GPU)</a></li><li><a class="tocitem" href="../tutorialsCGLShoot/">8/ Ginzburg-Landau 2d (Shooting)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Advanced Usage</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li><li><a class="tocitem" href="../linearsolver/">Linear / Eigen Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../detectionBifurcation/">Bifurcations</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><a class="tocitem" href="../periodicOrbitFD/">Periodic Orbits (Finite Differences)</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Periodic Orbits (Shooting)</a></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Structs-1"><span>Structs</span></a></li><li><a class="tocitem" href="#Newton-1"><span>Newton</span></a></li><li><a class="tocitem" href="#Newton-with-deflation-1"><span>Newton with deflation</span></a></li><li><a class="tocitem" href="#Newton-for-Fold-/-Hopf-1"><span>Newton for Fold / Hopf</span></a></li><li><a class="tocitem" href="#Newton-for-Periodic-Orbits-1"><span>Newton for Periodic Orbits</span></a></li><li><a class="tocitem" href="#Continuation-1"><span>Continuation</span></a></li><li><a class="tocitem" href="#Continuation-for-Fold-/-Hopf-1"><span>Continuation for Fold / Hopf</span></a></li><li><a class="tocitem" href="#Continuation-for-periodic-orbits-1"><span>Continuation for periodic orbits</span></a></li><li><a class="tocitem" href="#Plotting-1"><span>Plotting</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-1"><a class="docs-heading-anchor" href="#Library-1">Library</a><a class="docs-heading-anchor-permalink" href="#Library-1" title="Permalink"></a></h1><h2 id="Structs-1"><a class="docs-heading-anchor" href="#Structs-1">Structs</a><a class="docs-heading-anchor-permalink" href="#Structs-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.NewtonPar" href="#PseudoArcLengthContinuation.NewtonPar"><code>PseudoArcLengthContinuation.NewtonPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">options = NewtonPar(tol = 1e-4,...)</code></pre><p>Returns a variable containing parameters to affect the <code>newton</code> algorithm when solving <code>F(x) = 0</code>.</p><p><strong>Arguments (with default values):</strong></p><ul><li><code>tol = 1e-10</code>: absolute tolerance for <code>F(x)</code></li><li><code>maxIter = 50</code>: number of Newton iterations</li><li><code>verbose = false</code>: display Newton iterations?</li><li><code>linsolver = DefaultLS()</code>: linear solver, must be <code>&lt;: AbstractLinearSolver</code></li><li><code>eigsolver = DefaultEig()</code>: eigen solver, must be <code>&lt;: AbstractEigenSolver</code></li></ul><p><strong>Arguments only used in <code>newtonPALC</code></strong></p><ul><li><code>linesearch = false</code>: use line search algorithm</li><li><code>alpha = 1.0</code>: alpha (damping) parameter for line search algorithm</li><li><code>almin  = 0.001</code>: minimal vslue of the damping <code>alpha</code></li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Setfield.jl</code> to drastically simplify the mutation of different fields. See tutorials for more examples.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.ContinuationPar" href="#PseudoArcLengthContinuation.ContinuationPar"><code>PseudoArcLengthContinuation.ContinuationPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">options = ContinuationPar(dsmin = 1e-4,...)</code></pre><p>Returns a variable containing parameters to affect the <code>continuation</code> algorithm when solving <code>F(x,p) = 0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dsmin, dsmax</code> are the minimum, maximum arclength allowed value. It controls the density of points in the computed branch of solutions.</li><li><code>ds</code> is the initial arclength.</li><li><code>theta</code> is a parameter in the arclength constraint. It is very <strong>important</strong> to tune it. See the docs of <a href="#PseudoArcLengthContinuation.continuation"><code>continuation</code></a>.</li><li><code>pMin, pMax</code> allowed parameter range for <code>p</code></li><li><code>maxSteps</code> maximum number of continuation steps</li><li><code>newtonOptions::NewtonPar</code>: options for the Newton algorithm</li><li><code>saveToFile = false</code>: save to file. A name is automatically generated.</li><li><code>saveSolEveryNsteps::Int64 = 0</code> at which continuation steps do we save the current solution`</li><li><code>plotEveryNsteps = 3</code></li></ul><p>Handling eigen elements</p><ul><li><code>computeEigenValues = false</code> compute eigenvalues / eigenvectors</li><li><code>nev = 3</code> number of eigenvalues to be computed. It is automatically increased to have at least <code>nev</code> unstable eigenvalues. To be set for proper  bifurcation detection. See <a href="../detectionBifurcation/#Detection-of-bifurcation-points-1">Detection of bifurcation points</a> for more informations.</li><li><code>saveEigEveryNsteps = 1</code>	record eigen vectors every specified steps. <strong>Important</strong> for memory limited ressource, <em>e.g.</em> GPU.</li><li><code>saveEigenvectors	= true</code>	<strong>Important</strong> for memory limited ressource, <em>e.g.</em> GPU.</li></ul><p>Handling bifurcation detection</p><ul><li><code>precisionStability = 1e-10</code> lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits</li><li><code>detectFold = true</code> detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)</li><li><code>detectBifurcation::Int</code> ∈ {0, 1, 2} detect bifurcations? If set to 0, bifurcation are not detected. If set to 1, bifurcation are detected along the continuation run, but not located precisely. If set to 2, a bisection algorithm is used to locate the bifurcations (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory in memory limited devices (e.g. on GPU)</li><li><code>dsminBisection</code> dsmin for the bisection algorithm when locating bifurcation points</li><li><code>nInversion</code> number of sign inversions in bisection algorithm</li><li><code>maxBisectionSteps</code> maximum number of bisection steps</li></ul><p>Handling <code>ds</code> adaptation (see <a href="#PseudoArcLengthContinuation.continuation"><code>continuation</code></a> for more information)</p><ul><li><code>a  = 0.5</code> aggressiveness factor. It is used to adapt <code>ds</code> in order to have a number of newton iteration per continuation step roughly the same. The higher <code>a</code> is, the larger the step size <code>ds</code> is changed at each continuation step.</li><li><code>thetaMin = 1.0e-3</code> minimum value of <code>theta</code></li><li><code>doArcLengthScaling</code> trigger further adaptation of <code>theta</code></li></ul><p>Misc</p><ul><li><code>finDiffEps::T  = 1e-9</code> ε used in finite differences computations</li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Setfield.jl</code> to drastically simplify the mutation of different fields. See tutorials for more examples.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.PrecPartialSchurKrylovKit" href="#PseudoArcLengthContinuation.PrecPartialSchurKrylovKit"><code>PseudoArcLengthContinuation.PrecPartialSchurKrylovKit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">PrecPartialSchurKrylovKit(J, x0, nev, which = :LM; krylovdim = max(2nev, 20), verbosity = 0)</code></pre><p>Builds a preconditioner based on deflation of <code>nev</code> eigenvalues chosen according to <code>which</code>. A partial Schur decomposition is build (Matrix-Free) from which a projection is built. The package KrylovKit.jl is used to compute the partial Schur decomposition. The options are similar to the ones of <code>EigKrylovKit()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/Preconditioner.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.PrecPartialSchurArnoldiMethod" href="#PseudoArcLengthContinuation.PrecPartialSchurArnoldiMethod"><code>PseudoArcLengthContinuation.PrecPartialSchurArnoldiMethod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">PrecPartialSchurArnoldiMethod(J, N, nev, which = LM(); tol = 1e-9, kwargs...)</code></pre><p>Builds a preconditioner based on deflation of <code>nev</code> eigenvalues chosen according to <code>which</code>. A partial Schur decomposition is build (Matrix-Free) from which a projection is built. The package <code>ArnoldiMethod.jl</code> is used to compute the partial Schur decomposition. See the package <code>ArnoldiMethod.jl</code> for how to pass the proper options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/Preconditioner.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.ContResult" href="#PseudoArcLengthContinuation.ContResult"><code>PseudoArcLengthContinuation.ContResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ContResult{T, Eigentype, Vectype, Biftype}</code></pre><p>Structure which holds the results after a call to <a href="#PseudoArcLengthContinuation.continuation"><code>continuation</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>branch::VectorOfArray</code> holds the low-dimensional information about the branch. More precisely, <code>branch[:,i]</code> contains the following information <code>(param, printSolution(u, param), Newton iterations, ds, i)</code> for each continuation step <code>i</code>.</li><li><code>n_unstable::Vector{Int64}</code> a vector holding the number of eigenvalues with positive real part for each continuation step	(to detect stationary bifurcation)</li><li><code>n_imag::Vector{Int64}</code> a vector holding the number of eigenvalues with positive real part and non zero imaginary part for each continuation step (to detect Hopf bifurcation)</li><li><code>stability::Vector{Bool}</code> a vector holding the stability of the computed solution for each continuation step</li><li><code>bifpoint::Vector{Biftype}</code> a vector holding the set of bifurcation points detected during the computation of the branch. Each entry of the vector contains a tuple <code>(type, idx, param = T(0.), norm, printsol, u, tau, ind_bif, step, status)</code> where <code>step</code> is the continuation step at which the bifurcation occurs, <code>ind_bif</code> is the eigenvalue index responsible for the bifurcation (if applicable) and <code>idx</code> is the index in <code>eig</code> (see above) for which the bifurcation occurs.</li><li><code>foldpoint::Vector{Biftype}</code> a vector holding the set of fold points detected during the computation of the branch.</li><li><code>eig::Vector</code> contains for each continuation step the eigen elements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.DeflationOperator" href="#PseudoArcLengthContinuation.DeflationOperator"><code>PseudoArcLengthContinuation.DeflationOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DeflationOperator. It is used to describe the following situation. Assume you want to solve <code>F(x)=0</code> with a Newton algorithm but you want to avoid the process to return some already known solutions <span>$roots_i$</span>. You can use <code>DeflationOperator</code> to define a function <code>M(u)</code> used to find, with Newton iterations, the zeros of the following function <span>$F(u) / Π_i(dot(u - roots_i, u - roots_i)^{p} + shift) := F(u) / M(u)$</span>. The fields of the struct <code>DeflationOperator</code> are as follows:</p><ul><li>power <code>p</code></li><li><code>dot</code> function, this function has to be bilinear and symmetric for the linear solver</li><li>shift</li><li>roots</li></ul><p>The deflation operator is is <span>$M(u) = \frac{1}{\prod_{i=1}^{n_{roots}}(shift + norm(u-roots_i)^p)}$</span> where <span>$nrm(u) = dot(u,u)$</span>.</p><p>Given <code>defOp::DeflationOperator</code>, one can access its roots as <code>defOp[n]</code> as a shortcut for <code>defOp.roots[n]</code>. Also, one can add (resp.remove) a new root by using <code>push!(defOp, newroot)</code> (resp. <code>pop!(defOp)</code>). Finally <code>length(defOp)</code> is a shortcut for <code>length(defOp.roots)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/DeflationOperator.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.DeflatedProblem" href="#PseudoArcLengthContinuation.DeflatedProblem"><code>PseudoArcLengthContinuation.DeflatedProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">pb = DeflatedProblem(F, J, M::DeflationOperator)</code></pre><p>This creates a problem encoded a deflated problem <span>$M(u) \cdot F(u) = 0$</span> where <code>M</code> is a <code>DeflationOperator</code> which encodes the penalization term. <code>J</code> is the jacobian of <code>J</code>. Can be used to call <code>newton</code> and <code>continuation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/DeflationOperator.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.PeriodicOrbitTrapProblem" href="#PseudoArcLengthContinuation.PeriodicOrbitTrapProblem"><code>PseudoArcLengthContinuation.PeriodicOrbitTrapProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">pb = PeriodicOrbitTrapProblem(F, J, ϕ, xπ, M::Int)</code></pre><p>This composite type implements Finite Differences based on a Trapezoidal rule to locate periodic orbits. The arguments are as follows</p><ul><li><code>F</code> vector field</li><li><code>J</code> jacobian of <code>F</code></li><li><code>d2F = nothing</code> Hessian of F (optional), useful for continuation of Fold of periodic orbits</li><li><code>ϕ</code> used to set a section for the phase constraint equation</li><li><code>xπ</code> used in the section for the phase constraint equation</li><li><code>M::Int</code> number of time slices</li><li><code>linsolver: = DefaultLS()</code> linear solver for each time slice, i.e. to solve <code>J⋅sol = rhs</code>. This is only used for the computation of the Floquet multipliers.</li><li><code>isinplace::Bool</code> whether <code>F</code> and <code>J</code> are inplace functions (Experimental). In this case, the functions <code>F</code> and <code>J</code> must have the following definitions <code>(o, x) -&gt;  F(o, x)</code> and <code>(o, x, dx) -&gt; J(o, x, dx)</code>.</li><li><code>ongpu::Bool</code> whether the computation takes place on the gpu (Experimental)</li></ul><p>You can then call <code>pb(orbitguess)</code> to compute the functional on a <code>orbitguess</code>. Note that <code>orbitguess</code> must be of size M * N + 1 where N is the number of unknowns in the state space and <code>orbitguess[M*N+1]</code> is an estimate of the period of the limit cycle.</p><p>The scheme is as follows, one look for <code>T = x[end]</code> and</p><p><span>$\left(x_{i} - x_{i-1}\right) - \frac{h}{2} \left(F(x_{i}) + F(x_{i-1})\right) = 0,\ i=1,\cdots,m-1$</span></p><p>with <code>u_{0} = u_{m-1}</code> and the periodicity condition <code>u_{m} - u_{1} = 0</code> and</p><p>where <code>h = T/M</code>. Finally, the phase of the periodic orbit is constrained by using a section</p><p><span>$\langle x[1] - x_\pi, \phi\rangle=0.$</span></p><p>A functional, hereby called <code>G</code>, encodes this problem. The following methods are available</p><ul><li><code>pb(orbitguess)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, du)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code></li><li><code>pb(Val(:JacFullSparse), orbitguess)</code> return the sparse matrix of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code> without the constraints. It is called <code>A_γ</code> in the docs.</li><li><code>pb(Val(:JacCyclicSparse), orbitguess)</code> return the sparse cyclic matrix Jc (see the docs) of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code></li><li><code>pb(Val(:BlockDiagSparse), orbitguess)</code> return the diagonal of the sparse matrix of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code>. This allows to design Jacobi preconditioner. Use <code>blockdiag</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">GPU call</header><div class="admonition-body"><p>For these methods to work on the GPU, for example with <code>CuArrays</code> in mode <code>allowscalar(false)</code>, we face the issue that the function <code>extractPeriodFDTrap</code> won&#39;t be well defined because it is a scalar operation. One may have to redefine it like <code>extractPeriodFDTrap(x::CuArray) = x[end:end]</code> or something else. Also, note that you must pass the option <code>ongpu = true</code> for the functional to be evaluated efficiently on the gpu.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.Flow" href="#PseudoArcLengthContinuation.Flow"><code>PseudoArcLengthContinuation.Flow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">fl = Flow(F, flow, dflow)</code></pre><p>This composite type encapsulates:</p><ul><li>the vector field <code>x -&gt; F(x)</code> associated to a Cauchy problem,</li><li>the flow (or semigroup) associated to the Cauchy problem <code>(x, t) -&gt; flow(x, t)</code>. Only the last time point must be returned.</li><li>the flow (or semigroup) associated to the Cauchy problem <code>(x, t) -&gt; flow(x, t)</code>. The whole solution on the time interval (0,t) must be returned. This is not strictly necessary to provide this.</li><li>the differential <code>dflow</code> of the flow w.r.t. <code>x</code>, <code>(x, dx, t) -&gt; dflow(x, dx, t)</code>. One important thing is that we require <code>dflow(x, dx, t)</code> to return 2 vectors: the first is <code>flow(x, t)</code> and the second is the value of the derivative of the flow as the second vector.</li></ul><p>There are some simple constructors for which you only have to pass a <code>prob::ODEProblem</code> from <code>DifferentialEquations.jl</code> and an ODE time stepper like <code>Tsit5()</code>. Hence, you can do for example</p><pre><code class="language-none">fl = Flow(F, prob, Tsit5(); kwargs...)</code></pre><p>If your vector field depends on parameters <code>p</code>, you can define a <code>Flow</code> using</p><pre><code class="language-none">fl = Flow(F, p, prob, Tsit5(); kwargs...)</code></pre><p>Finally, you can pass two <code>ODEProblem</code> where the second one is used to compute the variational equation:</p><pre><code class="language-none">fl = Flow(F, p, prob1::ODEProblem, alg1, prob2::ODEProblem, alg2; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/periodicorbit/Shooting.jl#L55-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.ShootingProblem" href="#PseudoArcLengthContinuation.ShootingProblem"><code>PseudoArcLengthContinuation.ShootingProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">pb = ShootingProblem(flow::Flow, ds, section)</code></pre><p>This composite type implements the Standard Simple / Multiple Standard Shooting  method to locate periodic orbits. The arguments are as follows</p><ul><li><code>flow::Flow</code>: implements the flow of the Cauchy problem though the structure <code>Flow</code>.</li><li><code>ds</code>: vector of time differences for each shooting. Its length is written <code>M</code>. If <code>M==1</code>, then the simple shooting is implemented and the multiple one otherwise.</li><li><code>section</code>: implements a phase condition. The evaluation <code>section(x)</code> must return a scalar number where <code>x</code> is a guess for the periodic orbit. Note that the period <code>T</code> of the guess <code>x</code> is always included either as the last component of <code>T = x[end]</code> or as <code>T = x.p</code>. The type of <code>x</code> depends on what is passed to the newton solver.</li></ul><p>You can then call <code>pb(orbitguess)</code> to apply the functional to a guess. Note that <code>orbitguess</code> must be of size M * N + 1 where N is the number of unknowns of the state space and <code>orbitguess[M * N + 1]</code> is an estimate of the period <code>T</code> of the limit cycle. This form of guess is convenient for the use of the linear solvers in <code>IterativeSolvers.jl</code> (for example) which accepts only <code>AbstractVector</code>s. Another accepted guess is of the form <code>BorderedArray(guess, T)</code> where <code>guess[i]</code> is the state of the orbit at the <code>i</code>th time slice. This last form allows for non-vector state space which can be convenient for 2d problems for example.</p><p>A functional, hereby called <code>G</code>, encodes the shooting problem. For example, the following methods are available:</p><ul><li><code>pb(orbitguess)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, du)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code></li></ul><p><strong>Simplified constructors</strong></p><ul><li>A simpler way to build a functional is to use</li></ul><pre><code class="language-none">pb = ShootingProblem(F, p, prob::ODEProblem, alg, M::Int, section; kwargs...)</code></pre><p>or</p><pre><code class="language-none">pb = ShootingProblem(F, p, prob::ODEProblem, alg, ds, section; kwargs...)</code></pre><p>where <code>F</code> is the vector field, <code>p</code> is a parameter (to be passed to the vector field and the flow), <code>prob</code> is an <code>ODEProblem</code> which is used to create a flow using the ODE solver <code>alg</code> (for example <code>Tsit5()</code>). Finally, the arguments <code>kwargs</code> are passed to the ODE solver defining the flow. Look at <code>DifferentialEquations.jl</code> for more information. Note that, in this case, the derivative of the flow is computed internally using Finite Differences.</p><ul><li>The other way is an elaboration of the previous one</li></ul><pre><code class="language-none">pb = ShootingProblem(F, p, prob1::ODEProblem, alg1, prob2::ODEProblem, alg2, M::Int, section; kwargs...)</code></pre><p>or</p><pre><code class="language-none">pb = ShootingProblem(F, p, prob1::ODEProblem, alg1, prob2::ODEProblem, alg2, ds, section; kwargs...)</code></pre><p>where we supply now two <code>ODEProblem</code>. The first one <code>prob1</code>, is used to define the flow associated to <code>F</code> while the second one is a problem associated to the derivative of the flow. Hence, <code>prob2</code> should implement the following vector field <span>$\tilde F(x,\phi) = (F(x),dF(x)\cdot\phi)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.PoincareShootingProblem" href="#PseudoArcLengthContinuation.PoincareShootingProblem"><code>PseudoArcLengthContinuation.PoincareShootingProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>pb = PoincareShootingProblem(flow::Flow, M, section)</p><p>This composite type implements	 the Poincaré Shooting method to locate periodic orbits, basically using Poincaré return maps. The arguments are as follows</p><ul><li><code>flow::Flow</code>: implements the flow of the Cauchy problem though the structure <code>Flow</code>.</li><li><code>M</code>: the number of return maps. If <code>M==1</code>, then the simple shooting is implemented and the multiple one otherwise.</li><li><code>section</code>: implements a Poincaré section condition. The evaluation <code>section(x)</code> must return a scalar number where <code>x</code> is a guess for the periodic orbit when <code>M=1</code>. Otherwise, one must implement a function <code>section(out, x)</code> which populates <code>out</code> with the <code>M</code> hyperplanes.</li></ul><p><strong>Simplified constructors</strong></p><p>A simpler way is to create a functional is <code>pb = PoincareShootingProblem(F, p, prob::ODEProblem, alg, section; kwargs...)</code> for simple shooting or <code>pb = PoincareShootingProblem(F, p, prob::ODEProblem, alg, M::Int, section; kwargs...)</code> for multiple shooting . Here <code>F</code> is the vector field, <code>p</code> is a parameter (to be passed to the vector and the flow), <code>prob</code> is an <code>ODEProblem</code> which is used to create a flow using the ODE solver <code>alg</code> (for example <code>Tsit5()</code>). Finally, the arguments <code>kwargs</code> are passed to the ODE solver defining the flow. Look at <code>DifferentialEquations.jl</code> for more information.</p><p>Another convenient call is <code>pb = PoincareShootingProblem(F, p, prob::ODEProblem, alg, normals::AbstractVector, centers::AbstractVector; δ = 1e-8, kwargs...)</code> where <code>normals</code> (resp. <code>centers</code>) is a list of normals (resp. centers) which define a list of hyperplanes <span>$\Sigma_i$</span>. These hyperplanes are used to define partial Poincaré return maps. δ is a numerical value used for the Matrix-Free Jacobian by finite differences. If set to 0, analytical jacobian is used. See docs for more information.</p><p><strong>Computing the functionals</strong></p><p>You can then call <code>pb(orbitguess)</code> to apply the functional to a guess. Note that <code>orbitguess</code> must be of size M * N where N is the number of unknowns in the state space and <code>M</code> is the number of Poincaré maps. Another accepted <code>guess</code> is such that <code>guess[i]</code> is the state of the orbit on the <code>i</code>th section. This last form allows for non-vector state space which can be convenient for 2d problems for example.</p><p>A functional, hereby called <code>G</code> encodes this shooting problem. For example, the following methods are available:</p><ul><li><code>pb(orbitguess)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, du)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code></li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can use the function <code>getPeriod(pb::PoincareShootingProblem, sol)</code> to get the period of the solution <code>sol</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.FloquetQaDTrap" href="#PseudoArcLengthContinuation.FloquetQaDTrap"><code>PseudoArcLengthContinuation.FloquetQaDTrap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">floquet = FloquetQaDTrap(eigsolver::AbstractEigenSolver)</code></pre><p>This composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems based on Finite Differences (Trapeze method), also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations. The arguments are as follows:</p><ul><li><code>eigsolver::AbstractEigenSolver</code> solver used to compute the eigenvalues.</li></ul><p>If <code>eigsolver == DefaultEig()</code>, then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.</p><div class="admonition is-danger"><header class="admonition-header">Floquet multipliers computation</header><div class="admonition-body"><p>The computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver <code>eigsolver</code> needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option <code>which = :LM</code> of <code>eigsolver</code>. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/periodicorbit/FloquetQaD.jl#L18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.FloquetQaDShooting" href="#PseudoArcLengthContinuation.FloquetQaDShooting"><code>PseudoArcLengthContinuation.FloquetQaDShooting</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">floquet = FloquetQaDShooting(eigsolver::AbstractEigenSolver)</code></pre><p>This composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems based on the Shooting method, also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations. The arguments are as follows:</p><ul><li><code>eigsolver::AbstractEigenSolver</code> solver used to compute the eigenvalues.</li></ul><p>If <code>eigsolver == DefaultEig()</code>, then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.</p><div class="admonition is-danger"><header class="admonition-header">Floquet multipliers computation</header><div class="admonition-body"><p>The computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver <code>eigsolver</code> needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option <code>which = :LM</code> of <code>eigsolver</code>. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/periodicorbit/FloquetQaD.jl#L116-L126">source</a></section></article><h2 id="Newton-1"><a class="docs-heading-anchor" href="#Newton-1">Newton</a><a class="docs-heading-anchor-permalink" href="#Newton-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.newton" href="#PseudoArcLengthContinuation.newton"><code>PseudoArcLengthContinuation.newton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">	newton(F, J, x0, options::NewtonPar; normN = norm, callback = (x, f, J, res, iteration, optionsN; kwargs...) -&gt; true, kwargs...)</code></pre><p>This is the Newton Solver for <code>F(x) = 0</code> with Jacobian <code>J</code> and initial guess <code>x0</code>. The function <code>normN</code> allows to specify a norm for the convergence criteria. It is important to set the linear solver <code>options.linsolver</code> properly depending on your problem. This linear solver is used to solve <span>$J(x)u = -F(x)$</span> in the Newton step. You can for example use <code>linsolver = Default()</code> which is the operator backslash: it works well for Sparse / Dense matrices. See <a href="../linearsolver/#Linear-solvers-1">Linear solvers</a> for more informations.</p><p><strong>Arguments:</strong></p><ul><li><code>x -&gt; F(x)</code> functional whose zeros are looked for. In particular, it is not <strong>inplace</strong>,</li><li><code>dF(x) = x -&gt; J(x)</code> compute the jacobian of <code>F</code> at <code>x</code>. It is then passed to <code>options.linsolver</code>. The Jacobian <code>J(x)</code> can be a matrix or an out-of-place function.</li><li><code>x0</code> initial guess</li><li><code>options</code> variable holding the internal parameters used by the <code>newton</code> method</li><li><code>callback</code> function passed by the user which is called at the end of each iteration. Can be used to update a preconditionner for example. The <code>optionsN</code> will be <code>options</code> passed in order to change the linear / eigen solvers</li><li><code>kwargs</code> arguments passed to the callback. Useful when <code>newton</code> is called from <code>continuation</code></li></ul><p>Simplified calls are provided, for example when <code>J</code> is not passed. It is then computed with finite differences.</p><p><strong>Output:</strong></p><ul><li>solution:</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/Newton.jl#L33-L53">source</a></section><section><div><pre><code class="language-julia">function newton(Fhandle, Jhandle, x0::vectype, options:: NewtonPar{T}, defOp::DeflationOperator{T, Tf, vectype}; kwargs...) where {T, Tf, vectype}</code></pre><p>This is the deflated version of the Newton Solver for <code>F(x) = 0</code> with Jacobian <code>J</code>. It penalises the roots saved in <code>defOp.roots</code>. The other arguments are as for <code>newton</code>. See <a href="#PseudoArcLengthContinuation.DeflationOperator"><code>DeflationOperator</code></a> for more informations.</p><p>Simplified calls are provided, for example when <code>J</code> is not passed. It then computed with finite differences.</p><p><strong>Output:</strong></p><ul><li>solution:</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/DeflationOperator.jl#L114-L126">source</a></section><section><div><pre><code class="language-julia">newton(prob::T, orbitguess, options::NewtonPar; kwargs...) where {T &lt;: AbstractShootingProblem}</code></pre><p>This is the Newton Solver for computing a periodic orbit using Shooting method.</p><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/periodicorbit/Shooting.jl#L590-L600">source</a></section><section><div><pre><code class="language-none">newton(prob::T, orbitguess, options::NewtonPar, defOp::DeflationOperator; kwargs...) where {T &lt;: AbstractShootingProblem}</code></pre><p>This is the deflated Newton Solver for computing a periodic orbit using Shooting method.</p><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/periodicorbit/Shooting.jl#L608-L618">source</a></section><section><div><pre><code class="language-julia">newton(prob::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, linearPO = :BorderedLU; kwargs...)</code></pre><p>This is the Newton Solver for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.</p><p><strong>Arguments:</strong></p><ul><li><code>prob</code> a problem of type <code>PeriodicOrbitTrapProblem</code> encoding the functional G</li><li><code>orbitguess</code> a guess for the periodic orbit where <code>orbitguess[end]</code> is an estimate of the period of the orbit. It should be a vector of size <code>N * M + 1</code> where <code>M</code> is the number of time slices, <code>N</code> is the dimension of the phase space. This must be compatible with the numbers <code>N,M</code> in <code>prob</code>.</li><li><code>options</code> same as for the regular <code>newton</code> method</li><li><code>linearPO = :BorderedLU</code>. Specify the choice of the linear algorithm, which must belong to <code>[:FullLU, :BorderedLU, :FullMatrixFree, :BorderedMatrixFree]</code>. This is used to select a way of inverting the jacobian <code>dG</code> of the functional G. For <code>:FullLU</code>, we use the default linear solver on a sparse matrix representation of <code>dG</code>. For <code>:BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use LU decomposition to invert <code>dG</code> using a bordered linear solver. This is the default algorithm. For <code>:FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects the convergence properties of GMRES. Finally, for <code>:BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li></ul><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/periodicorbit/PeriodicOrbitFD.jl#L544-L560">source</a></section><section><div><pre><code class="language-julia">newton(probPO::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, defOp::DeflationOperator{T, Tf, vectype}, linearPO = :BorderedLU; kwargs...) where {T, Tf, vectype}</code></pre><p>This function is similar to <code>newton(probPO, orbitguess, options, linearPO; kwargs...)</code> except that it uses deflation in order to find periodic orbits different from the one in <code>defOp</code>. For example, it can be used in the vicinity of a Hopf bifurcation to prevent the Newton algorithm from converging to the equilibrium point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/periodicorbit/PeriodicOrbitFD.jl#L608-L612">source</a></section></article><h2 id="Newton-with-deflation-1"><a class="docs-heading-anchor" href="#Newton-with-deflation-1">Newton with deflation</a><a class="docs-heading-anchor-permalink" href="#Newton-with-deflation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.newton-Union{Tuple{vectype}, Tuple{Tf}, Tuple{T}, Tuple{Any,Any,vectype,NewtonPar{T,L,E} where E&lt;:AbstractEigenSolver where L&lt;:PseudoArcLengthContinuation.AbstractLinearSolver,DeflationOperator{T,Tf,vectype}}} where vectype where Tf where T" href="#PseudoArcLengthContinuation.newton-Union{Tuple{vectype}, Tuple{Tf}, Tuple{T}, Tuple{Any,Any,vectype,NewtonPar{T,L,E} where E&lt;:AbstractEigenSolver where L&lt;:PseudoArcLengthContinuation.AbstractLinearSolver,DeflationOperator{T,Tf,vectype}}} where vectype where Tf where T"><code>PseudoArcLengthContinuation.newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function newton(Fhandle, Jhandle, x0::vectype, options:: NewtonPar{T}, defOp::DeflationOperator{T, Tf, vectype}; kwargs...) where {T, Tf, vectype}</code></pre><p>This is the deflated version of the Newton Solver for <code>F(x) = 0</code> with Jacobian <code>J</code>. It penalises the roots saved in <code>defOp.roots</code>. The other arguments are as for <code>newton</code>. See <a href="#PseudoArcLengthContinuation.DeflationOperator"><code>DeflationOperator</code></a> for more informations.</p><p>Simplified calls are provided, for example when <code>J</code> is not passed. It then computed with finite differences.</p><p><strong>Output:</strong></p><ul><li>solution:</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/DeflationOperator.jl#L114-L126">source</a></section></article><h2 id="Newton-for-Fold-/-Hopf-1"><a class="docs-heading-anchor" href="#Newton-for-Fold-/-Hopf-1">Newton for Fold / Hopf</a><a class="docs-heading-anchor-permalink" href="#Newton-for-Fold-/-Hopf-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,BorderedArray{vectype,T},Any,NewtonPar}} where vectype where T" href="#PseudoArcLengthContinuation.newtonFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,BorderedArray{vectype,T},Any,NewtonPar}} where vectype where T"><code>PseudoArcLengthContinuation.newtonFold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`newtonFold(F, J, foldpointguess::BorderedArray{vectype, T}, eigenvec, options::NewtonPar; Jt = nothing, d2F = nothing, normN = norm)`</code></pre><p>This function turns an initial guess for a Fold point into a solution to the Fold problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F   = (x, p) -&gt; F(x, p)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>dF  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>foldpointguess</code> initial guess (x<em>0, p</em>0) for the Fold point. It should be a <code>BorderedArray</code> as given by the function FoldPoint</li><li><code>eigenvec</code> guess for the 0 eigenvector</li><li><code>options::NewtonPar</code></li></ul><p>Optional arguments:</p><ul><li><code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian transpose, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method.</li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x,p)[v1,v2]</code>.</li><li><code>normN = norm</code></li></ul><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/FoldCont.jl#L167-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonFold-Tuple{Any,Any,ContResult,Int64,NewtonPar}" href="#PseudoArcLengthContinuation.newtonFold-Tuple{Any,Any,ContResult,Int64,NewtonPar}"><code>PseudoArcLengthContinuation.newtonFold</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simplified call to refine an initial guess for a Fold point. More precisely, the call is as follows</p><pre><code class="language-none">`newtonFold(F, J, br::ContResult, index::Int64, options::NewtonPar; Jt = nothing, d2F = nothing)`</code></pre><p>where the optional argument <code>Jt</code> is the jacobian transpose and the Hessian is <code>d2F</code>. The parameters / options are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/FoldCont.jl#L212-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonHopf-Union{Tuple{T}, Tuple{vectypeR}, Tuple{Any,Any,BorderedArray{vectypeR,T},Any,Any,NewtonPar}} where T where vectypeR" href="#PseudoArcLengthContinuation.newtonHopf-Union{Tuple{T}, Tuple{vectypeR}, Tuple{Any,Any,BorderedArray{vectypeR,T},Any,Any,NewtonPar}} where T where vectypeR"><code>PseudoArcLengthContinuation.newtonHopf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`newtonHopf(F, J, hopfpointguess::BorderedArray{vectypeR, T}, eigenvec, eigenvec_ad, options::NewtonPar; Jt = nothing, d2F = nothing, normN = norm)`</code></pre><p>This function turns an initial guess for a Hopf point into a solution to the Hopf problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F  = (x, p) -&gt; F(x, p)</code> where <code>p</code> is the parameter associated to the Hopf point</li><li><code>J  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>hopfpointguess</code> initial guess (x<em>0, p</em>0) for the Hopf point. It should a <code>BorderedArray</code> as given by the function HopfPoint.</li><li><code>eigenvec</code> guess for the  iω eigenvector</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector</li><li><code>options::NewtonPar</code></li></ul><p>Optional arguments:</p><ul><li><code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian transpose</li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x,p)[v1, v2]</code>.</li><li><code>normN = norm</code></li></ul><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/HopfCont.jl#L172-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.newtonHopf-Tuple{Any,Any,ContResult,Int64,NewtonPar}" href="#PseudoArcLengthContinuation.newtonHopf-Tuple{Any,Any,ContResult,Int64,NewtonPar}"><code>PseudoArcLengthContinuation.newtonHopf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simplified call to refine an initial guess for a Hopf point. More precisely, the call is as follows</p><pre><code class="language-none">`newtonHopf(F, J, br::ContResult, index::Int64, options; Jt = nothing, d2F = nothing, normN = norm)`</code></pre><p>where the optional argument <code>Jt</code> is the jacobian transpose and the Hessian is <code>d2F</code>. The parameters are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><div class="admonition is-warning"><header class="admonition-header">Eigenvectors</header><div class="admonition-body"><p>This simplified call has been written when the eigenvectors are organised in a 2d Array <code>evec</code> where <code>evec[:,2]</code> is the second eigenvector in the list.</p></div></div><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/HopfCont.jl#L218-L233">source</a></section></article><h2 id="Newton-for-Periodic-Orbits-1"><a class="docs-heading-anchor" href="#Newton-for-Periodic-Orbits-1">Newton for Periodic Orbits</a><a class="docs-heading-anchor-permalink" href="#Newton-for-Periodic-Orbits-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.newton" href="#PseudoArcLengthContinuation.newton"><code>PseudoArcLengthContinuation.newton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">newton(prob::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, linearPO = :BorderedLU; kwargs...)</code></pre><p>This is the Newton Solver for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.</p><p><strong>Arguments:</strong></p><ul><li><code>prob</code> a problem of type <code>PeriodicOrbitTrapProblem</code> encoding the functional G</li><li><code>orbitguess</code> a guess for the periodic orbit where <code>orbitguess[end]</code> is an estimate of the period of the orbit. It should be a vector of size <code>N * M + 1</code> where <code>M</code> is the number of time slices, <code>N</code> is the dimension of the phase space. This must be compatible with the numbers <code>N,M</code> in <code>prob</code>.</li><li><code>options</code> same as for the regular <code>newton</code> method</li><li><code>linearPO = :BorderedLU</code>. Specify the choice of the linear algorithm, which must belong to <code>[:FullLU, :BorderedLU, :FullMatrixFree, :BorderedMatrixFree]</code>. This is used to select a way of inverting the jacobian <code>dG</code> of the functional G. For <code>:FullLU</code>, we use the default linear solver on a sparse matrix representation of <code>dG</code>. For <code>:BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use LU decomposition to invert <code>dG</code> using a bordered linear solver. This is the default algorithm. For <code>:FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects the convergence properties of GMRES. Finally, for <code>:BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li></ul><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/periodicorbit/PeriodicOrbitFD.jl#L544-L560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.newton-Union{Tuple{T}, Tuple{T,Any,NewtonPar}} where T&lt;:AbstractShootingProblem" href="#PseudoArcLengthContinuation.newton-Union{Tuple{T}, Tuple{T,Any,NewtonPar}} where T&lt;:AbstractShootingProblem"><code>PseudoArcLengthContinuation.newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newton(prob::T, orbitguess, options::NewtonPar; kwargs...) where {T &lt;: AbstractShootingProblem}</code></pre><p>This is the Newton Solver for computing a periodic orbit using Shooting method.</p><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/periodicorbit/Shooting.jl#L590-L600">source</a></section></article><h2 id="Continuation-1"><a class="docs-heading-anchor" href="#Continuation-1">Continuation</a><a class="docs-heading-anchor-permalink" href="#Continuation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.continuation" href="#PseudoArcLengthContinuation.continuation"><code>PseudoArcLengthContinuation.continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">continuation(F, J, x0, p0::Real, contParams::ContinuationPar; plot = false, normC = norm, dotPALC = (x,y) -&gt; dot(x,y) / length(x), printSolution = norm, plotSolution = (x; kwargs...)-&gt;nothing, finaliseSolution = (z, tau, step, contResult) -&gt; true, callbackN = (x, f, J, res, iteration, options; kwargs...) -&gt; true, linearAlgo = BorderingBLS(), tangentAlgo = SecantPred(), verbosity = 0)</code></pre><p>Compute the continuation curve associated to the functional <code>F</code> and its jacobian <code>J</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>F = (x, p) -&gt; F(x, p)</code> where <code>p</code> is the parameter for the continuation</li><li><code>J = (x, p) -&gt; d_xF(x, p)</code> its associated jacobian. It can be a matrix, a function or a callable struct.</li><li><code>u0</code> initial guess</li><li><code>p0</code> initial parameter, must be a real number</li><li><code>contParams</code> parameters for continuatio. See <a href="#PseudoArcLengthContinuation.ContinuationPar"><code>ContinuationPar</code></a> for more information about the options</li><li><code>plot = false</code> whether to plot the solution while computing</li><li><code>printSolution = (x, p) -&gt; norm(x)</code> function used to plot in the continuation curve. It is also used in the way results are saved. It could be <code>norm</code> or <code>x -&gt; x[1]</code>. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...).</li><li><code>plotSolution = (x; kwargs...) -&gt; nothing</code> function implementing the plot of the solution.</li><li><code>finaliseSolution = (z, tau, step, contResult) -&gt; true</code> Function called at the end of each continuation step. Can be used to alter the continuation procedure (stop it by returning false), saving personal data, plotting... The notations are <span>$z=(x,p)$</span>, <code>tau</code> is the tangent at <code>z</code> (see below), <code>step</code> is the index of the current continuation step and <code>ContResult</code> is the current branch. Note that you can have a better control over the continuation procedure by using an iterator, see <a href="../iterator/#Iterator-Interface-1">Iterator Interface</a>.</li><li><code>callbackN</code> callback for newton iterations. see docs for <code>newton</code>. Can be used to change preconditioners</li><li><code>tangentAlgo = SecantPred()</code> controls the algorithm use to predict the tangent along the curve of solutions or the corrector. Can be <code>NaturalPred</code>, <code>SecantPred</code> or <code>BorderedPred</code>.</li><li><code>linearAlgo = BorderingBLS()</code>. Must belong to <code>[MatrixBLS(), BorderingBLS(), MatrixFreeBLS()]</code>. Used to control the way the extended linear system associated to the continuation problem is solved.</li><li><code>verbosity ∈ {0,1,2,3}</code> controls the amount of information printed during the continuation process.</li><li><code>normC = norm</code> norm used in the different Newton solves</li><li><code>dotPALC = (x,y) -&gt; dot(x,y) / length(x)</code>, dot product used in the definition of the dot product (norm) <span>$\|(u, p)\|^2_\theta$</span> in the constraint <span>$N(x,p)$</span> (see below). This option can be used to remove the factor <code>1/length(x)</code> for example in problems where the dimension of the state space changes (mesh adaptation, ...)</li><li><code>filename</code> name of a file to save the computed branch during continuation. The identifier .jld2 will be appended to this filename</li></ul><p><strong>Outputs:</strong></p><ul><li><code>contres::ContResult</code> composite type which contains the computed branch. See <a href="#PseudoArcLengthContinuation.ContResult"><code>ContResult</code></a> for more information.</li><li><code>u::BorderedArray</code> the last solution computed on the branch</li></ul><div class="admonition is-success"><header class="admonition-header">Controlling the parameter `linearAlgo`</header><div class="admonition-body"><p>In this simplified interface to <code>continuation</code>, the argument <code>linearAlgo</code> is internally overwritten to provide a valid argument to the algorithm. If you do not want this to happen, call directly <code>continuation(F, J, x0, p0, contParams, linearAlgo; kwrags...)</code>.</p></div></div><p><strong>Method</strong></p><p><strong>Bordered system of equations</strong></p><p>The pseudo-arclength continuation method solves the equation <span>$F(x, p) = 0$</span> (of dimension N) together with the pseudo-arclength constraint <span>$N(x, p) = \frac{\theta}{length(x)} \langle x - x_0, \tau_0\rangle + (1 - \theta)\cdot(p - p_0)\cdot dp_0 - ds = 0$</span>. In practice, the curve <span>$\gamma$</span> is parametrised by <span>$s$</span> so that <span>$\gamma(s) = (x(s), p(s))$</span> is a curve of solutions to <span>$F(x, p)$</span>. This formulation allows to pass turning points (where the implicit theorem fails). In the previous formula, <span>$(x_0, p_0)$</span> is a solution for a given <span>$s_0$</span>, <span>$(\tau_0, dp_0)$</span> is the tangent to the curve at <span>$s_0$</span>. Hence, to compute the curve of solutions, we need solve an equation of dimension N+1 which is called a Bordered system.</p><div class="admonition is-warning"><header class="admonition-header">Parameter `theta`</header><div class="admonition-body"><p>The parameter <code>theta</code> in the struct <code>ContinuationPar</code>is very important. It should be tuned for the continuation to work properly especially in the case of large problems where the <span>$\langle x - x_0, \tau_0\rangle$</span> component in the constraint might be favoured too much.</p></div></div><p>The parameter ds is adjusted internally depending on the number of Newton iterations and other factors. See the function <code>stepSizeControl</code> for more information. An important parameter to adjust the magnitude of this adaptation is the parameter <code>a</code> in the struct <code>ContinuationPar</code>.</p><p><strong>Algorithm</strong></p><p>The algorithm works as follows:</p><ol><li>Start from a known solution <span>$(x_0, p_0,\tau_0 ,dp_0)$</span></li><li><strong>Predictor</strong> set <span>$(x_1, p_1) = (x_0, p_0) + ds\cdot (\tau_0, dp_0)$</span></li><li><strong>Corrector</strong> solve <span>$F(x, p)=0,\ N(x, p)=0$</span> with a (Bordered) Newton Solver with guess <span>$(x_1, p_1)$</span>.<ul><li>if Newton in 3. did not converge, put ds/2 ⟶ ds and go to 1.</li></ul></li><li><strong>New tangent</strong> Compute <span>$(\tau_1, dp_1)$</span>, set <span>$(x_0, p_0, \tau_0, dp_0) = (x_1, p_1, \tau_1, dp_1)$</span> and return to step 2</li></ol><p><strong>Natural continuation</strong></p><p>We speak of <em>natural</em> continuation when we do not consider the constraint <span>$N(x, p)=0$</span>. Knowing <span>$(x_0, p_0)$</span>, we use <span>$x_0$</span> as a guess for solving <span>$F(x, p_1)=0$</span> with <span>$p_1$</span> close to <span>$p_0$</span>. Again, this fails at Turning points but it can be faster to compute than the constrained case. This is set by the option <code>tangentAlgo = NaturalPred()</code> in <code>continuation</code>.</p><p><strong>Tangent computation (step 4)</strong></p><p>There are various ways to compute <span>$(\tau_1, p_1)$</span>. The first one is called secant and is parametrised by the option <code>tangentAlgo = SecantPred()</code>. It is computed by <span>$(\tau_1, p_1) = (z_1, p_1) - (z_0, p_0)$</span> and normalised by the norm <span>$\|(u, p)\|^2_\theta = \frac{\theta}{length(u)} \langle u,u\rangle + (1 - \theta)\cdot p^2$</span>. Another method is to compute <span>$(\tau_1, p_1)$</span> by solving solving the bordered linear system <span>$\begin{bmatrix} F_x &amp; F_p	; \ \frac{\theta}{length(x)}\tau_0 &amp; (1-\theta)p_0\end{bmatrix}\begin{bmatrix}\tau_1 ;  p_1\end{bmatrix} =\begin{bmatrix}0 ; 1\end{bmatrix}$</span> ; it is set by the option <code>tangentAlgo = BorderedPred()</code>.</p><p><strong>Bordered linear solver</strong></p><p>When solving the Bordered system <span>$F(x, p) = 0,\ N(x, p)=0$</span>, one faces the issue of solving the Bordered linear system <span>$\begin{bmatrix} J &amp; a	; b^T &amp; c\end{bmatrix}\begin{bmatrix}X ;  y\end{bmatrix} =\begin{bmatrix}R ; n\end{bmatrix}$</span>. This can be solved in many ways via bordering (which requires two Jacobian inverses), by forming the bordered matrix (which works well for sparse matrices) or by using a full Matrix Free formulation. The choice of method is set by the argument <code>linearAlgo</code>. Have a look at the struct <code>linearBorderedSolver</code> for more information.</p><p><strong>Linear Algebra</strong></p><p>Let us discuss here more about the norm and dot product. First, the option <code>normC</code> gives a norm that is used to evaluate the residual in the following way: <span>$max(normC(F(x,p)), \|N(x,p)\|)&lt;tol$</span>. It is thus used as a stopping criterion for a Newton algorithm. The dot product (resp. norm) used in <span>$N$</span> and in the (iterative) linear solvers is <code>LinearAlgebra.dot</code> (resp. <code>LinearAlgebra.norm</code>). It can be changed by importing these functions and redefining it. Not that by default, the <span>$L^2$</span> norm is used. These details are important because of the constraint <span>$N$</span> which incorporates the factor <code>length</code>. For some custom composite type implementing a Vector space, the dot product could already incorporates the <code>length</code> factor in which case you should either redefine the dot product or change <span>$\theta$</span>.</p><p><strong>Step size control</strong></p><p>As explained above, each time the corrector phased failed, the step size <span>$ds$</span> is halved. This has the disavantage of having lost Newton iterations (which costs time) and impose small steps (which can be slow as well). To prevent this, the step size is controlled internally with the idea of having a constant number of Newton iterations per point. This is in part controlled by the aggressiveness factor <code>a</code> in <code>ContinuationPar</code>. Further tuning is performed by using <code>doArcLengthScaling=true</code> in <code>ContinuationPar</code>. This adjusts internally <span>$\theta$</span> so that the relative contributions of <span>$x$</span> and <span>$p$</span> are balanced in the constraint <span>$N$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/Continuation.jl#L619-L687">source</a></section></article><h2 id="Continuation-for-Fold-/-Hopf-1"><a class="docs-heading-anchor" href="#Continuation-for-Fold-/-Hopf-1">Continuation for Fold / Hopf</a><a class="docs-heading-anchor-permalink" href="#Continuation-for-Fold-/-Hopf-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,BorderedArray{vectype,T},T,Any,ContinuationPar}} where vectype where T" href="#PseudoArcLengthContinuation.continuationFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,BorderedArray{vectype,T},T,Any,ContinuationPar}} where vectype where T"><code>PseudoArcLengthContinuation.continuationFold</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p1, p2) -&gt;	F(x, p1, p2)</code> where <code>p</code> is the parameter associated to the Fold point</li><li><code>J = (x, p1, p2) -&gt; d_xF(x, p1, p2)</code> associated jacobian</li><li><code>foldpointguess</code> initial guess (x<em>0, p1</em>0) for the Fold point. It should be a <code>BorderedArray</code> as given by the function FoldPoint</li><li><code>p2</code> parameter p2 for which <code>foldpointguess</code> is a good guess</li><li><code>eigenvec</code> guess for the 0 eigenvector at p1_0</li><li><code>options::NewtonPar</code></li></ul><p>Optional arguments:</p><ul><li><code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> associated jacobian transpose</li><li><code>d2F = p2 -&gt; ((x, p1, v1, v2) -&gt; d2F(x, p1, p2, v1, v2))</code> this is the hessian of <code>F</code> computed at <code>(x, p1, p2)</code> and evaluated at <code>(v1, v2)</code>.</li></ul><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/FoldCont.jl#L235-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationFold-Tuple{Any,Any,ContResult,Int64,Real,ContinuationPar}" href="#PseudoArcLengthContinuation.continuationFold-Tuple{Any,Any,ContResult,Int64,Real,ContinuationPar}"><code>PseudoArcLengthContinuation.continuationFold</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simplified call for continuation of Fold point. More precisely, the call is as follows <code>continuationFold(F, J, br::ContResult, index::Int64, options; Jt = nothing, d2F = p2 -&gt; nothing)</code> where the parameters are as for <code>continuationFold</code> except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/FoldCont.jl#L297-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationHopf-Tuple{Any,Any,ContResult,Int64,Real,ContinuationPar}" href="#PseudoArcLengthContinuation.continuationHopf-Tuple{Any,Any,ContResult,Int64,Real,ContinuationPar}"><code>PseudoArcLengthContinuation.continuationHopf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simplified call for continuation of Hopf point. More precisely, the call is as follows <code>continuationHopf(F, J, br::ContResult, index::Int64, options; Jt = nothing, d2F = p2 -&gt; nothing)</code> where the parameters are as for <code>continuationHopf</code> except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine.</p><p>Simplified calls are also provided but at the cost of using finite differences.</p><div class="admonition is-warning"><header class="admonition-header">Eigenvectors</header><div class="admonition-body"><p>This simplified call has been written when the eigenvectors are organised in a 2d Array <code>evec</code> where <code>evec[:,2]</code> is the second eigenvector in the list.</p></div></div><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/HopfCont.jl#L314-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationHopf-Union{Tuple{vectype}, Tuple{Tb}, Tuple{T}, Tuple{Any,Any,BorderedArray{vectype,Tb},T,Any,Any,ContinuationPar}} where vectype where Tb where T" href="#PseudoArcLengthContinuation.continuationHopf-Union{Tuple{vectype}, Tuple{Tb}, Tuple{T}, Tuple{Any,Any,BorderedArray{vectype,Tb},T,Any,Any,ContinuationPar}} where vectype where Tb where T"><code>PseudoArcLengthContinuation.continuationHopf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>codim 2 continuation of Hopf points. This function turns an initial guess for a Hopf point into a curve of Hopf points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>(x, p1, p2)-&gt; F(x, p1, p2)</code> where <code>p</code> is the parameter associated to the hopf point</li><li><code>J = (x, p1, p2)-&gt; d_xF(x, p1, p2)</code> associated jacobian</li><li><code>hopfpointguess</code> initial guess (x<em>0, p1</em>0) for the Hopf point. It should be a <code>Vector</code> or a <code>BorderedArray</code></li><li><code>p2</code> parameter p2 for which hopfpointguess is a good guess</li><li><code>eigenvec</code> guess for the iω eigenvector at p1_0</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector at p1_0</li><li><code>options::NewtonPar</code></li></ul><p>Optional arguments:</p><ul><li><code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> associated jacobian transpose</li><li><code>d2F = p2 -&gt; ((x, p1, v1, v2) -&gt; d2F(x, p1, p2, v1, v2))</code> this is the hessian of <code>F</code> computed at <code>(x, p1, p2)</code> and evaluated at <code>(v1, v2)</code>.</li></ul><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jt = nothing</code> by using <code>tranpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jt = (x, p1, p2) -&gt; transpose(d_xF(x, p1, p2))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/HopfCont.jl#L247-L270">source</a></section></article><h2 id="Continuation-for-periodic-orbits-1"><a class="docs-heading-anchor" href="#Continuation-for-periodic-orbits-1">Continuation for periodic orbits</a><a class="docs-heading-anchor-permalink" href="#Continuation-for-periodic-orbits-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationPOTrap" href="#PseudoArcLengthContinuation.continuationPOTrap"><code>PseudoArcLengthContinuation.continuationPOTrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">continuationPOTrap(prob, orbitguess, p0::Real, contParams::ContinuationPar, linearPO = :BorderedLU; printSolution = (u,p) -&gt; u[end], kwargs...)</code></pre><p>This is the continuation routine for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.</p><p><strong>Arguments</strong></p><ul><li><code>p -&gt; prob(p)</code> is a family such that <code>prob(p)::PeriodicOrbitTrapProblem</code> encodes the functional G</li><li><code>orbitguess</code> a guess for the periodic orbit where <code>orbitguess[end]</code> is an estimate of the period of the orbit. It could be a vector of size <code>N * M + 1</code> where <code>M</code> is the number of time slices, <code>N</code> is the dimension of the phase space. This must be compatible with the numbers <code>N, M</code> in <code>prob</code>.</li><li><code>p0</code> initial parameter, must be a real number</li><li><code>contParams</code> same as for the regular <code>continuation</code> method</li><li><code>linearPO = :BorderedLU</code>. Same as <code>newton</code> when applied to <code>PeriodicOrbitTrapProblem</code>.</li></ul><p>Note that by default, the methods prints the period of the periodic orbit as function of the parameter. This can be changed by providing your <code>printSolution</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/periodicorbit/PeriodicOrbitFD.jl#L664-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.continuationPOShooting-Tuple{Any,Any,Real,ContinuationPar}" href="#PseudoArcLengthContinuation.continuationPOShooting-Tuple{Any,Any,Real,ContinuationPar}"><code>PseudoArcLengthContinuation.continuationPOShooting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">continuationPOShooting(prob, orbitguess, p0::Real, contParams::ContinuationPar; printPeriod = true, kwargs...)</code></pre><p>This is the continuation routine for computing a periodic orbit using a functional G based on a Shooting method.</p><p><strong>Arguments</strong></p><ul><li><code>p -&gt; prob(p)</code> is a function or family such that <code>prob(p)::AbstractShootingProblem</code> encodes the functional G</li><li><code>orbitguess</code> a guess for the periodic orbit. For the type of <code>orbitguess</code>, please see the information concerning <code>ShootingProblem</code> and <code>PoincareShootingProblem</code>.</li><li><code>p0</code> initial parameter, must be a real number</li><li><code>contParams</code> same as for the regular <code>continuation</code> method</li><li><code>printPeriod</code> in the case of Poincaré Shooting, plot the period of the cycle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/periodicorbit/Shooting.jl#L666-L677">source</a></section></article><h2 id="Plotting-1"><a class="docs-heading-anchor" href="#Plotting-1">Plotting</a><a class="docs-heading-anchor-permalink" href="#Plotting-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.plotBranch-Tuple{ContResult}" href="#PseudoArcLengthContinuation.plotBranch-Tuple{ContResult}"><code>PseudoArcLengthContinuation.plotBranch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plotBranch(contres::ContResult, plot_fold = true; kwargs...)</code></pre><p>Plot the branch of solutions from a <code>ContResult</code>. You can also pass parameters like <code>plotBranch(br, marker = :dot)</code>. For the continuation diagram, the legend is as follows <code>(:fold =&gt; :black, :hopf =&gt; :red, :bp =&gt; :blue, :nd =&gt; :magenta, :none =&gt; :yellow)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/Plotting.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.plotBranch!-Tuple{ContResult}" href="#PseudoArcLengthContinuation.plotBranch!-Tuple{ContResult}"><code>PseudoArcLengthContinuation.plotBranch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plotBranch!(contres, plot_fold = true; putbifptlegend = true, filterbifpoints::Bool = false, kwargs...)</code></pre><p>Append to the current plot, the plot of the branch of solutions from a <code>ContResult</code>. You can also pass parameters like <code>plotBranch!(br, marker = :dot)</code>. Options to filter the bifurcation points (which are mostly guesses) are provided. For example, <code>filterbifpoints = true</code> merges the nearby Fold and Branch points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/Plotting.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PseudoArcLengthContinuation.plotBranch-Tuple{Array{T,1} where T}" href="#PseudoArcLengthContinuation.plotBranch-Tuple{Array{T,1} where T}"><code>PseudoArcLengthContinuation.plotBranch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plotBranch(contres::ContResult, plot_fold = true; kwargs...)</code></pre><p>Plot the branch of solutions from a <code>ContResult</code>. You can also pass parameters like <code>plotBranch(br, marker = :dot)</code>. For the continuation diagram, the legend is as follows <code>(:fold =&gt; :black, :hopf =&gt; :red, :bp =&gt; :blue, :nd =&gt; :magenta, :none =&gt; :yellow)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/Plotting.jl#L30-L35">source</a></section><section><div><pre><code class="language-none">plotBranch(brs::Vector, plot_fold = true; putbifptlegend = true, filterbifpoints = false, kwargs...)</code></pre><p>Plot all the branches contained in <code>brs</code> in a single figure. Convenient when many bifurcation diagram have been computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/9018dc1333d70b65c4a9e8415aff40d10dbb0935/src/Plotting.jl#L42-L46">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faq/">« Frequently Asked Questions</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 14 March 2020 10:51">Saturday 14 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
