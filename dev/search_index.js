var documenterSearchIndex = {"docs":
[{"location":"tutorialsPD/#Period-doubling-in-the-Barrio-Varea-Aragon-Maini-model-1","page":"6/ Period Doubling in BVAM model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"","category":"section"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"The purpose of this example is to show how to handle period doubling bifurcations of periodic orbits.","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"unknown: References\nThis example is taken from Aragón, J. L., R. A. Barrio, T. E. Woolley, R. E. Baker, and P. K. Maini. “Nonlinear Effects on Turing Patterns: Time Oscillations and Chaos.” Physical Review E 86, no. 2 (2012)","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"info: Method and performance\nWe focus on the Shooting method but we could have based the computation of periodic orbits on finite differences instead. Performances of the current tutorial are directly linked to the ones of DifferentialEquations.jl.     ","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"We focus on the following 1D model:","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"tagEbeginaligned\nfracpartial upartial t=D nabla^2 u+etaleft(u+a v-C u v-u v^2right)\nfracpartial vpartial t=nabla^2 v+etaleft(b v+H u+C u v+u v^2right)\nendaligned","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"with Neumann boundary conditions. We start by encoding the model","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"using Revise\nusing DiffEqOperators, ForwardDiff, DifferentialEquations, SparseArrays\nusing PseudoArcLengthContinuation, LinearAlgebra, Plots, Setfield\nconst PALC = PseudoArcLengthContinuation\n\nnorminf = x -> norm(x, Inf)\nf(u, v, p) = p.η * (      u + p.a * v - p.C * u * v - u * v^2)\ng(u, v, p) = p.η * (p.H * u + p.b * v + p.C * u * v + u * v^2)\n\nfunction Laplacian(N, lx, bc = :Dirichlet)\n\thx = 2lx/N\n\tD2x = CenteredDifference(2, 2, hx, N)\n\tif bc == :Neumann\n\t\tQx = Neumann0BC(hx)\n\telseif bc == :Dirichlet\n\t\tQx = Dirichlet0BC(typeof(hx))\n\tend\n\tD2xsp = sparse(D2x * Qx)[1]\nend\n\nfunction NL!(dest, u, p, t = 0.)\n\tN = div(length(u), 2)\n\tu1 =  @view (u[1:N])\n\tu2 =  @view (u[N+1:end])\n\tdest[1:N]     .= f.(u1, u2, Ref(p))\n\tdest[N+1:end] .= g.(u1, u2, Ref(p))\n\treturn dest\nend\n\nfunction Fbr!(f, u, p)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\nend\n\nfunction NL(u, p)\n\tout = similar(u)\n\tNL!(out, u, p)\n\tout\nend\n\nfunction Fbr(x, p, t = 0.)\n\tf = similar(x)\n\tFbr!(f, x, p)\nend\n\n# this is not very efficient but simple enough ;)\nJbr(x,p) = sparse(ForwardDiff.jacobian(x -> Fbr(x, p), x))","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"We can now perform bifurcation of the following Turing solution:","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"N = 100\nn = 2N\nlx = 3pi /2\nX = LinRange(-lx,lx, N)\n\nΔ = Laplacian(N, lx, :Neumann)\nD = 0.08\npar_br = (η = 1.0, a = -1., b = -3/2., H = 3.0, D = D, C = -0.6, Δ = blockdiag(D*Δ, Δ))\n\nu0 = 1.0 * cos.(2X)\nsolc0 = vcat(u0, u0)\n\n# parameters for continuation\neigls = EigArpack(0.5, :LM)\nopt_newton = NewtonPar(eigsolver = eigls, verbose=true, maxIter = 3200, tol=1e-9)\nopts_br = ContinuationPar(dsmax = 0.04, ds = -0.01, pMin = -1.8,\n\tdetectBifurcation = 2, nev = 21, plotEveryNsteps = 50, newtonOptions = opt_newton, maxSteps = 400)\n\nbr, _ = @time continuation(\n\t(x, p) -> Fbr(x, @set par_br.C = p),\n\t(x, p) -> Jbr(x, @set par_br.C = p),\n\tsolc0, -0.2,\n\topts_br;\n\tplot = true, verbosity = 2,\n\tprintSolution = (x, p) -> norm(x, Inf),\n\tplotSolution = (x; kwargs...) -> plot!(x[1:end÷2];label=\"\",ylabel =\"u\", kwargs...))","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"which yields","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"(Image: )","category":"page"},{"location":"tutorialsPD/#Periodic-orbits-from-the-Hopf-point-(Shooting)-1","page":"6/ Period Doubling in BVAM model","title":"Periodic orbits from the Hopf point (Shooting)","text":"","category":"section"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"We continue the periodic orbit form the first Hopf point around Capprox -08598 using a Standard Simple Shooting method (see Periodic orbits based on the shooting method). To this end, we define a SplitODEProblem from DifferentialEquations.jl which is convenient for solving semilinear problems of the form ","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"dot x = Ax+g(x)","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"where A is the infinitesimal generator of a C_0-semigroup. We use the exponential-RK scheme ETDRK2 ODE solver to compute the solution of (E) just after the Hopf point. ","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"f1 = DiffEqArrayOperator(par_br.Δ)\nf2 = NL!\nprob_sp = SplitODEProblem(f1, f2, solc0, (0.0, 280.0), @set par_br.C = -0.86)\n\nsol = @time solve(prob_sp, ETDRK2(krylov=true); abstol=1e-14, reltol=1e-14, dt = 0.1)","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"We estimate the period of the limit cycle to be around Tapprox 3. We then use this as a guess for the shooting method:","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"# compute the guess for the shooting method\norbitsection = Array(sol[:, end])\ninitpo = vcat(vec(orbitsection), 3.)\n\n# define the functional for the standard simple shooting based on the \n# ODE solver ETDRK2. SectionShooting implements an appropriate phase condition\nprobSh = p -> ShootingProblem(u -> Fbr(u, p), p, prob_sp, ETDRK2(krylov=true),\n1, x -> PALC.sectionShooting(x, Array(sol[:,[end]]), p, Fbr); atol = 1e-14, rtol = 1e-14, dt = 0.1)\n\nls = GMRESIterativeSolvers(tol = 1e-7, N = length(initpo), maxiter = 50, verbose = false)\noptn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 120, linsolver = ls)\nout_po_sh, _, flag = @time newton(probSh(@set par_br.C = -0.86),\n\tinitpo, optn; normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", out_po_sh[end], \", amplitude = \", PALC.getAmplitude(probSh(@set par_br.C = -0.86), out_po_sh; ratio = 2),\"\\n\")","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"which gives","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"--> T = 2.94557883943451, amplitude = 0.05791350025709674","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"We can now continue this periodic orbit:","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"eig = DefaultEig()\nopts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.01, ds= 0.005, pMin = -1.8, maxSteps = 170, newtonOptions = (@set optn.eigsolver = eig),\n\tnev = 10, precisionStability = 1e-2, detectBifurcation = 2)\n\tbr_po_sh, _ , _ = @time continuationPOShooting(\n\t\tp -> probSh(@set par_br.C = p),\n\t\topts_po_cont, -0.86,\n\t\topts_po_cont; verbosity = 3,\n\t\tplot = true,\n\t\tplotSolution = (x; kwargs...) -> PALC.plotPeriodicShooting!(x[1:end-1], 1; kwargs...),\n\t\tprintSolution = (u, p) -> PALC.getMaximum(probSh(@set par_br.C = p), u; ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"We plot the result using plotBranch(vcat(br_po_sh, br), label = \"\"):","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"(Image: )","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"tip: Numerical precision for stability\nThe Floquet multipliers are not very precisely computed here using the Shooting method. We know that 1=exp(0) should be a Floquet multiplier but this is only true here at precision ~1e-3. In order to prevent spurious bifurcation detection, there is a threshold precisionStability in ContinuationPar for declaring an unstable eigenvalue. Another way would be to use Poincaré Shooting so that this issue does not show up.","category":"page"},{"location":"tutorialsPD/#Periodic-orbits-from-the-PD-point-(Shooting)-1","page":"6/ Period Doubling in BVAM model","title":"Periodic orbits from the PD point (Shooting)","text":"","category":"section"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"We now compute the periodic orbits branching of the first Period-Doubling bifurcation point. It is straightforward to obtain an initial guess using the flow around the bifurcation point:","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"prob_sp = SplitODEProblem(f1, f2, solc0, (0.0, 300.0), @set par_br.C = -1.32)\n# solution close to the PD point.\nsolpd = @time solve(prob_sp, ETDRK2(krylov=true); abstol=1e-14, reltol=1e-14, dt = 0.1)","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"The estimated period is T_pd=62:","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"orbitsectionpd = Array(solpd[:,end-100])\ninitpo_pd = vcat(vec(orbitsectionpd), 6.2)","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"For educational purposes, we show the newton outputs:","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"out_po_sh_pd, _, flag = @time newton(\n\t\tprobSh(@set par_br.C = -1.32),\n\t\tinitpo_pd, optn;normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", out_po_sh_pd[end], \", amplitude = \", PALC.getAmplitude(probSh(@set par_br.C = -0.86), out_po_sh_pd; ratio = 2),\"\\n\")","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"which gives","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     1.3462e-01         0\n        1                2     2.1845e-02        11\n        2                3     4.6417e-03        12\n        3                4     6.9467e-04        13\n        4                5     8.3113e-06        12\n        5                6     2.5982e-07        13\n        6                7     1.1674e-08        14\n        7                8     5.2221e-10        13\n  4.845103 seconds (3.07 M allocations: 1.959 GiB, 5.37% gc time)\n--> T = 6.126423339476528, amplitude = 1.8457951639694683","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"We also compute the branch of periodic orbits using the following command:","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"opts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.005, ds= 0.001, pMin = -1.8, maxSteps = 100, newtonOptions = (@set optn.eigsolver = eig), nev = 5, precisionStability = 1e-3, detectBifurcation = 1)\nbr_po_sh_pd, _ , _ = @time continuationPOShooting(\n\tp -> probSh(@set par_br.C = p),\n\tout_po_sh_pd, -1.32,\n\topts_po_cont; verbosity = 2,\n\tplot = true,\n\tplotSolution = (x; kwargs...) -> PALC.plotPeriodicShooting!(x[1:end-1], 1; kwargs...),\n\tprintSolution = (u, p) -> PALC.getMaximum(probSh(@set par_br.C = p), u; ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"and plot it using plotBranch(vcat(br_po_sh, br, br_po_sh_pd), label = \"\"):","category":"page"},{"location":"tutorialsPD/#","page":"6/ Period Doubling in BVAM model","title":"6/ Period Doubling in BVAM model","text":"(Image: )","category":"page"},{"location":"periodicOrbitFD/#Periodic-orbits-based-on-finite-differences-1","page":"Periodic Orbits (Finite Differences)","title":"Periodic orbits based on finite differences","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"We have implemented a method where we compute M slices of a periodic orbit. This is implemented by PeriodicOrbitTrapProblem for which the problem of finding periodic orbits is discretized using Finite Differences based on a trapezoidal rule. ","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"unknown: References\nThe general method is very well exposed in Hopf Bifurcation and Time Periodic Orbits with Pde2path – Algorithms and Applications., Uecker, Hannes, Communications in Computational Physics 25, no. 3 (2019) and in the PhD thesis Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust, Kurt, 1997. We adopt the notations of the first reference.","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"We look for periodic orbits as solutions (x(0)T) of","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"dot x = Tcdot F(x) x(0)=x(1)","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"By discretizing this equation, we obtain","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"beginarrayl\n0= left(x_j-x_j-1right)-frach2 left(Fleft(x_jright)+Fleft(x_j-1right)right)equiv G_j(x)quad j=1cdotsm-1  \n0= x_m-x_1 equiv G_m(x) \n0= x_1-x_piphi\nendarray","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"where x_0=x_m and h=Tm. The Jacobian of the system of equations w.r.t. (x_0T) is given by ","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"mathcalJ=left(beginarrayccA_1  partial_TG  star  dendarrayright)","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"where ","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"A_gamma=left(beginarrayccccccc\nM_1  0  0  0  cdots  -H_1  0  \n-H_2  M_2  0  0  cdots  0  0  \n0  -H_3  M_3  0  cdots  0  0  \nvdots  cdots  ddots  ddots  ddots  vdots  vdots  \n0  cdots  cdots  ddots  ddots  0  0  \n0  cdots  cdots  0  -H_m-1  M_m-1  0  \n-gamma I  0  cdots  cdots  cdots  0  I\nendarrayright)","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"with M_i = I-\tfrac h2partial_uF(x_i) and H_i = I+frac h2partial_uF(x_i-1).","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"We solve the linear equation mathcal Jcdot sol = rhs with a bordering strategy (a linear solver <: AbstractBorderedLinearSolver) which in turn requires to solve A_gamma z=b where z=(xx_m). We also solve this equation with a bordering strategy but this time, it can be simplified as follows. If we write b=(fg), one gets J_c x=f and x_m=g+gamma x_1 where x_1 is the first time slice of x. Note that we call J_c the following cyclic matrix:","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"J_c=left(beginarrayccccccc\nM_1  0  0  0  cdots  -H_1  \n-H_2  M_2  0  0  cdots  0  \n0  -H_3  M_3  0  cdots  0  \nvdots  cdots  ddots  ddots  ddots  vdots  \n0  cdots  cdots  ddots  ddots  0  \n0  cdots  cdots  0  -H_m-1  M_m-1  \nendarrayright)","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"Our code thus provides methods to invert J_c and A_gamma using a sparse solver or a Matrix-Free solver. A preconditioner can be used. ","category":"page"},{"location":"periodicOrbitFD/#Encoding-of-the-functional-1","page":"Periodic Orbits (Finite Differences)","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"The functional is encoded in the composite type PeriodicOrbitTrapProblem. See the link for more information, in particular on how to access the underlying functional, its jacobian and other matrices related to it like A_gamma J_c...","category":"page"},{"location":"periodicOrbitFD/#Preconditioning-1","page":"Periodic Orbits (Finite Differences)","title":"Preconditioning","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"We strongly advise you to use a preconditioner to deal with the above linear problem. See Complex Ginzburg-Landau 2d for an example.","category":"page"},{"location":"periodicOrbitFD/#Floquet-multipliers-computation-1","page":"Periodic Orbits (Finite Differences)","title":"Floquet multipliers computation","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"A not very precise algorithm for computing the Floquet multipliers is provided. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations of periodic orbits. It seems to work reasonably well for the tutorials considered here. For more information, have a look at FloquetQaDTrap.","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"note: Algorithm\nA more precise algorithm, based on the periodic Schur decomposition will be implemented in the future.","category":"page"},{"location":"periodicOrbitFD/#Computation-with-newton-1","page":"Periodic Orbits (Finite Differences)","title":"Computation with newton","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"We provide a simplified call to newton to locate the periodic orbits. Compared to the regular newton function, there is an additional option linearalgo to select one of the many ways to deal with the above linear problem. The default solver linearalgo is :BorderedLU.","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"Have a look at the Continuation of periodic orbits (Finite differences) example for the Brusselator for a basic example and at Complex Ginzburg-Landau 2d for a more advanced one. ","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"The docs for this specific newton are located at Newton for Periodic Orbits.","category":"page"},{"location":"periodicOrbitFD/#Computation-with-newton-and-deflation-1","page":"Periodic Orbits (Finite Differences)","title":"Computation with newton and deflation","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"We also provide a simplified call to newton to locate the periodic orbit with a deflation operator. ","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"newton(probPO::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, defOp::DeflationOperator{T, Tf, vectype}, linearalgo::Symbol; kwargs...) where {T, Tf, vectype}","category":"page"},{"location":"periodicOrbitFD/#PseudoArcLengthContinuation.newton-Union{Tuple{vectype}, Tuple{Tf}, Tuple{T}, Tuple{PeriodicOrbitTrapProblem,Any,NewtonPar,DeflationOperator{T,Tf,vectype},Symbol}} where vectype where Tf where T","page":"Periodic Orbits (Finite Differences)","title":"PseudoArcLengthContinuation.newton","text":"newton(probPO::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, defOp::DeflationOperator{T, Tf, vectype}, linearPO = :BorderedLU; kwargs...) where {T, Tf, vectype}\n\nThis function is similar to newton(probPO, orbitguess, options, linearPO; kwargs...) except that it uses deflation in order to find periodic orbits different from the one in defOp. For example, it can be used in the vicinity of a Hopf bifurcation to prevent the Newton algorithm from converging to the equilibrium point.\n\n\n\n\n\n","category":"method"},{"location":"periodicOrbitFD/#Continuation-1","page":"Periodic Orbits (Finite Differences)","title":"Continuation","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"Have a look at the Continuation of periodic orbits (Finite differences) example for the Brusselator.","category":"page"},{"location":"periodicOrbitFD/#","page":"Periodic Orbits (Finite Differences)","title":"Periodic Orbits (Finite Differences)","text":"continuationPOTrap","category":"page"},{"location":"periodicOrbitFD/#PseudoArcLengthContinuation.continuationPOTrap","page":"Periodic Orbits (Finite Differences)","title":"PseudoArcLengthContinuation.continuationPOTrap","text":"continuationPOTrap(prob, orbitguess, p0::Real, contParams::ContinuationPar, linearPO = :BorderedLU; printSolution = (u,p) -> u[end], kwargs...)\n\nThis is the continuation routine for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.\n\nArguments\n\np -> prob(p) is a family such that prob(p)::PeriodicOrbitTrapProblem encodes the functional G\norbitguess a guess for the periodic orbit where orbitguess[end] is an estimate of the period of the orbit. It could be a vector of size N * M + 1 where M is the number of time slices, N is the dimension of the phase space. This must be compatible with the numbers N, M in prob.\np0 initial parameter, must be a real number\ncontParams same as for the regular continuation method\nlinearPO = :BorderedLU. Same as newton when applied to PeriodicOrbitTrapProblem.\n\nNote that by default, the methods prints the period of the periodic orbit as function of the parameter. This can be changed by providing your printSolution argument.\n\n\n\n\n\n","category":"function"},{"location":"tutorials1/#Temperature-model-1","page":"1/ Temperature model","title":"Temperature model","text":"","category":"section"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"This is a classical example from the Trilinos library.","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"This is a simple example in which we aim at solving Delta T+alpha N(Tbeta)=0 with boundary conditions T(0) = T(1)=beta. This example is coded in examples/chan.jl. We start with some imports:","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"using PseudoArcLengthContinuation, LinearAlgebra, Plots\nconst PALC = PseudoArcLengthContinuation\n\nN(x; a = 0.5, b = 0.01) = 1 + (x + a*x^2)/(1 + b*x^2)","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"We then write our functional:","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"function F_chan(x, α, β = 0.01)\n\tf = similar(x)\n\tn = length(x)\n\tf[1] = x[1] - β\n\tf[n] = x[n] - β\n\tfor i=2:n-1\n\t\tf[i] = (x[i-1] - 2 * x[i] + x[i+1]) * (n-1)^2 + α * N(x[i], b = β)\n\tend\n\treturn f\nend","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"We want to call a Newton solver. We first need an initial guess:","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"n = 101\nsol = [(i-1)*(n-i)/n^2+0.1 for i=1:n]","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"Finally, we need to provide some parameters for the Newton iterations. This is done by calling","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"optnewton = NewtonPar(verbose = true)","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"We call the Newton solver:","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"out, _, _ = @time newton(\n\t\tx -> F_chan(x, 3.3),\n\t\tsol, optnewton)","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"and you should see","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     2.3440e+01         0\n        1                2     1.3774e+00         1\n        2                3     1.6267e-02         1\n        3                4     2.4521e-06         1\n        4                5     5.9356e-11         1\n  0.098594 seconds (105.74 k allocations: 6.938 MiB)","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"Note that, in this case, we did not give the Jacobian. It was computed internally using Finite Differences. ","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"This is not as bad as it looks despite the fact that there are so many allocations even with Finite Differences Jacobian. Using BenchmarkTools.jl, one actually finds 1.153 ms (2067 allocations: 2.04 MiB). This is reasonable as we did not code the problem with much care...","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"We can perform numerical continuation w.r.t. the parameter alpha. This time, we need to provide additional parameters, but now for the continuation method:","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"optcont = ContinuationPar(dsmin = 0.01, dsmax = 0.15, ds= 0.01, pMax = 4.1, newtonOptions = NewtonPar(tol = 1e-9))","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"Next, we call the continuation routine","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"br, _ = continuation((x, p) -> F_chan(x, p),\n\tout, 3.3, optcont, plot = true,\n\tplotSolution = (x;kwargs...) -> (plot!(x; ylabel=\"solution\",label=\"\",kwargs...)))","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"tip: Tip\nWe don't need to call newton first in order to use continuation.","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"You should see (Image: )","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"The left figure is the norm of the solution as function of the parameter p=alpha, the y-axis can be changed by passing a different printSolution to continuation. The top right figure is the value of alpha as function of the iteration number. The bottom right is the solution for the current value of the parameter. This last plot can be modified by changing the argument plotSolution to continuation.","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"note: Bif. point detection\nTwo Fold points were detected. This can be seen by looking at br.foldpoint or by the black \tdots on the continuation plots. Note that the bifurcation points are located in br.bifpoint.","category":"page"},{"location":"tutorials1/#Continuation-of-Fold-points-1","page":"1/ Temperature model","title":"Continuation of Fold points","text":"","category":"section"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"We get a summary of the branch by doing","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"julia> br\nBranch number of points: 78\nFold points:\n-   1,    fold point around p ≈ 4.03439121, step =  11, idx =  11, ind_bif =   0\n-   2,    fold point around p ≈ 3.15581463, step =  35, idx =  35, ind_bif =   0","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"We can take the first Fold point, which has been guessed during the previous continuation run and locate it precisely. However, this only works well when the jacobian is computed analytically:","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"# derivative of N\ndN(x; a = 0.5, b = 0.01) = (1-b*x^2+2*a*x)/(1+b*x^2)^2\n\n# Jacobian of F_chan\nfunction Jac_mat(u, α, β = 0.01)\n\tn = length(u)\n\tJ = zeros(n, n)\n\tJ[1, 1] = 1.0\n\tJ[n, n] = 1.0\n\tfor i = 2:n-1\n\t\tJ[i, i-1] = (n-1)^2\n\t\tJ[i, i+1] = (n-1)^2\n\t\tJ[i, i] = -2 * (n-1)^2 + α * dN(u[i], b = β)\n\tend\n\treturn J\nend\n\n# index of the Fold bifurcation point in br.bifpoint\nindfold = 2\n\noutfold, _, flag = newtonFold(\n\t\t(x, α) -> F_chan(x, α),\n\t\t(x, α) -> Jac_mat(x, α),\n\t\tbr, indfold, #index of the fold point\n\t\toptcont.newtonOptions)\nflag && printstyled(color=:red, \"--> We found a Fold Point at α = \", outfold.p, \", β = 0.01, from \", br.foldpoint[indfold].param, \"\\n\")","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"which gives","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"--> We found a Fold Point at α = 3.1556507316107947, β = 0.01, from 3.155651011218501","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"We can finally continue this fold point in the plane (ab) by performing a Fold Point continuation. In the present case, we find a Cusp point.","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"tip: Tip\nWe don't need to call newtonFold first in order to use continuationFold.","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"optcontfold = ContinuationPar(dsmin = 0.001, dsmax = 0.05,ds= 0.01, pMax = 4.1, pMin = 0.)\n\toutfoldco, _, _ = @time continuationFold(\n\t\t(x, α, β) ->  F_chan(x, α, β),\n\t\t(x, α, β) -> Jac_mat(x, α, β),\n\t\tbr, indfold,\n\t\t0.01,\n\t\toptcontfold)\n\nplotBranch(outfoldco; xlabel=\"beta\", ylabel=\"alpha\")","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"This produces:","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"(Image: )","category":"page"},{"location":"tutorials1/#Using-GMRES-or-another-linear-solver-1","page":"1/ Temperature model","title":"Using GMRES or another linear solver","text":"","category":"section"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"We continue the previous example but now using Matrix Free methods. The user can pass its own solver by implementing a version of LinearSolver. Some linear solvers have been implemented from KrylovKit.jl and IterativeSolvers.jl (see Linear solvers for more information), we can use them here. Note that we can also use preconditioners as shown below. The same functionality is present for the eigensolver.","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"# Matrix Free version of the differential of F_chan\n# Very easy to write since we have F_chan. \n# We could use Automatic Differentiation as well\nfunction dF_chan(x, dx, α, β = 0.01)\n\tout = similar(x)\n\tn = length(x)\n\tout[1] = dx[1]\n\tout[n] = dx[n]\n\tfor i=2:n-1\n\t\tout[i] = (dx[i-1] - 2 * dx[i] + dx[i+1]) * (n-1)^2 + α * dN(x[i], b = β) * dx[i]\n\tend\n\treturn out\nend\n\n# we create a new linear solver\nls = GMRESKrylovKit(dim = 100)\n\n# and pass it to the newton parameters\noptnewton_mf = NewtonPar(verbose = true, linsolver = ls)\n\n# we can then call the newton solver\nout_mf, _, _ = @time newton(\n\tx -> F_chan(x, 3.3),\n\t# we pass the differential a x, \n\t# which is a linear operator in dx\n\tx -> (dx -> dF_chan(x, dx, 3.3)),\n\tsol,\n\toptnewton_mf)","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"which gives:","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     2.3440e+01         0\n        1                2     1.3774e+00        68\n        2                3     1.6267e-02        98\n        3                4     2.4336e-06        73\n        4                5     6.2617e-12        73\n  0.248527 seconds (963.53 k allocations: 46.840 MiB)","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"We can improve this computation, i.e. reduce the number of Linear-Iterations, by using a preconditioner","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"using SparseArrays\n\n# define preconditioner which is basically Δ\nP = spdiagm(0 => -2 * (n-1)^2 * ones(n), -1 => (n-1)^2 * ones(n-1), 1 => (n-1)^2 * ones(n-1))\nP[1,1:2] .= [1, 0.];P[end,end-1:end] .= [0, 1.]\n\n# define gmres solver with left preconditioner\nls = GMRESIterativeSolvers(tol = 1e-4, N = length(sol), restart = 10, maxiter = 10, Pl = lu(P))\n\toptnewton_mf = NewtonPar(verbose = true, linsolver = ls)\n\tout_mf, _, _ = @time newton(\n\t\tx -> F_chan(x, 3.3),\n\t\tx -> (dx -> dF_chan(x, dx, 3.3)),\n\t\tsol,\n\t\toptnewton_mf)","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":"which gives","category":"page"},{"location":"tutorials1/#","page":"1/ Temperature model","title":"1/ Temperature model","text":" Newton Iterations\n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     2.3440e+01         0\n        1                2     1.3777e+00         3\n        2                3     1.6266e-02         3\n        3                4     2.3699e-05         2\n        4                5     4.8930e-09         3\n        5                6     6.3288e-12         4","category":"page"},{"location":"tutorialsCGL/#Complex-Ginzburg-Landau-2d-1","page":"7/ Ginzburg-Landau 2d (GPU)","title":"Complex Ginzburg-Landau 2d","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"This example is also treated in the MATLAB library pde2path.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We look at the Ginzburg-Landau equations in 2d. The code is very similar to the Brusselator example except that some special care has to be taken in order to cope with the \"high\" dimensionality of the problem.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Note that we try to be pedagogical here. Hence, we may write \"bad\" code that we improve later. Finally, we could use all sort of tricks to take advantage of the specificity of the problem. Rather, we stay quite close to the example in the MATLAB library pde2path (and discussed in Hopf Bifurcation and Time Periodic Orbits with Pde2path – Algorithms and Applications., Uecker, Hannes, Communications in Computational Physics 25, no. 3 (2019)) for fair comparison.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"The equations are as follows","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"partial_t u=Delta u+(r+mathrmi v) u-left(c_3+mathrmi muright)u^2 u-c_5u^4 u quad u=u(t x) in mathbbC","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"with Dirichlet boundary conditions. We discretize the square Omega = (0L_x)times(0L_y) with 2N_xN_y points. We start by writing the Laplacian:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"using Revise\nusing DiffEqOperators, ForwardDiff\nusing PseudoArcLengthContinuation, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield\nconst PALC = PseudoArcLengthContinuation\n\nnorminf = x -> norm(x, Inf)\n\nfunction Laplacian2D(Nx, Ny, lx, ly, bc = :Dirichlet)\n\thx = 2lx/Nx\n\thy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\tif bc == :Neumann\n\t\tQx = Neumann0BC(hx)\n\t\tQy = Neumann0BC(hy)\n\telseif  bc == :Dirichlet\n\t\tQx = Dirichlet0BC(typeof(hx))\n\t\tQy = Dirichlet0BC(typeof(hy))\n\tend\n\t\n\tD2xsp = sparse(D2x * Qx)[1]\n\tD2ysp = sparse(D2y * Qy)[1]\n\t\n\tA = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))\n\treturn A, D2x\nend","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"It is then straightforward to write the vector field","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"# this encodes the nonlinearity\nfunction NL(u, p)\n\t@unpack r, μ, ν, c3, c5 = p\n\tn = div(length(u), 2)\n\tu1 = @view u[1:n]\n\tu2 = @view u[n+1:2n]\n\n\tua = u1.^2 .+ u2.^2\n\n\tf = similar(u)\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@. f1 .= r * u1 - ν * u2 - ua * (c3 * u1 - μ * u2) - c5 * ua^2 * u1\n\t@. f2 .= r * u2 + ν * u1 - ua * (c3 * u2 + μ * u1) - c5 * ua^2 * u2\n\n\treturn f\nend\n\nfunction Fcgl(u, p)\n\tf = similar(u)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\nend","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"and its jacobian:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"function Jcgl(u, p)\n\t@unpack r, μ, ν, c3, c5, Δ = p\n\n\tn = div(length(u), 2)\n\tu1 = @view u[1:n]\n\tu2 = @view u[n+1:2n]\n\n\tua = u1.^2 .+ u2.^2\n\n\tf1u = zero(u1)\n\tf2u = zero(u1)\n\tf1v = zero(u1)\n\tf2v = zero(u1)\n\n\t@. f1u =  r - 2 * u1 * (c3 * u1 - μ * u2) - c3 * ua - 4 * c5 * ua * u1^2 - c5 * ua^2\n\t@. f1v = -ν - 2 * u2 * (c3 * u1 - μ * u2)  + μ * ua - 4 * c5 * ua * u1 * u2\n\t@. f2u =  ν - 2 * u1 * (c3 * u2 + μ * u1)  - μ * ua - 4 * c5 * ua * u1 * u2\n\t@. f2v =  r - 2 * u2 * (c3 * u2 + μ * u1) - c3 * ua - 4 * c5 * ua * u2 ^2 - c5 * ua^2\n\n\tjacdiag = vcat(f1u, f2v)\n\n\tΔ + spdiagm(0 => jacdiag, n => f1v, -n => f2u)\nend","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We now define the parameters and the stationary solution:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Nx = 41\nNy = 21\nn = Nx * Ny\nlx = pi\nly = pi/2\n\nΔ = Laplacian2D(Nx, Ny, lx, ly)[1]\npar_cgl = (r = 0.5, μ = 0.1, ν = 1.0, c3 = -1.0, c5 = 1.0, Δ = blockdiag(Δ, Δ))\nsol0 = zeros(2Nx, Ny)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"and we continue it to find the Hopf bifurcation points. We use a Shift-Invert eigensolver.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"# Shift-Invert eigensolver\neigls = EigArpack(1.0, :LM)\nopt_newton = NewtonPar(tol = 1e-10, verbose = true, eigsolver = eigls)\nopts_br = ContinuationPar(dsmin = 0.001, dsmax = 0.005, ds = 0.001, pMax = 2., detectBifurcation = 1, nev = 5, plotEveryNsteps = 50, newtonOptions = opt_newton, maxSteps = 1060)\n\nbr, _ = @time continuation(\n\t(x, p) -> Fcgl(x, @set par_cgl.r = p),\n\t(x, p) -> Jcgl(x, @set par_cgl.r = p),\n\tvec(sol0), par_cgl.r, opts_br, verbosity = 0)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/#Periodic-orbits-continuation-with-stability-1","page":"7/ Ginzburg-Landau 2d (GPU)","title":"Periodic orbits continuation with stability","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Having found two Hopf bifurcation points, we aim at computing the periodic orbits branching from them. Like for the Brusselator example, we need to find some educated guess for the periodic orbits in order to have a successful Newton call.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"The following code is very close to the one explained in the tutorial Brusselator 1d so we won't give too much details here.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We focus on the first Hopf bifurcation point. Note that, we do not improve the guess for the Hopf bifurcation point, e.g. by calling newtonHopf, as this is not really needed.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"# index of the Hopf point we want to branch from\nind_hopf = 1\n\n# number of time slices in the periodic orbit\nM = 30\n\n# periodic orbit initial guess\nr_hopf, Th, orbitguess2, hopfpt, vec_hopf = guessFromHopf(br, ind_hopf, opt_newton.eigsolver, M, 22*sqrt(0.1); phase = 0.25)\n\n# flatten the initial guess\norbitguess_f2 = reduce(hcat, orbitguess2)\norbitguess_f = vcat(vec(orbitguess_f2), Th) |> vec","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Like in the Brusselator 1d example, we create a problem to hold the functional and find periodic orbits based on Finite Differences","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"poTrap = p -> PeriodicOrbitTrapProblem(\n# vector field\n\tx ->  Fcgl(x, p),\n# sparse representation of the Jacobian\t\n\tx ->  Jcgl(x, p),\n# parameters for the phase condition\n\treal.(vec_hopf),\n\thopfpt.u,\n# number of time slices\t\n\tM)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We can use this (family) problem poTrap with newton on our periodic orbit guess to find a periodic orbit. Hence, one can be tempted to use","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"danger: Don't run this!!\nIt uses too much memory opts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.03, ds= 0.001, pMax = 2.5, \t maxSteps = 250, plotEveryNsteps = 3, newtonOptions = (@set opt_po.linsolver = DefaultLS()))\nbr_po, upo , _= @time continuationPOTrap(p -> poTrap(@set par_cgl.r = p),\n orbitguess_f, r_hopf - 0.01, opts_po_cont)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"However, the linear system associated to the newton iterations will be solved by forming the sparse jacobian of size (2N_xN_yM+1)^2 and the use of \\ (based on LU decomposition). It takes way too much time and memory.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Instead, we use a preconditioner. We build the jacobian once, compute its incomplete LU decomposition (ILU) and use it as a preconditioner.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"using IncompleteLU\n\n# Sparse matrix representation of the jacobian of the periodic orbit functional\nJpo = poTrap(@set par_cgl.r = r_hopf - 0.01)(Val(:JacFullSparse), orbitguess_f)\n\n# incomplete LU factorization with threshold\nPrecilu = @time ilu(Jpo, τ = 0.005)\n\n# we define the linear solver with left preconditioner Precilu\nls = GMRESIterativeSolvers(verbose = false, tol = 1e-3, N = size(Jpo,1), restart = 40, maxiter = 50, Pl = Precilu, log=true)\n\n# we try the linear solver\nls(Jpo, rand(ls.N))","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"This converges in 7 iterations whereas, without the preconditioner, it does not converge after 100 iterations. ","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We set the parameters for the newton solve.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"opt_po = @set opt_newton.verbose = true\noutpo_f, _, flag = @time newton(poTrap(@set par_cgl.r = r_hopf - 0.01),\n\torbitguess_f, (@set opt_po.linsolver = ls), \n\t:FullMatrixFree; normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", outpo_f[end], \", amplitude = \", PALC.amplitude(outpo_f, Nx*Ny, M; ratio = 2),\"\\n\")\nPALC.plotPeriodicPOTrap(outpo_f, M, Nx, Ny; ratio = 2);","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"which gives ","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     6.5509e-03         0\n        1                2     1.4311e-03         9\n        2                3     3.6948e-04         9\n        3                4     6.5156e-05        10\n        4                5     4.3270e-06        11\n        5                6     3.9205e-08        12\n        6                7     1.0685e-10        13\n        7                8     1.0492e-13        14\n  1.896905 seconds (165.04 k allocations: 1.330 GiB, 12.03% gc time)\n--> T = 6.5367097374070315, amplitude = 0.3507182067194716","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"and","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"At this point, we are still wasting a lot of resources, because the matrix-free version of the jacobian of the functional uses the jacobian of the vector field x ->  Jcgl(x, p). Hence, it builds M sparse matrices for each evaluation!! Let us create a problem which is fully Matrix Free:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"# computation of the first derivative using automatic differentiation\nd1Fcgl(x, p, dx) = ForwardDiff.derivative(t -> Fcgl(x .+ t .* dx, p), 0.)\n\n# linear solver for solving Jcgl*x = rhs. Needed for Floquet multipliers computation\nls0 = GMRESIterativeSolvers(N = 2Nx*Ny, tol = 1e-9, Pl = lu(I + par_cgl.Δ))\n\n# matrix-free problem\npoTrapMF = p -> PeriodicOrbitTrapProblem(\n\tx ->  Fcgl(x, p),\n\tx ->  (dx -> d1Fcgl(x, p, dx)),\n\treal.(vec_hopf),\n\thopfpt.u,\n\tM, ls0)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We can now use newton","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"outpo_f, _, flag = @time newton(poTrapMF(@set par_cgl.r = r_hopf - 0.01),\n\torbitguess_f, (@set opt_po.linsolver = ls), \n\t:FullMatrixFree; normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", outpo_f[end], \", amplitude = \", PALC.amplitude(outpo_f, Nx*Ny, M; ratio = 2),\"\\n\")","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"which gives ","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     6.5509e-03         0\n        1                2     1.4311e-03         9\n        2                3     3.6948e-04         9\n        3                4     6.5156e-05        10\n        4                5     4.3270e-06        11\n        5                6     3.9205e-08        12\n        6                7     1.0685e-10        13\n        7                8     1.0495e-13        14\n  1.251035 seconds (69.10 k allocations: 488.773 MiB, 3.95% gc time)\n--> T = 6.53670973740703, amplitude = 0.3507182067194715","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"The speedup will increase a lot for larger N_x N_y. Also, for Floquet multipliers computation, the speedup will be substantial.","category":"page"},{"location":"tutorialsCGL/#Removing-most-allocations-(Advanced-and-Experimental)-1","page":"7/ Ginzburg-Landau 2d (GPU)","title":"Removing most allocations (Advanced and Experimental)","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We show here how to remove most allocations and speed up the computations. This is an experimental feature as the Floquet multipliers computation is not yet readily available in this case. To this end, we rewrite the functional using inplace formulation and trying to avoid allocations. This can be done as follows:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"# compute just the nonlinearity\nfunction NL!(f, u, p, t = 0.)\n\t@unpack r, μ, ν, c3, c5 = p\n\tn = div(length(u), 2)\n\tu1v = @view u[1:n]\n\tu2v = @view u[n+1:2n]\n\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@inbounds for ii = 1:n\n\t\tu1 = u1v[ii]\n\t\tu2 = u2v[ii]\n\t\tua = u1^2+u2^2\n\t\tf1[ii] = r * u1 - ν * u2 - ua * (c3 * u1 - μ * u2) - c5 * ua^2 * u1\n\t\tf2[ii] = r * u2 + ν * u1 - ua * (c3 * u2 + μ * u1) - c5 * ua^2 * u2\n\tend\n\treturn f\nend\n\n# derivative of the nonlinearity\nfunction dNL!(f, u, p, du)\n\t@unpack r, μ, ν, c3, c5 = p\n\tn = div(length(u), 2)\n\tu1v = @view u[1:n]\n\tu2v = @view u[n+1:2n]\n\n\tdu1v = @view du[1:n]\n\tdu2v = @view du[n+1:2n]\n\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@inbounds for ii = 1:n\n\t\tu1 = u1v[ii]\n\t\tu2 = u2v[ii]\n\t\tdu1 = du1v[ii]\n\t\tdu2 = du2v[ii]\n\t\tua = u1^2+u2^2\n\t\tf1[ii] = (-5*c5*u1^4 + (-6*c5*u2^2 - 3*c3)*u1^2 + 2*μ*u1*u2 - c5*u2^4 - c3*u2^2 + r) * du1 +\n\t\t(-4*c5*u2*u1^3 + μ*u1^2 + (-4*c5*u2^3 - 2*c3*u2)*u1 + 3*u2^2*μ - ν) * du2\n\n\t\tf2[ii] = (-4*c5*u2*u1^3 - 3*μ*u1^2 + (-4*c5*u2^3 - 2*c3*u2)*u1 - u2^2*μ + ν) * du1 + (-c5*u1^4 + (-6*c5*u2^2 - c3)*u1^2 - 2*μ*u1*u2 - 5*c5*u2^4 - 3*c3*u2^2 + r) * du2\n\tend\n\n\treturn f\nend\n\n# inplace vector field\nfunction Fcgl!(f, u, p, t = 0.)\n\tNL!(f, u, p)\n\tmul!(f, p.Δ, u, 1., 1.)\nend\n\n# inplace derivative of the vector field\nfunction dFcgl!(f, x, p, dx)\n\tdNL!(f, x, p, dx)\n\tmul!(f, p.Δ, dx, 1., 1.)\nend","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We can now define an inplace functional","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"ls0 = GMRESIterativeSolvers(N = 2Nx*Ny, tol = 1e-9)#, Pl = lu(I + par_cgl.Δ))\npoTrapMFi = p -> PeriodicOrbitTrapProblem(\n\t(o, x) ->  Fcgl!(o, x, p),\n\t(o, x, dx) -> dFcgl!(o, x, p, dx),\n\treal.(vec_hopf),\n\thopfpt.u,\n\tM, ls0; isinplace = true)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"and run the newton method:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"outpo_f, _, flag = @time newton(poTrapMFi(@set par_cgl.r = r_hopf - 0.01),\n\torbitguess_f, (@set opt_po.linsolver = ls),\n\t:FullMatrixFree; normN = norminf)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"It gives\t","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     6.5509e-03         0\n        1                2     1.4311e-03         9\n        2                3     3.6948e-04         9\n        3                4     6.5156e-05        10\n        4                5     4.3270e-06        11\n        5                6     3.9205e-08        12\n        6                7     1.0685e-10        13\n        7                8     1.0592e-13        14\n  1.157987 seconds (23.44 k allocations: 154.468 MiB, 3.39% gc time)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Notice the small speed boost but the reduced allocations. At this stage, further improvements could target the use of BlockBandedMatrices.jl for the Laplacian operator, etc.","category":"page"},{"location":"tutorialsCGL/#Other-linear-formulation-1","page":"7/ Ginzburg-Landau 2d (GPU)","title":"Other linear formulation","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We could use another way to \"invert\" jacobian of the functional based on bordered technics. We try to use an ILU preconditioner on the cyclic matrix J_c (see Periodic orbits based on finite differences) which has a smaller memory footprint:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Jpo2 = poTrap(@set par_cgl.r = r_hopf - 0.1)(Val(:JacCyclicSparse), orbitguess_f)\nPrecilu = @time ilu(Jpo2, τ = 0.005)\nls2 = GMRESIterativeSolvers(verbose = false, tol = 1e-3, N = size(Jpo2,1), restart = 30, maxiter = 50, Pl = Precilu, log=true)\n\nopt_po = @set opt_newton.verbose = true\noutpo_f, hist, flag = @time newton(\n\tpoTrapMF(@set par_cgl.r = r_hopf - 0.1),\n\torbitguess_f, (@set opt_po.linsolver = ls2), :BorderedMatrixFree;\n\tnormN = norminf)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"but it gives:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     3.3281e-03         0\n        1                2     9.4520e-03        34\n        2                3     1.2632e-03        26\n        3                4     6.7022e-05        29\n        4                5     4.2398e-07        34\n        5                6     1.4380e-09        43\n        6                7     6.7513e-13        60\n  4.139557 seconds (143.13 k allocations: 1.007 GiB, 3.67% gc time)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Hence, it seems better to use the previous preconditioner.","category":"page"},{"location":"tutorialsCGL/#Continuation-of-periodic-solutions-1","page":"7/ Ginzburg-Landau 2d (GPU)","title":"Continuation of periodic solutions","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We can now perform continuation of the newly found periodic orbit and compute the Floquet multipliers using Matrix-Free methods.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"# set the eigensolver for the computation of the Floquet multipliers\nopt_po = @set opt_po.eigsolver = EigKrylovKit(tol = 1e-3, x₀ = rand(2n), verbose = 2, dim = 25)\n\n# parameters for the continuation\nopts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.02, ds = 0.001, pMax = 2.2, maxSteps = 250, plotEveryNsteps = 3, newtonOptions = (@set opt_po.linsolver = ls), \n\tnev = 5, precisionStability = 1e-7, detectBifurcation = 0)\n\nbr_po, _ , _= @time continuationPOTrap(\n\tp -> poTrapMF(@set par_cgl.r = p),\n\toutpo_f, r_hopf - 0.01,\n\topts_po_cont, :FullMatrixFree;\n\tverbosity = 2,\tplot = true,\n\tplotSolution = (x ;kwargs...) -> PALC.plotPeriodicPOTrap(x, M, Nx, Ny; ratio = 2, kwargs...),\n\tprintSolution = (u, p) -> PALC.amplitude(u, Nx*Ny, M; ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"This gives the following bifurcation diagram:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"tip: Improved performances\nAlthough it would be \"cheating\" for fair comparisons with existing packages, there is a trick to compute the bifurcation diagram without using preconditionners. We will not detail it here but it allows to handle the case Nx = 200; Ny = 110; M = 30 and above.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We did not change the preconditioner in the previous example as it does not seem needed. Let us show how to do this nevertheless:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"# callback which will be sent to newton. \n# `iteration` in the arguments refers to newton iterations\nfunction callbackPO(x, f, J, res, iteration, linsolver = ls, prob = poTrap, p = par_cgl; kwargs...)\n\t# we update the preconditioner every 10 continuation steps\n\tif mod(kwargs[:iterationC], 10) == 9 && iteration == 1\n\t\t@info \"update Preconditioner\"\n\t\tJpo = poTrap(@set p.r = kwargs[:p])(Val(:JacCyclicSparse), x)\n\t\tPrecilu = @time ilu(Jpo, τ = 0.003)\n\t\tls.Pl = Precilu\n\tend\n\ttrue\nend\n\nbr_po, _ , _= @time continuationPOTrap(\n\tp -> poTrapMF(@set par_cgl.r = p),\n\toutpo_f, r_hopf - 0.01,\n\topts_po_cont, :FullMatrixFree;\n\tverbosity = 2,\tplot = true,\n\tcallbackN = callbackPO,\n\tplotSolution = (x ;kwargs...) -> PALC.plotPeriodicPOTrap(x, M, Nx, Ny; ratio = 2, kwargs...),\n\tprintSolution = (u, p) -> PALC.amplitude(u, Nx*Ny, M; ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsCGL/#Continuation-of-Fold-of-periodic-orbits-1","page":"7/ Ginzburg-Landau 2d (GPU)","title":"Continuation of Fold of periodic orbits","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We continue the Fold point of the first branch of the previous bifurcation diagram in the parameter plane (r c_5). To this end, we need to be able to compute the Hessian of the periodic orbit functional. This is not yet readily available so we turn to automatic differentiation.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"using ForwardDiff\n\n# computation of the second derivative of a function f\nfunction d2Fcglpb(f, x, dx1, dx2)\n   return ForwardDiff.derivative(t2 -> ForwardDiff.derivative( t1-> f(x .+ t1 .* dx1 .+ t2 .* dx2,), 0.), 0.)\nend","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We select the Fold point from the branch br_po and redefine our linear solver to get the ILU preconditioner tuned close to the Fold point.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"indfold = 2\nfoldpt = FoldPoint(br_po, indfold)\n\nJpo = poTrap(@set par_cgl.r = r_hopf - 0.1)(Val(:JacFullSparse), orbitguess_f)\nPrecilu = @time ilu(Jpo, τ = 0.005)\nls = GMRESIterativeSolvers(verbose = false, tol = 1e-4, N = size(Jpo, 1), restart = 40, maxiter = 60, Pl = Precilu)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We can then use our functional to call newtonFold like for a regular function (see Tutorial 1)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"outfold, hist, flag = @time newtonFold(\n\t(x, p) -> poTrap(@set par_cgl.r = p)(x),\n\t(x, p) -> poTrap(@set par_cgl.r = p)(Val(:JacFullSparse), x),\n\t(x, p) -> transpose(poTrap(@set par_cgl.r = p)(Val(:JacFullSparse), x)),\n\t(x, p, dx1, dx2) -> d2Fcglpb(poTrap(@set par_cgl.r = p), x, dx1, dx2),\n\tbr_po, indfold, #index of the fold point\n\t@set opt_po.linsolver = ls)\nflag && printstyled(color=:red, \"--> We found a Fold Point at α = \", outfold.p,\" from \", br_po.foldpoint[indfold][3],\"\\n\")","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"and this gives","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     4.6366e-01         0\n        1                2     5.6561e-01        20\n        2                3     3.2592e-02        24\n        3                4     3.2054e-05        32\n        4                5     2.3656e-07        37\n        5                6     1.2573e-10        43\n        6                7     1.9629e-13        49\n 27.289005 seconds (1.07 M allocations: 24.444 GiB, 10.12% gc time)\n--> We found a Fold Point at α = 0.9470569704262517 from 0.9481896723164748","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Finally, one can perform continuation of the Fold bifurcation point as follows","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"optcontfold = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 40.1, pMin = -10., newtonOptions = (@set opt_po.linsolver = ls), maxSteps = 20)\n\noutfoldco, hist, flag = @time continuationFold(\n\t(x, r, c5) -> poTrap(setproperties(par_cgl, (r=r, c5=c5)))(x),\n\t(x, r, c5) -> poTrap(setproperties(par_cgl, (r=r, c5=c5)))(Val(:JacFullSparse), x),\n\t(x, r, c5) -> transpose(poTrap(setproperties(par_cgl, (r=r, c5=c5)))(Val(:JacFullSparse), x)),\n\tc5 -> ((x, r, dx1, dx2) -> d2Fcglpb(poTrap(setproperties(par_cgl, (r=r, c5=c5))), x, dx1, dx2)),\n\tbr_po, indfold,\n\tpar_cgl.c5, plot = true, verbosity = 2,\n\toptcontfold)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"which yields:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"There is still room for a lot of improvements here. Basically, the idea would be to use full Matrix-Free the jacobian functional and its transpose.","category":"page"},{"location":"tutorialsCGL/#Continuation-of-periodic-orbits-on-the-GPU-(Advanced)-1","page":"7/ Ginzburg-Landau 2d (GPU)","title":"Continuation of periodic orbits on the GPU (Advanced)","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"tip: \nThis is a very neat example all done on the GPU using the following ingredients: Matrix-Free computation of periodic orbits using preconditioners.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We now take advantage of the computing power of GPUs. The section is run on an NVIDIA Tesla V100. Given the small number of unknowns, we can (only) expect significant speedup in the application of the big preconditioner. ","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Note that we use the parameters Nx = 82; Ny = 42; M=30.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"# computation of the first derivative\nd1Fcgl(x, p, dx) = ForwardDiff.derivative(t -> Fcgl(x .+ t .* dx, p), 0.)\n\nd1NL(x, p, dx) = ForwardDiff.derivative(t -> NL(x .+ t .* dx, p), 0.)\n\nfunction dFcgl(x, p, dx)\n\tf = similar(dx)\n\tmul!(f, p.Δ, dx)\n\tnl = d1NL(x, p, dx)\n\tf .= f .+ nl\nend","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We first load CuArrays","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"using CuArrays\nCuArrays.allowscalar(false)\nimport LinearAlgebra: mul!, axpby!\nmul!(x::CuArray, y::CuArray, α::T) where {T <: Number} = (x .= α .* y)\nmul!(x::CuArray, α::T, y::CuArray) where {T <: Number} = (x .= α .* y)\naxpby!(a::T, X::CuArray, b::T, Y::CuArray) where {T <: Number} = (Y .= a .* X .+ b .* Y)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"and update the parameters","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"par_cgl_gpu = @set par_cgl.Δ = CuArrays.CUSPARSE.CuSparseMatrixCSC(par_cgl.Δ);","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Then, we precompute the preconditioner on the CPU:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Jpo = poTrap(@set par_cgl.r = r_hopf - 0.01)(Val(:JacFullSparse), orbitguess_f)\nPrecilu = @time ilu(Jpo, τ = 0.003)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"To invert Precilu on the GPU, we need to define a few functions which are not in CuArrays and which are related to LU decomposition:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"struct LUperso\n\tL\n\tUt\t# transpose of U in LU decomposition\nend\n\nimport Base: ldiv!\nfunction LinearAlgebra.ldiv!(_lu::LUperso, rhs::CuArrays.CuArray)\n\t_x = UpperTriangular(_lu.Ut) \\ (LowerTriangular(_lu.L) \\ rhs)\n\trhs .= vec(_x)\n\tCuArrays.unsafe_free!(_x)\n\trhs\nend","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Finally, for the methods in PeriodicOrbitTrapProblem to work, we need to redefine the following method. Indeed, we disable the use of scalar on the GPU to increase the speed.","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"import PseudoArcLengthContinuation: extractPeriodFDTrap\nextractPeriodFDTrap(x::CuArray) = x[end:end]","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"We can now define our functional:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"# matrix-free problem on the gpu\nls0gpu = GMRESKrylovKit(rtol = 1e-9)\npoTrapMFGPU = p -> PeriodicOrbitTrapProblem(\n\tx ->  Fcgl(x, p),\n\tx ->  (dx -> dFcgl(x, p, dx)),\n\tCuArray(real.(vec_hopf)),\n\tCuArray(hopfpt.u),\n\tM, ls0gpu;\n\tongpu = true) # this is required to alter the way the constraint is handled","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"Let us have a look at the linear solvers and compare the speed on CPU and GPU:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"ls = GMRESKrylovKit(verbose = 2, Pl = Precilu, rtol = 1e-3, dim  = 20)\n   # runs in \t2.990495 seconds (785 allocations: 31.564 MiB, 0.98% gc time)\n\touth, _, _ = @time ls((Jpo), orbitguess_f)\n\nPrecilu_gpu = LUperso(LowerTriangular(CuArrays.CUSPARSE.CuSparseMatrixCSR(I+Precilu.L)), UpperTriangular(CuArrays.CUSPARSE.CuSparseMatrixCSR(sparse(Precilu.U'))));\nlsgpu = GMRESKrylovKit(verbose = 2, Pl = Precilu_gpu, rtol = 1e-3, dim  = 20)\n\tJpo_gpu = CuArrays.CUSPARSE.CuSparseMatrixCSR(Jpo);\n\torbitguess_cu = CuArray(orbitguess_f)\n\t# runs in 1.751230 seconds (6.54 k allocations: 188.500 KiB, 0.43% gc time)\n\toutd, _, _ = @time lsgpu(Jpo_gpu, orbitguess_cu)","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"So we can expect a pretty descent x2 speed up in computing the periodic orbits. We can thus call newton:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"opt_po = @set opt_newton.verbose = true\n\toutpo_f, hist, flag = @time newton(\n\t\t\tpoTrapMFGPU(@set par_cgl_gpu.r = r_hopf - 0.01),\n\t\t\torbitguess_cu,\n\t\t\t(@set opt_po.linsolver = lsgpu), :FullMatrixFree;\n\t\t\tnormN = x->maximum(abs.(x))) ","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"The computing time is 6.914367 seconds (2.94 M allocations: 130.348 MiB, 1.10% gc time). The same computation on the CPU, runs in 13.972836 seconds (551.41 k allocations: 1.300 GiB, 1.05% gc time).","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"You can also perform continuation, here is a simple example:","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"opts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.02, ds= 0.001, pMax = 2.2, maxSteps = 250, plotEveryNsteps = 3, newtonOptions = (@set opt_po.linsolver = lsgpu))\nbr_po, upo , _= @time continuationPOTrap(\n   p -> poTrapMFGPU(@set par_cgl_gpu.r = p),\n   orbitguess_cu, r_hopf - 0.01,\n   opts_po_cont, :FullMatrixFree;\n   verbosity = 2,\n   printSolution = (u,p) -> amplitude(u, Nx*Ny, M), normC = x->maximum(abs.(x)))","category":"page"},{"location":"tutorialsCGL/#","page":"7/ Ginzburg-Landau 2d (GPU)","title":"7/ Ginzburg-Landau 2d (GPU)","text":"info: Preconditioner update\nFor now, the preconditioner has been precomputed on the CPU which forbids its (efficient) update during continuation of a branch of periodic orbits. This could be improved using ilu0! and friends in CuArrays.","category":"page"},{"location":"periodicOrbitShooting/#Periodic-orbits-based-on-the-shooting-method-1","page":"Periodic Orbits (Shooting)","title":"Periodic orbits based on the shooting method","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"A shooting algorithm is provided which is called either Simple Shooting (SS) if a single section is used and Multiple Shooting (MS) otherwise. ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"unknown: References\nFor the exposition, we follow the PhD thesis Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust, Kurt, 1997. ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"We aim at finding periodic orbits for the Cauchy problem ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"tag1 fracd xd t=f(x)","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"and we write phi^t(x_0) the associated flow (or semigroup of solutions).","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"tip: Tip about convenience functions\nFor convenience, we provide some functions plotPeriodicShooting for plotting, getAmplitude (resp. getMaximum) for getting the amplitude (resp. maximum) of the solution encoded by a shooting problem. See tutorials for example of use.","category":"page"},{"location":"periodicOrbitShooting/#Standard-Shooting-1","page":"Periodic Orbits (Shooting)","title":"Standard Shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/#Simple-shooting-1","page":"Periodic Orbits (Shooting)","title":"Simple shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"A periodic orbit is found when we have a couple (x T) such that phi^T(x) = x and the trajectory is non constant. Therefore, we want to solve the equations G(xT)=0 given by","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"tagSS\nbeginarraylphi^T(x)-x=0  s(xT)=0endarray","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"The section s(xT)=0 is a phase condition to remove the indeterminacy of the point on the limit cycle.","category":"page"},{"location":"periodicOrbitShooting/#Multiple-shooting-1","page":"Periodic Orbits (Shooting)","title":"Multiple shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"This case is similar to the previous one but more sections are used. To this end, we partition the unit interval with M+1 points 0=s_0s_1cdotss_m-1s_m=1 and consider the equations G(x_1cdotsx_MT)=0","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"beginaligned \nphi^delta s_1T(x_1)-x_2 =0  \nphi^delta s_2T(x_2)-x_3 =0   vdots  \nphi^delta s_m-1T(x_m-1)-x_m =0  \nphi^delta s_mT(x_m)-x_1 =0  s(x_1 x_2 cdots x_m T) =0 endaligned","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"where delta s_i=s_i+1-s_i. The Jacobian of the system of equations w.r.t. (xT) is given by ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"mathcalJ=left(beginarrayccmathcal J_c  partial_TG  star  dendarrayright)","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"where the cyclic matrix mathcal J_c is","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"mathcal J_c = \nleft(beginarrayccccc\nM_1  -I      \n  M_2  -I   \n    ddots  -I \n-I      M_m \nendarrayright)","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"and M_i=partial_xphi^delta s_i T(x_i).","category":"page"},{"location":"periodicOrbitShooting/#Encoding-of-the-functional-1","page":"Periodic Orbits (Shooting)","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"The functional is encoded in the composite type ShootingProblem. In particular, the user can pass its own time stepper or he can use the different ODE solvers in  DifferentialEquations.jl which makes it very easy to choose a solver tailored for the a specific problem. See the link ShootingProblem for more information, in particular on how to access the underlying functional, its jacobian...","category":"page"},{"location":"periodicOrbitShooting/#Poincaré-shooting-1","page":"Periodic Orbits (Shooting)","title":"Poincaré shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"The algorithm is based on the one described in Newton–Krylov Continuation of Periodic Orbits for Navier–Stokes Flows., Sánchez, J., M. Net, B. Garcı́a-Archilla, and C. Simó (2004) and Matrix-Free Continuation of Limit Cycles for Bifurcation Analysis of Large Thermoacoustic Systems. Waugh, Iain, Simon Illingworth, and Matthew Juniper (2013). ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"The idea is to look for periodic orbits solutions of (1) using hyperplanes Sigma_i for i=1cdotsM which intersect transversally an initial periodic orbit guess. We write Pi_i, the Poincaré return map on Sigma_i and look for solutions of the following problem:","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"beginaligned \nPi_1(x_1)-x_2 =0  \nPi_2(x_2)-x_3 =0   vdots  \nPi_m(x_m)-x_1 =0 \nendaligned","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"The main idea of the algorithm is to use the fact that the problem is (N-1)cdot M dimensional if x_iinmathbb R^N because each x_i lives in Sigma_i. Hence, one has to constrained the unknowns to these hyperplanes otherwise the Newton algorithm does not converge (well).","category":"page"},{"location":"periodicOrbitShooting/#Encoding-of-the-functional-2","page":"Periodic Orbits (Shooting)","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"The functional is encoded in the composite type PoincareShootingProblem. In particular, the user can pass its own time stepper or he can use the different ODE solvers in  DifferentialEquations.jl which makes it very easy to choose a tailored solver: the partial Poincaré return maps are implemented using callbacks. See the link PoincareShootingProblem for more information, in particular on how to access the underlying functional, its jacobian...","category":"page"},{"location":"periodicOrbitShooting/#Floquet-multipliers-computation-1","page":"Periodic Orbits (Shooting)","title":"Floquet multipliers computation","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"These are the eigenvalues of M_mcdots M_1.","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"Unlike the case with Finite differences, the matrices M_i are not sparse.","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"A not very precise algorithm for computing the Floquet multipliers is provided. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations of periodic orbits. It seems to work reasonably well for the tutorials considered here. For more information, have a look at FloquetQaDShooting.","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"note: Algorithm\nA more precise algorithm, based on the periodic Schur decomposition will be implemented in the future.","category":"page"},{"location":"periodicOrbitShooting/#Computation-with-newton-1","page":"Periodic Orbits (Shooting)","title":"Computation with newton","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"We provide a simplified call to newton to locate the periodic orbit. Have a look at the tutorial Continuation of periodic orbits (Standard Shooting) for a simple example on how to use the above methods. ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"The docs for this specific newton are located at Newton for Periodic Orbits.","category":"page"},{"location":"periodicOrbitShooting/#Computation-with-newton-and-deflation-1","page":"Periodic Orbits (Shooting)","title":"Computation with newton and deflation","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"We also provide a simplified call to newton to locate the periodic orbit with a deflation operator:","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"newton(prob::T, orbitguess, options::NewtonPar; kwargs...) where {T <: AbstractShootingProblem}","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"and","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"newton(prob::Tpb, orbitguess, options::NewtonPar, defOp::DeflationOperator{T, Tf, vectype}; kwargs...) where {Tpb <: AbstractShootingProblem, T, Tf, vectype}","category":"page"},{"location":"periodicOrbitShooting/#Continuation-1","page":"Periodic Orbits (Shooting)","title":"Continuation","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"Have a look at the Continuation of periodic orbits (Standard Shooting) example for the Brusselator.","category":"page"},{"location":"periodicOrbitShooting/#","page":"Periodic Orbits (Shooting)","title":"Periodic Orbits (Shooting)","text":"continuationPOShooting","category":"page"},{"location":"periodicOrbitShooting/#PseudoArcLengthContinuation.continuationPOShooting","page":"Periodic Orbits (Shooting)","title":"PseudoArcLengthContinuation.continuationPOShooting","text":"continuationPOShooting(prob, orbitguess, p0::Real, contParams::ContinuationPar; printPeriod = true, kwargs...)\n\nThis is the continuation routine for computing a periodic orbit using a functional G based on a Shooting method.\n\nArguments\n\np -> prob(p) is a function or family such that prob(p)::AbstractShootingProblem encodes the functional G\norbitguess a guess for the periodic orbit. For the type of orbitguess, please see the information concerning ShootingProblem and PoincareShootingProblem.\np0 initial parameter, must be a real number\ncontParams same as for the regular continuation method\nprintPeriod in the case of Poincaré Shooting, plot the period of the cycle.\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/#Fold-/-Hopf-Continuation-1","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"","category":"section"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"For this to work, it is important to have an analytical expression for the jacobian. See the tutorial Temperature model for more details.","category":"page"},{"location":"codim2Continuation/#The-case-of-the-Fold-point-1","page":"Fold / Hopf Continuation","title":"The case of the Fold point","text":"","category":"section"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"Once a Fold point has been detected after a call to br, _ = continuation(...), it can be refined using newton iterations. We have implemented a Minimally Augmented formulation. A simplified interface is provided.","category":"page"},{"location":"codim2Continuation/#Newton-refinement-1","page":"Fold / Hopf Continuation","title":"Newton refinement","text":"","category":"section"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"Let us say that ind_fold is the index in br.bifpoint of a Fold point. This guess can be refined by calling the following simplified interface. More precisions are provided below for an advanced usage.","category":"page"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"outfold, hist, flag = @time newtonFold(\n\t\t\t\t\t(x, p) ->   F(x, p),\n\t\t\t\t\t(x, p) -> Jac(x, p),\n\t\t\t\t\tbr, ind_fold,\n\t\t\t\t\topt_newton)","category":"page"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"It is important to note that for improved performances, a function implementing the expression of the hessian should be provided. This is by far the fastest. Reader interested in this advanced usage should look at the code example/chan.jl of the tutorial Temperature model. Although it is a simple problem, many different use case are shown in a simple setting. See also newtonFold.","category":"page"},{"location":"codim2Continuation/#The-case-of-the-Hopf-point-1","page":"Fold / Hopf Continuation","title":"The case of the Hopf point","text":"","category":"section"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"One a Hopf point have been detected after a call to br, _ = continuation(...), it can be refined using newton iterations. We have implemented a Minimally Augmented formulation. A simplified interface is provided as for the Fold case.","category":"page"},{"location":"codim2Continuation/#Newton-refinement-2","page":"Fold / Hopf Continuation","title":"Newton refinement","text":"","category":"section"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"Let us say that ind_hopf is the index in br.bifpoint of a Hopf point. This guess can be refined by calling the simplified interface. More precisions are provided below for an advanced usage. See also newtonHopf.","category":"page"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"outfold, hist, flag = @time newtonHopf(\n\t\t\t\t\t(x, p) ->   F(x, p),\n\t\t\t\t\t(x, p) -> Jac(x, p),\n\t\t\t\t\tbr, ind_hopf,\n\t\t\t\t\topt_newton)","category":"page"},{"location":"codim2Continuation/#Methods-1","page":"Fold / Hopf Continuation","title":"Methods","text":"","category":"section"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"newtonFold","category":"page"},{"location":"codim2Continuation/#PseudoArcLengthContinuation.newtonFold","page":"Fold / Hopf Continuation","title":"PseudoArcLengthContinuation.newtonFold","text":"This function turns an initial guess for a Fold point into a solution to the Fold problem based on a Minimally Augmented formulation. The arguments are as follows\n\nF   = (x, p) -> F(x, p) where p is the parameter associated to the Fold point\ndF  = (x, p) -> d_xF(x, p) associated jacobian\ndFt = (x, p) -> transpose(d_xF(x, p)) associated jacobian transpose, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method.\nd2F = (x, p, v1, v2) ->  d2F(x, p, v1, v2) a bilinear operator representing the hessian of F. It has to provide an expression for d2F(x,p)[v1,v2].\nfoldpointguess initial guess (x0, p0) for the Fold point. It should be a BorderedArray as given by the function FoldPoint\neigenvec guess for the 0 eigenvector\noptions::NewtonPar\n\n\n\n\n\nSimplified call to refine an initial guess for a Fold point. More precisely, the call is as follows\n\n`newtonFold(F, J, Jt, br::ContResult, index::Int64, options::NewtonPar)`\n\nor\n\n`newtonFold(F, J, Jt, d2F, br::ContResult, index::Int64, options::NewtonPar)`\n\nwhether the Hessian d2F is known analytically or not. The parameters / options are as usual except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine.\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"newtonHopf","category":"page"},{"location":"codim2Continuation/#PseudoArcLengthContinuation.newtonHopf","page":"Fold / Hopf Continuation","title":"PseudoArcLengthContinuation.newtonHopf","text":"This function turns an initial guess for a Hopf point into a solution to the Hopf problem based on a Minimally Augmented formulation. The arguments are as follows\n\nF  = (x, p) -> F(x, p) where p is the parameter associated to the Hopf point\nJ  = (x, p) -> d_xF(x, p) associated jacobian\nJt = (x, p) -> transpose(d_xF(x, p)) associated jacobian transpose\nd2F = (x, p, v1, v2) ->  d2F(x, p, v1, v2) a bilinear operator representing the hessian of F. It has to provide an expression for d2F(x,p)[v1, v2].\nhopfpointguess initial guess (x0, p0) for the Hopf point. It should a BorderedArray as given by the function HopfPoint.\neigenvec guess for the  iω eigenvector\neigenvec_ad guess for the -iω eigenvector\noptions::NewtonPar\n\n\n\n\n\ncall when hessian is unknown, finite differences are then used\n\n\n\n\n\nSimplified call to refine an initial guess for a Hopf point. More precisely, the call is as follows\n\n`newtonHopf(F, J, Jt, br::ContResult, index::Int64, options)`\n\nor\n\n`newtonHopf(F, J, Jt, d2F, br::ContResult, index::Int64, options)`\n\nwhen the Hessian d2F is known. The parameters are as usual except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine.\n\nwarning: Eigenvectors\nThis simplified call has been written when the eigenvectors are organised in a 2d Array evec where evec[:,2] is the second eigenvector in the list.\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"continuationFold","category":"page"},{"location":"codim2Continuation/#PseudoArcLengthContinuation.continuationFold","page":"Fold / Hopf Continuation","title":"PseudoArcLengthContinuation.continuationFold","text":"Codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows\n\nF = (x, p1, p2) ->\tF(x, p1, p2) where p is the parameter associated to the Fold point\nJ = (x, p1, p2) -> d_xF(x, p1, p2) associated jacobian\nJt = (x, p1, p2) -> transpose(d_xF(x, p1, p2)) associated jacobian transpose\nd2F = p2 -> ((x, p1, v1, v2) -> d2F(x, p1, p2, v1, v2)) this is the hessian of F computed at (x, p1, p2) and evaluated at (v1, v2).\nfoldpointguess initial guess (x0, p10) for the Fold point. It should be a BorderedArray as given by the function FoldPoint\np2 parameter p2 for which foldpointguess is a good guess\neigenvec guess for the 0 eigenvector at p1_0\noptions::NewtonPar\n\n\n\n\n\ncodim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows\n\nF = (x, p1, p2) -> F(x, p1, p2) where p is the parameter associated to the Fold point\nJ = (x, p1, p2) -> d_xF(x, p1, p2) associated jacobian\nfoldpointguess initial guess (x0, p10) for the Fold point. It should be a BorderedArray as given by the function FoldPoint\np2 parameter p2 for which foldpointguess is a good guess\neigenvec guess for the 0 eigenvector at p1_0\noptions::NewtonPar\n\nwarning: Hessian\nThe hessian of F in this case is computed with Finite differences. This can be slow for many variables, e.g. ~1e6\n\n\n\n\n\nSimplified call for continuation of Fold point. More precisely, the call is as follows continuationFold(F, J, Jt, d2F, br::ContResult, index::Int64, options) where the parameters are as for continuationFold except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine.\n\nSimplified calls are also provided but at the cost of using finite differences.\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation","title":"Fold / Hopf Continuation","text":"continuationHopf","category":"page"},{"location":"codim2Continuation/#PseudoArcLengthContinuation.continuationHopf","page":"Fold / Hopf Continuation","title":"PseudoArcLengthContinuation.continuationHopf","text":"codim 2 continuation of Hopf points. This function turns an initial guess for a Hopf point into a curve of Hopf points based on a Minimally Augmented formulation. The arguments are as follows\n\n(x, p1, p2)-> F(x, p1, p2) where p is the parameter associated to the hopf point\nJ = (x, p1, p2)-> d_xF(x, p1, p2) associated jacobian\nJt = (x, p1, p2) -> transpose(d_xF(x, p1, p2)) associated jacobian transpose\nd2F = p2 -> ((x, p1, v1, v2) -> d2F(x, p1, p2, v1, v2)) this is the hessian of F computed at (x, p1, p2) and evaluated at (v1, v2).\nhopfpointguess initial guess (x0, p10) for the Hopf point. It should be a Vector or a BorderedArray\np2 parameter p2 for which hopfpointguess is a good guess\neigenvec guess for the iω eigenvector at p1_0\neigenvec_ad guess for the -iω eigenvector at p1_0\noptions::NewtonPar\n\n\n\n\n\nSimplified call for continuation of Hopf point. More precisely, the call is as follows continuationHopf(F, J, Jt, d2F, br::ContResult, index::Int64, options) where the parameters are as for continuationHopf except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine.\n\nSimplified calls are also provided but at the cost of using finite differences.\n\nwarning: Eigenvectors\nThis simplified call has been written when the eigenvectors are organised in a 2d Array evec where evec[:,2] is the second eigenvector in the list.\n\n\n\n\n\n","category":"function"},{"location":"library/#Library-1","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#Structs-1","page":"Library","title":"Structs","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"NewtonPar","category":"page"},{"location":"library/#PseudoArcLengthContinuation.NewtonPar","page":"Library","title":"PseudoArcLengthContinuation.NewtonPar","text":"options = NewtonPar(tol = 1e-4,...)\n\nReturns a variable containing parameters to affect the newton algorithm when solving F(x) = 0.\n\nArguments (with default values):\n\ntol = 1e-10: absolute tolerance for F(x)\nmaxIter = 50: number of Newton iterations\nverbose = false: display Newton iterations?\nlinsolver = DefaultLS(): linear solver, must be <: AbstractLinearSolver\neigsolver = DefaultEig(): eigen solver, must be <: AbstractEigenSolver\n\nArguments only used in newtonPALC\n\nlinesearch = false: use line search algorithm\nalpha = 1.0: alpha (damping) parameter for line search algorithm\nalmin  = 0.001: minimal vslue of the damping alpha\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Setfield.jl to drastically simplify the mutation of different fields. See tutorials for more examples.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"ContinuationPar","category":"page"},{"location":"library/#PseudoArcLengthContinuation.ContinuationPar","page":"Library","title":"PseudoArcLengthContinuation.ContinuationPar","text":"options = ContinuationPar(dsmin = 1e-4,...)\n\nReturns a variable containing parameters to affect the continuation algorithm when solving F(x,p) = 0.\n\nArguments\n\ndsmin, dsmax are the minimum, maximum arclength allowed value. It controls the density of points in the computed branch of solutions.\nds is the initial arclength.\ntheta is a parameter in the arclength constraint. It is very important to tune it. See the docs of continuation.\npMin, pMax allowed parameter range for p\nmaxSteps maximum number of continuation steps\nnewtonOptions::NewtonPar: options for the Newton algorithm\nsaveToFile = false: save to file. A name is automatically generated.\nsaveSolEveryNsteps::Int64 = 0 at which continuation steps do we save the current solution`\nplotEveryNsteps = 3\n\nHandling eigen elements\n\ncomputeEigenValues = false compute eigenvalues / eigenvectors\nnev = 3 number of eigenvalues to be computed. It is automatically increased to have at least nev unstable eigenvalues. To be set for proper  bifurcation detection. See Detection of bifurcation points for more informations.\nsaveEigEveryNsteps = 1\trecord eigen vectors every specified steps. Important for memory limited ressource, e.g. GPU.\nsaveEigenvectors\t= true\tImportant for memory limited ressource, e.g. GPU.\n\nHandling bifurcation detection\n\nprecisionStability = 1e-10 lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits\ndetectFold = true detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)\ndetectBifurcation::Int ∈ {0, 1, 2} detect bifurcations? If set to 0, bifurcation are not detected. If set to 1, bifurcation are detected along the continuation run, but not located precisely. If set to 2, a bisection algorithm is used to locate the bifurcations (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory in memory limited devices (e.g. on GPU)\ndsminBisection dsmin for the bisection algorithm when locating bifurcation points\nnInversion number of sign inversions in bisection algorithm\nmaxBisectionSteps maximum number of bisection steps\n\nHandling ds adaptation (see continuation for more information)\n\na  = 0.5 aggressiveness factor. It is used to adapt ds in order to have a number of newton iteration per continuation step roughly the same. The higher a is, the larger the step size ds is changed at each continuation step.\nthetaMin = 1.0e-3 minimum value of theta\ndoArcLengthScaling trigger further adaptation of theta\n\nMisc\n\nfinDiffEps::T  = 1e-9 ε used in finite differences computations\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Setfield.jl to drastically simplify the mutation of different fields. See tutorials for more examples.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"ContResult","category":"page"},{"location":"library/#PseudoArcLengthContinuation.ContResult","page":"Library","title":"PseudoArcLengthContinuation.ContResult","text":"ContResult{T, Eigentype, Vectype, Biftype}\n\nStructure which holds the results after a call to continuation.\n\nArguments\n\nbranch::VectorOfArray holds the low-dimensional information about the branch. More precisely, branch[:,i] contains the following information (param, printSolution(u, param), Newton iterations, ds, i) for each continuation step i.\nn_unstable::Vector{Int64} a vector holding the number of eigenvalues with positive real part for each continuation step\t(to detect stationary bifurcation)\nn_imag::Vector{Int64} a vector holding the number of eigenvalues with positive real part and non zero imaginary part for each continuation step (to detect Hopf bifurcation)\nstability::Vector{Bool} a vector holding the stability of the computed solution for each continuation step\nbifpoint::Vector{Biftype} a vector holding the set of bifurcation points detected during the computation of the branch. Each entry of the vector contains a tuple (type, idx, param = T(0.), norm, printsol, u, tau, ind_bif, step, status) where step is the continuation step at which the bifurcation occurs, ind_bif is the eigenvalue index responsible for the bifurcation (if applicable) and idx is the index in eig (see above) for which the bifurcation occurs.\nfoldpoint::Vector{Biftype} a vector holding the set of fold points detected during the computation of the branch.\neig::Vector contains for each continuation step the eigen elements.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"DeflationOperator","category":"page"},{"location":"library/#PseudoArcLengthContinuation.DeflationOperator","page":"Library","title":"PseudoArcLengthContinuation.DeflationOperator","text":"DeflationOperator. It is used to describe the following situation. Assume you want to solve F(x)=0 with a Newton algorithm but you want to avoid the process to return some already known solutions roots_i. You can use DeflationOperator to define a function M(u) used to find, with Newton iterations, the zeros of the following function F(u)  Π_i(dot(u - roots_i u - roots_i)^p + shift) = F(u)  M(u). The fields of the struct DeflationOperator are as follows:\n\npower p\ndot function, this function has to be bilinear and symmetric for the linear solver\nshift\nroots\n\nThe deflation operator is is M(u) = frac1prod_i=1^n_roots(shift + norm(u-roots_i)^p) where nrm(u) = dot(uu).\n\nGiven defOp::DeflationOperator, one can access its roots as defOp[n] as a shortcut for defOp.roots[n]. Also, one can add (resp.remove) a new root by using push!(defOp, newroot) (resp. pop!(defOp)). Finally length(defOp) is a shortcut for length(defOp.roots)\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"DeflatedProblem","category":"page"},{"location":"library/#PseudoArcLengthContinuation.DeflatedProblem","page":"Library","title":"PseudoArcLengthContinuation.DeflatedProblem","text":"pb = DeflatedProblem(F, J, M::DeflationOperator)\n\nThis creates a problem encoded a deflated problem M(u) cdot F(u) = 0 where M is a DeflationOperator which encodes the penalization term. J is the jacobian of J. Can be used to call newton and continuation.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"PeriodicOrbitTrapProblem","category":"page"},{"location":"library/#PseudoArcLengthContinuation.PeriodicOrbitTrapProblem","page":"Library","title":"PseudoArcLengthContinuation.PeriodicOrbitTrapProblem","text":"pb = PeriodicOrbitTrapProblem(F, J, ϕ, xπ, M::Int)\n\nThis composite type implements Finite Differences based on a Trapezoidal rule to locate periodic orbits. The arguments are as follows\n\nF vector field\nJ jacobian of F\nd2F = nothing Hessian of F (optional), useful for continuation of Fold of periodic orbits\nϕ used to set a section for the phase constraint equation\nxπ used in the section for the phase constraint equation\nM::Int number of time slices\nlinsolver: = DefaultLS() linear solver for each time slice, i.e. to solve J⋅sol = rhs. This is only used for the computation of the Floquet multipliers.\nisinplace::Bool whether F and J are inplace functions (Experimental). In this case, the functions F and J must have the following definitions (o, x) ->  F(o, x) and (o, x, dx) -> J(o, x, dx).\nongpu::Bool whether the computation takes place on the gpu (Experimental)\n\nYou can then call pb(orbitguess) to compute the functional on a orbitguess. Note that orbitguess must be of size M * N + 1 where N is the number of unknowns in the state space and orbitguess[M*N+1] is an estimate of the period of the limit cycle.\n\nThe scheme is as follows, one look for T = x[end] and\n\nleft(x_i - x_i-1right) - frach2 left(F(x_i) + F(x_i-1)right) = 0 i=1cdotsm-1\n\nwith u_{0} = u_{m-1} and the periodicity condition u_{m} - u_{1} = 0 and\n\nwhere h = T/M. Finally, the phase of the periodic orbit is constrained by using a section\n\nlangle x1 - x_pi phirangle=0\n\nA functional, hereby called G, encodes this problem. The following methods are available\n\npb(orbitguess) evaluates the functional G on orbitguess\npb(orbitguess, du) evaluates the jacobian dG(orbitguess).du functional at orbitguess on du\npb(Val(:JacFullSparse), orbitguess) return the sparse matrix of the jacobian dG(orbitguess) at orbitguess without the constraints. It is called A_γ in the docs.\npb(Val(:JacCyclicSparse), orbitguess) return the sparse cyclic matrix Jc (see the docs) of the jacobian dG(orbitguess) at orbitguess\npb(Val(:BlockDiagSparse), orbitguess) return the diagonal of the sparse matrix of the jacobian dG(orbitguess) at orbitguess. This allows to design Jacobi preconditioner. Use blockdiag.\n\nnote: GPU call\nFor these methods to work on the GPU, for example with CuArrays in mode allowscalar(false), we face the issue that the function extractPeriodFDTrap won't be well defined because it is a scalar operation. One may have to redefine it like extractPeriodFDTrap(x::CuArray) = x[end:end] or something else. Also, note that you must pass the option ongpu = true for the functional to be evaluated efficiently on the gpu.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"Flow","category":"page"},{"location":"library/#PseudoArcLengthContinuation.Flow","page":"Library","title":"PseudoArcLengthContinuation.Flow","text":"fl = Flow(F, flow, dflow)\n\nThis composite type encapsulates:\n\nthe vector field x -> F(x) associated to a Cauchy problem,\nthe flow (or semigroup) associated to the Cauchy problem (x, t) -> flow(x, t). Only the last time point must be returned.\nthe flow (or semigroup) associated to the Cauchy problem (x, t) -> flow(x, t). The whole solution on the time interval (0,t) must be returned. This is not strictly necessary to provide this.\nthe differential dflow of the flow w.r.t. x, (x, dx, t) -> dflow(x, dx, t). One important thing is that we require dflow(x, dx, t) to return 2 vectors: the first is flow(x, t) and the second is the value of the derivative of the flow as the second vector.\n\nThere are some simple constructors for which you only have to pass a prob::ODEProblem from DifferentialEquations.jl and an ODE time stepper like Tsit5(). Hence, you can do for example\n\nfl = Flow(F, prob, Tsit5(); kwargs...)\n\nIf your vector field depends on parameters p, you can define a Flow using\n\nfl = Flow(F, p, prob, Tsit5(); kwargs...)\n\nFinally, you can pass two ODEProblem where the second one is used to compute the variational equation:\n\nfl = Flow(F, p, prob1::ODEProblem, alg1, prob2::ODEProblem, alg2; kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"ShootingProblem","category":"page"},{"location":"library/#PseudoArcLengthContinuation.ShootingProblem","page":"Library","title":"PseudoArcLengthContinuation.ShootingProblem","text":"pb = ShootingProblem(flow::Flow, ds, section)\n\nThis composite type implements the Standard Simple / Multiple Standard Shooting  method to locate periodic orbits. The arguments are as follows\n\nflow::Flow: implements the flow of the Cauchy problem though the structure Flow.\nds: vector of time differences for each shooting. Its length is written M. If M==1, then the simple shooting is implemented and the multiple one otherwise.\nsection: implements a phase condition. The evaluation section(x) must return a scalar number where x is a guess for the periodic orbit. Note that the period T of the guess x is always included either as the last component of T = x[end] or as T = x.p. The type of x depends on what is passed to the newton solver.\n\nYou can then call pb(orbitguess) to apply the functional to a guess. Note that orbitguess must be of size M * N + 1 where N is the number of unknowns of the state space and orbitguess[M * N + 1] is an estimate of the period T of the limit cycle. This form of guess is convenient for the use of the linear solvers in IterativeSolvers.jl (for example) which accepts only AbstractVectors. Another accepted guess is of the form BorderedArray(guess, T) where guess[i] is the state of the orbit at the ith time slice. This last form allows for non-vector state space which can be convenient for 2d problems for example.\n\nA functional, hereby called G, encodes the shooting problem. For example, the following methods are available:\n\npb(orbitguess) evaluates the functional G on orbitguess\npb(orbitguess, du) evaluates the jacobian dG(orbitguess).du functional at orbitguess on du\n\nSimplified constructors\n\nA simpler way to build a functional is to use\n\npb = ShootingProblem(F, p, prob::ODEProblem, alg, M::Int, section; kwargs...)\n\nor\n\npb = ShootingProblem(F, p, prob::ODEProblem, alg, ds, section; kwargs...)\n\nwhere F is the vector field, p is a parameter (to be passed to the vector field and the flow), prob is an ODEProblem which is used to create a flow using the ODE solver alg (for example Tsit5()). Finally, the arguments kwargs are passed to the ODE solver defining the flow. Look at DifferentialEquations.jl for more information. Note that, in this case, the derivative of the flow is computed internally using Finite Differences.\n\nThe other way is an elaboration of the previous one\n\npb = ShootingProblem(F, p, prob1::ODEProblem, alg1, prob2::ODEProblem, alg2, M::Int, section; kwargs...)\n\nor\n\npb = ShootingProblem(F, p, prob1::ODEProblem, alg1, prob2::ODEProblem, alg2, ds, section; kwargs...)\n\nwhere we supply now two ODEProblem. The first one prob1, is used to define the flow associated to F while the second one is a problem associated to the derivative of the flow. Hence, prob2 should implement the following vector field tilde F(xphi) = (F(x)dF(x)cdotphi).\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"PoincareShootingProblem","category":"page"},{"location":"library/#PseudoArcLengthContinuation.PoincareShootingProblem","page":"Library","title":"PseudoArcLengthContinuation.PoincareShootingProblem","text":"pb = PoincareShootingProblem(flow::Flow, M, section)\n\nThis composite type implements the Poincaré Shooting method to locate periodic orbits, basically using Poincaré return maps. The arguments are as follows\n\nflow::Flow: implements the flow of the Cauchy problem though the structure Flow.\nM: the number of return maps. If M==1, then the simple shooting is implemented and the multiple one otherwise.\nsection: implements a Poincaré section condition. The evaluation section(x) must return a scalar number where x is a guess for the periodic orbit when M=1. Otherwise, one must implement a function section(out, x) which populates out with the M hyperplanes.\n\nSimplified constructors\n\nA simpler way is to create a functional is pb = PoincareShootingProblem(F, p, prob::ODEProblem, alg, section; kwargs...) for simple shooting or pb = PoincareShootingProblem(F, p, prob::ODEProblem, alg, M::Int, section; kwargs...) for multiple shooting . Here F is the vector field, p is a parameter (to be passed to the vector and the flow), prob is an ODEProblem which is used to create a flow using the ODE solver alg (for example Tsit5()). Finally, the arguments kwargs are passed to the ODE solver defining the flow. Look at DifferentialEquations.jl for more information.\n\nAnother convenient call is pb = PoincareShootingProblem(F, p, prob::ODEProblem, alg, normals::AbstractVector, centers::AbstractVector; kwargs...) where normals (resp. centers) is a list of normals (resp. centers) which define a list of hyperplanes Sigma_i. These hyperplanes are used to define partial Poincaré return maps. See docs for more information.\n\nComputing the functionals\n\nYou can then call pb(orbitguess) to apply the functional to a guess. Note that orbitguess must be of size M * N where N is the number of unknowns in the state space and M is the number of Poincaré maps. Another accepted guess is such that guess[i] is the state of the orbit on the ith section. This last form allows for non-vector state space which can be convenient for 2d problems for example.\n\nA functional, hereby called G encodes this shooting problem. For example, the following methods are available:\n\npb(orbitguess) evaluates the functional G on orbitguess\npb(orbitguess, du) evaluates the jacobian dG(orbitguess).du functional at orbitguess on du\n\ntip: Tip\nYou can use the function getPeriod(pb::PoincareShootingProblem, sol) to get the period of the solution sol\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"FloquetQaDTrap","category":"page"},{"location":"library/#PseudoArcLengthContinuation.FloquetQaDTrap","page":"Library","title":"PseudoArcLengthContinuation.FloquetQaDTrap","text":"floquet = FloquetQaDTrap(eigsolver::AbstractEigenSolver)\n\nThis composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems based on Finite Differences (Trapeze method), also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations. The arguments are as follows:\n\neigsolver::AbstractEigenSolver solver used to compute the eigenvalues.\n\nIf eigsolver == DefaultEig(), then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.\n\ndanger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver eigsolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of eigsolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"FloquetQaDShooting","category":"page"},{"location":"library/#PseudoArcLengthContinuation.FloquetQaDShooting","page":"Library","title":"PseudoArcLengthContinuation.FloquetQaDShooting","text":"floquet = FloquetQaDShooting(eigsolver::AbstractEigenSolver)\n\nThis composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems based on the Shooting method, also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations. The arguments are as follows:\n\neigsolver::AbstractEigenSolver solver used to compute the eigenvalues.\n\nIf eigsolver == DefaultEig(), then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.\n\ndanger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver eigsolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of eigsolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.\n\n\n\n\n\n","category":"type"},{"location":"library/#Newton-1","page":"Library","title":"Newton","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"newton","category":"page"},{"location":"library/#PseudoArcLengthContinuation.newton","page":"Library","title":"PseudoArcLengthContinuation.newton","text":"\tnewton(F, J, x0, options::NewtonPar; normN = norm, callback = (x, f, J, res, iteration, optionsN; kwargs...) -> true, kwargs...)\n\nThis is the Newton Solver for F(x) = 0 with Jacobian J and initial guess x0. The function normN allows to specify a norm for the convergence criteria. It is important to set the linear solver options.linsolver properly depending on your problem. This linear solver is used to solve J(x)u = -F(x) in the Newton step. You can for example use linsolver = Default() which is the operator backslash: it works well for Sparse / Dense matrices. See Linear solvers for more informations.\n\nArguments:\n\nx -> F(x) functional whose zeros are looked for. In particular, it is not inplace,\ndF(x) = x -> J(x) compute the jacobian of F at x. It is then passed to options.linsolver. The Jacobian J(x) can be a matrix or an out-of-place function.\nx0 initial guess\noptions variable holding the internal parameters used by the newton method\ncallback function passed by the user which is called at the end of each iteration. Can be used to update a preconditionner for example. The optionsN will be options passed in order to change the linear / eigen solvers\nkwargs arguments passed to the callback. Useful when newton is called from continuation\n\nSimplified calls are provided, for example when J is not passed. It is then computed with finite differences.\n\nOutput:\n\nsolution:\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\nfunction newton(Fhandle, Jhandle, x0::vectype, options:: NewtonPar{T}, defOp::DeflationOperator{T, Tf, vectype}; kwargs...) where {T, Tf, vectype}\n\nThis is the deflated version of the Newton Solver for F(x) = 0 with Jacobian J. It penalises the roots saved in defOp.roots. The other arguments are as for newton. See DeflationOperator for more informations.\n\nSimplified calls are provided, for example when J is not passed. It then computed with finite differences.\n\nOutput:\n\nsolution:\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\nnewton(prob::T, orbitguess, options::NewtonPar; kwargs...) where {T <: AbstractShootingProblem}\n\nThis is the Newton Solver for computing a periodic orbit using Shooting method.\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\nnewton(prob::T, orbitguess, options::NewtonPar, defOp::DeflationOperator; kwargs...) where {T <: AbstractShootingProblem}\n\nThis is the deflated Newton Solver for computing a periodic orbit using Shooting method.\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\nnewton(prob::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, linearPO = :BorderedLU; kwargs...)\n\nThis is the Newton Solver for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.\n\nArguments:\n\nprob a problem of type PeriodicOrbitTrapProblem encoding the functional G\norbitguess a guess for the periodic orbit where orbitguess[end] is an estimate of the period of the orbit. It should be a vector of size N * M + 1 where M is the number of time slices, N is the dimension of the phase space. This must be compatible with the numbers N,M in prob.\noptions same as for the regular newton method\nlinearPO = :BorderedLU. Specify the choice of the linear algorithm, which must belong to [:FullLU, :BorderedLU, :FullMatrixFree, :BorderedMatrixFree]. This is used to select a way of inverting the jacobian dG of the functional G. For :FullLU, we use the default linear solver on a sparse matrix representation of dG. For :BorderedLU, we take advantage of the bordered shape of the linear solver and use LU decomposition to invert dG using a bordered linear solver. This is the default algorithm. For :FullMatrixFree, a matrix free linear solver is used for dG: note that a preconditioner is very likely required here because of the cyclic shape of dG which affects the convergence properties of GMRES. Finally, for :BorderedMatrixFree, a matrix free linear solver is used but for Jc only (see docs): it means that options.linsolver is used to invert Jc. These two Matrix-Free options thus expose different part of the jacobian dG in order to use specific preconditioners. For example, an ILU preconditioner on Jc could remove the constraints in dG and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\nnewton(probPO::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, defOp::DeflationOperator{T, Tf, vectype}, linearPO = :BorderedLU; kwargs...) where {T, Tf, vectype}\n\nThis function is similar to newton(probPO, orbitguess, options, linearPO; kwargs...) except that it uses deflation in order to find periodic orbits different from the one in defOp. For example, it can be used in the vicinity of a Hopf bifurcation to prevent the Newton algorithm from converging to the equilibrium point.\n\n\n\n\n\n","category":"function"},{"location":"library/#Newton-with-deflation-1","page":"Library","title":"Newton with deflation","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"newton(Fhandle, Jhandle, x0::vectype, options:: NewtonPar{T}, defOp::DeflationOperator{T, Tf, vectype}; kwargs...) where {T, Tf, vectype}","category":"page"},{"location":"library/#PseudoArcLengthContinuation.newton-Union{Tuple{vectype}, Tuple{Tf}, Tuple{T}, Tuple{Any,Any,vectype,NewtonPar{T,L,E} where E<:AbstractEigenSolver where L<:PseudoArcLengthContinuation.AbstractLinearSolver,DeflationOperator{T,Tf,vectype}}} where vectype where Tf where T","page":"Library","title":"PseudoArcLengthContinuation.newton","text":"function newton(Fhandle, Jhandle, x0::vectype, options:: NewtonPar{T}, defOp::DeflationOperator{T, Tf, vectype}; kwargs...) where {T, Tf, vectype}\n\nThis is the deflated version of the Newton Solver for F(x) = 0 with Jacobian J. It penalises the roots saved in defOp.roots. The other arguments are as for newton. See DeflationOperator for more informations.\n\nSimplified calls are provided, for example when J is not passed. It then computed with finite differences.\n\nOutput:\n\nsolution:\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\n","category":"method"},{"location":"library/#Newton-for-Fold-/-Hopf-1","page":"Library","title":"Newton for Fold / Hopf","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"newtonFold(F, J, Jt, d2F, foldpointguess::BorderedArray{vectype, T}, eigenvec, options::NewtonPar; normN = norm, d2F_is_known = true ) where {T,vectype}","category":"page"},{"location":"library/#PseudoArcLengthContinuation.newtonFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,Any,Any,BorderedArray{vectype,T},Any,NewtonPar}} where vectype where T","page":"Library","title":"PseudoArcLengthContinuation.newtonFold","text":"This function turns an initial guess for a Fold point into a solution to the Fold problem based on a Minimally Augmented formulation. The arguments are as follows\n\nF   = (x, p) -> F(x, p) where p is the parameter associated to the Fold point\ndF  = (x, p) -> d_xF(x, p) associated jacobian\ndFt = (x, p) -> transpose(d_xF(x, p)) associated jacobian transpose, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method.\nd2F = (x, p, v1, v2) ->  d2F(x, p, v1, v2) a bilinear operator representing the hessian of F. It has to provide an expression for d2F(x,p)[v1,v2].\nfoldpointguess initial guess (x0, p0) for the Fold point. It should be a BorderedArray as given by the function FoldPoint\neigenvec guess for the 0 eigenvector\noptions::NewtonPar\n\n\n\n\n\n","category":"method"},{"location":"library/#","page":"Library","title":"Library","text":"newtonFold(F, J, Jt, d2F, br::ContResult, ind_fold::Int64, options::NewtonPar;kwargs...)","category":"page"},{"location":"library/#PseudoArcLengthContinuation.newtonFold-Tuple{Any,Any,Any,Any,ContResult,Int64,NewtonPar}","page":"Library","title":"PseudoArcLengthContinuation.newtonFold","text":"Simplified call to refine an initial guess for a Fold point. More precisely, the call is as follows\n\n`newtonFold(F, J, Jt, br::ContResult, index::Int64, options::NewtonPar)`\n\nor\n\n`newtonFold(F, J, Jt, d2F, br::ContResult, index::Int64, options::NewtonPar)`\n\nwhether the Hessian d2F is known analytically or not. The parameters / options are as usual except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine.\n\n\n\n\n\n","category":"method"},{"location":"library/#Newton-for-Periodic-Orbits-1","page":"Library","title":"Newton for Periodic Orbits","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"newton(probPO::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, linearalgo::Symbol = :BorderedLU; kwargs...)","category":"page"},{"location":"library/#PseudoArcLengthContinuation.newton","page":"Library","title":"PseudoArcLengthContinuation.newton","text":"newton(prob::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, linearPO = :BorderedLU; kwargs...)\n\nThis is the Newton Solver for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.\n\nArguments:\n\nprob a problem of type PeriodicOrbitTrapProblem encoding the functional G\norbitguess a guess for the periodic orbit where orbitguess[end] is an estimate of the period of the orbit. It should be a vector of size N * M + 1 where M is the number of time slices, N is the dimension of the phase space. This must be compatible with the numbers N,M in prob.\noptions same as for the regular newton method\nlinearPO = :BorderedLU. Specify the choice of the linear algorithm, which must belong to [:FullLU, :BorderedLU, :FullMatrixFree, :BorderedMatrixFree]. This is used to select a way of inverting the jacobian dG of the functional G. For :FullLU, we use the default linear solver on a sparse matrix representation of dG. For :BorderedLU, we take advantage of the bordered shape of the linear solver and use LU decomposition to invert dG using a bordered linear solver. This is the default algorithm. For :FullMatrixFree, a matrix free linear solver is used for dG: note that a preconditioner is very likely required here because of the cyclic shape of dG which affects the convergence properties of GMRES. Finally, for :BorderedMatrixFree, a matrix free linear solver is used but for Jc only (see docs): it means that options.linsolver is used to invert Jc. These two Matrix-Free options thus expose different part of the jacobian dG in order to use specific preconditioners. For example, an ILU preconditioner on Jc could remove the constraints in dG and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"newton(prob::T, orbitguess, options::NewtonPar; kwargs...) where {T <: AbstractShootingProblem}","category":"page"},{"location":"library/#PseudoArcLengthContinuation.newton-Union{Tuple{T}, Tuple{T,Any,NewtonPar}} where T<:AbstractShootingProblem","page":"Library","title":"PseudoArcLengthContinuation.newton","text":"newton(prob::T, orbitguess, options::NewtonPar; kwargs...) where {T <: AbstractShootingProblem}\n\nThis is the Newton Solver for computing a periodic orbit using Shooting method.\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\n","category":"method"},{"location":"library/#Continuation-1","page":"Library","title":"Continuation","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"continuation","category":"page"},{"location":"library/#PseudoArcLengthContinuation.continuation","page":"Library","title":"PseudoArcLengthContinuation.continuation","text":"continuation(F, J, x0, p0::Real, contParams::ContinuationPar; plot = false, normC = norm, dotPALC = (x,y) -> dot(x,y) / length(x), printSolution = norm, plotSolution = (x; kwargs...)->nothing, finaliseSolution = (z, tau, step, contResult) -> true, callbackN = (x, f, J, res, iteration, options; kwargs...) -> true, linearAlgo = BorderingBLS(), tangentAlgo = SecantPred(), verbosity = 0)\n\nCompute the continuation curve associated to the functional F and its jacobian J.\n\nArguments:\n\nF = (x, p) -> F(x, p) where p is the parameter for the continuation\nJ = (x, p) -> d_xF(x, p) its associated jacobian. It can be a matrix, a function or a callable struct.\nu0 initial guess\np0 initial parameter, must be a real number\ncontParams parameters for continuatio. See ContinuationPar for more information about the options\nplot = false whether to plot the solution while computing\nprintSolution = (x, p) -> norm(x) function used to plot in the continuation curve. It is also used in the way results are saved. It could be norm or x -> x[1]. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...).\nplotSolution = (x; kwargs...) -> nothing function implementing the plot of the solution.\nfinaliseSolution = (z, tau, step, contResult) -> true Function called at the end of each continuation step. Can be used to alter the continuation procedure (stop it by returning false), saving personal data, plotting... The notations are z=(xp), tau is the tangent at z (see below), step is the index of the current continuation step and ContResult is the current branch. Note that you can have a better control over the continuation procedure by using an iterator, see Iterator Interface.\ncallbackN callback for newton iterations. see docs for newton. Can be used to change preconditioners\ntangentAlgo = SecantPred() controls the algorithm use to predict the tangent along the curve of solutions or the corrector. Can be NaturalPred, SecantPred or BorderedPred.\nlinearAlgo = BorderingBLS(). Must belong to [MatrixBLS(), BorderingBLS(), MatrixFreeBLS()]. Used to control the way the extended linear system associated to the continuation problem is solved.\nverbosity ∈ {0,1,2,3} controls the amount of information printed during the continuation process.\nnormC = norm norm used in the different Newton solves\ndotPALC = (x,y) -> dot(x,y) / length(x), dot product used in the definition of the dot product (norm) (u p)^2_theta in the constraint N(xp) (see below). This option can be used to remove the factor 1/length(x) for example in problems where the dimension of the state space changes (mesh adaptation, ...)\nfilename name of a file to save the computed branch during continuation. The identifier .jld2 will be appended to this filename\n\nOutputs:\n\ncontres::ContResult composite type which contains the computed branch. See ContResult for more information.\nu::BorderedArray the last solution computed on the branch\n\ntip: Controlling the parameter `linearAlgo`\nIn this simplified interface to continuation, the argument linearAlgo is internally overwritten to provide a valid argument to the algorithm. If you do not want this to happen, call directly continuation(F, J, x0, p0, contParams, linearAlgo; kwrags...).\n\nMethod\n\nBordered system of equations\n\nThe pseudo-arclength continuation method solves the equation F(x p) = 0 (of dimension N) together with the pseudo-arclength constraint N(x p) = fracthetalength(x) langle x - x_0 tau_0rangle + (1 - theta)cdot(p - p_0)cdot dp_0 - ds = 0. In practice, the curve gamma is parametrised by s so that gamma(s) = (x(s) p(s)) is a curve of solutions to F(x p). This formulation allows to pass turning points (where the implicit theorem fails). In the previous formula, (x_0 p_0) is a solution for a given s_0, (tau_0 dp_0) is the tangent to the curve at s_0. Hence, to compute the curve of solutions, we need solve an equation of dimension N+1 which is called a Bordered system.\n\nwarning: Parameter `theta`\nThe parameter theta in the struct ContinuationParis very important. It should be tuned for the continuation to work properly especially in the case of large problems where the langle x - x_0 tau_0rangle component in the constraint might be favoured too much.\n\nThe parameter ds is adjusted internally depending on the number of Newton iterations and other factors. See the function stepSizeControl for more information. An important parameter to adjust the magnitude of this adaptation is the parameter a in the struct ContinuationPar.\n\nAlgorithm\n\nThe algorithm works as follows:\n\nStart from a known solution (x_0 p_0tau_0 dp_0)\nPredictor set (x_1 p_1) = (x_0 p_0) + dscdot (tau_0 dp_0)\nCorrector solve F(x p)=0 N(x p)=0 with a (Bordered) Newton Solver with guess (x_1 p_1).\nif Newton in 3. did not converge, put ds/2 ⟶ ds and go to 1.\nNew tangent Compute (tau_1 dp_1), set (x_0 p_0 tau_0 dp_0) = (x_1 p_1 tau_1 dp_1) and return to step 2\n\nNatural continuation\n\nWe speak of natural continuation when we do not consider the constraint N(x p)=0. Knowing (x_0 p_0), we use x_0 as a guess for solving F(x p_1)=0 with p_1 close to p_0. Again, this fails at Turning points but it can be faster to compute than the constrained case. This is set by the option tangentAlgo = NaturalPred() in continuation.\n\nTangent computation (step 4)\n\nThere are various ways to compute (tau_1 p_1). The first one is called secant and is parametrised by the option tangentAlgo = SecantPred(). It is computed by (tau_1 p_1) = (z_1 p_1) - (z_0 p_0) and normalised by the norm (u p)^2_theta = fracthetalength(u) langle uurangle + (1 - theta)cdot p^2. Another method is to compute (tau_1 p_1) by solving solving the bordered linear system beginbmatrix F_x  F_p\t  fracthetalength(x)tau_0  (1-theta)p_0endbmatrixbeginbmatrixtau_1   p_1endbmatrix =beginbmatrix0  1endbmatrix ; it is set by the option tangentAlgo = BorderedPred().\n\nBordered linear solver\n\nWhen solving the Bordered system F(x p) = 0 N(x p)=0, one faces the issue of solving the Bordered linear system beginbmatrix J  a\t b^T  cendbmatrixbeginbmatrixX   yendbmatrix =beginbmatrixR  nendbmatrix. This can be solved in many ways via bordering (which requires two Jacobian inverses), by forming the bordered matrix (which works well for sparse matrices) or by using a full Matrix Free formulation. The choice of method is set by the argument linearAlgo. Have a look at the struct linearBorderedSolver for more information.\n\nLinear Algebra\n\nLet us discuss here more about the norm and dot product. First, the option normC gives a norm that is used to evaluate the residual in the following way: max(normC(F(xp)) N(xp))tol. It is thus used as a stopping criterion for a Newton algorithm. The dot product (resp. norm) used in N and in the (iterative) linear solvers is LinearAlgebra.dot (resp. LinearAlgebra.norm). It can be changed by importing these functions and redefining it. Not that by default, the L^2 norm is used. These details are important because of the constraint N which incorporates the factor length. For some custom composite type implementing a Vector space, the dot product could already incorporates the length factor in which case you should either redefine the dot product or change theta.\n\nStep size control\n\nAs explained above, each time the corrector phased failed, the step size ds is halved. This has the disavantage of having lost Newton iterations (which costs time) and impose small steps (which can be slow as well). To prevent this, the step size is controlled internally with the idea of having a constant number of Newton iterations per point. This is in part controlled by the aggressiveness factor a in ContinuationPar. Further tuning is performed by using doArcLengthScaling=true in ContinuationPar. This adjusts internally theta so that the relative contributions of x and p are balanced in the constraint N.\n\n\n\n\n\n","category":"function"},{"location":"library/#Continuation-for-Fold-/-Hopf-1","page":"Library","title":"Continuation for Fold / Hopf","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"continuationFold(F, J, Jt, d2F, foldpointguess::BorderedArray{vectype, T}, p2_0::T, eigenvec, options_cont::ContinuationPar ; d2F_is_known = true, kwargs...) where {T,vectype}","category":"page"},{"location":"library/#PseudoArcLengthContinuation.continuationFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,Any,Any,BorderedArray{vectype,T},T,Any,ContinuationPar}} where vectype where T","page":"Library","title":"PseudoArcLengthContinuation.continuationFold","text":"Codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows\n\nF = (x, p1, p2) ->\tF(x, p1, p2) where p is the parameter associated to the Fold point\nJ = (x, p1, p2) -> d_xF(x, p1, p2) associated jacobian\nJt = (x, p1, p2) -> transpose(d_xF(x, p1, p2)) associated jacobian transpose\nd2F = p2 -> ((x, p1, v1, v2) -> d2F(x, p1, p2, v1, v2)) this is the hessian of F computed at (x, p1, p2) and evaluated at (v1, v2).\nfoldpointguess initial guess (x0, p10) for the Fold point. It should be a BorderedArray as given by the function FoldPoint\np2 parameter p2 for which foldpointguess is a good guess\neigenvec guess for the 0 eigenvector at p1_0\noptions::NewtonPar\n\n\n\n\n\n","category":"method"},{"location":"library/#","page":"Library","title":"Library","text":"continuationFold(F, J, Jt, foldpointguess::BorderedArray{vectype, T}, p2_0::T, eigenvec, options_cont::ContinuationPar ;kwargs...) where {T,vectype}","category":"page"},{"location":"library/#PseudoArcLengthContinuation.continuationFold-Union{Tuple{vectype}, Tuple{T}, Tuple{Any,Any,Any,BorderedArray{vectype,T},T,Any,ContinuationPar}} where vectype where T","page":"Library","title":"PseudoArcLengthContinuation.continuationFold","text":"codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows\n\nF = (x, p1, p2) -> F(x, p1, p2) where p is the parameter associated to the Fold point\nJ = (x, p1, p2) -> d_xF(x, p1, p2) associated jacobian\nfoldpointguess initial guess (x0, p10) for the Fold point. It should be a BorderedArray as given by the function FoldPoint\np2 parameter p2 for which foldpointguess is a good guess\neigenvec guess for the 0 eigenvector at p1_0\noptions::NewtonPar\n\nwarning: Hessian\nThe hessian of F in this case is computed with Finite differences. This can be slow for many variables, e.g. ~1e6\n\n\n\n\n\n","category":"method"},{"location":"library/#","page":"Library","title":"Library","text":"continuationFold(F, J, Jt, d2F, br::ContResult, ind_fold::Int64, p2_0::Real, options_cont::ContinuationPar ; kwargs...)","category":"page"},{"location":"library/#PseudoArcLengthContinuation.continuationFold-Tuple{Any,Any,Any,Any,ContResult,Int64,Real,ContinuationPar}","page":"Library","title":"PseudoArcLengthContinuation.continuationFold","text":"Simplified call for continuation of Fold point. More precisely, the call is as follows continuationFold(F, J, Jt, d2F, br::ContResult, index::Int64, options) where the parameters are as for continuationFold except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine.\n\nSimplified calls are also provided but at the cost of using finite differences.\n\n\n\n\n\n","category":"method"},{"location":"library/#","page":"Library","title":"Library","text":"continuationHopf(F, J, Jt, d2F, hopfpointguess::BorderedArray{vectype, Tb}, p2_0::T, eigenvec, eigenvec_ad, options_cont::ContinuationPar ; kwargs...) where {T,Tb,vectype}","category":"page"},{"location":"library/#PseudoArcLengthContinuation.continuationHopf-Union{Tuple{vectype}, Tuple{Tb}, Tuple{T}, Tuple{Any,Any,Any,Any,BorderedArray{vectype,Tb},T,Any,Any,ContinuationPar}} where vectype where Tb where T","page":"Library","title":"PseudoArcLengthContinuation.continuationHopf","text":"codim 2 continuation of Hopf points. This function turns an initial guess for a Hopf point into a curve of Hopf points based on a Minimally Augmented formulation. The arguments are as follows\n\n(x, p1, p2)-> F(x, p1, p2) where p is the parameter associated to the hopf point\nJ = (x, p1, p2)-> d_xF(x, p1, p2) associated jacobian\nJt = (x, p1, p2) -> transpose(d_xF(x, p1, p2)) associated jacobian transpose\nd2F = p2 -> ((x, p1, v1, v2) -> d2F(x, p1, p2, v1, v2)) this is the hessian of F computed at (x, p1, p2) and evaluated at (v1, v2).\nhopfpointguess initial guess (x0, p10) for the Hopf point. It should be a Vector or a BorderedArray\np2 parameter p2 for which hopfpointguess is a good guess\neigenvec guess for the iω eigenvector at p1_0\neigenvec_ad guess for the -iω eigenvector at p1_0\noptions::NewtonPar\n\n\n\n\n\n","category":"method"},{"location":"library/#Continuation-for-periodic-orbits-1","page":"Library","title":"Continuation for periodic orbits","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"continuationPOTrap(probPO, orbitguess, p0::Real, contParams::ContinuationPar, linearalgo = :BorderedLU; printSolution = (u,p) -> u[end], kwargs...)","category":"page"},{"location":"library/#PseudoArcLengthContinuation.continuationPOTrap","page":"Library","title":"PseudoArcLengthContinuation.continuationPOTrap","text":"continuationPOTrap(prob, orbitguess, p0::Real, contParams::ContinuationPar, linearPO = :BorderedLU; printSolution = (u,p) -> u[end], kwargs...)\n\nThis is the continuation routine for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.\n\nArguments\n\np -> prob(p) is a family such that prob(p)::PeriodicOrbitTrapProblem encodes the functional G\norbitguess a guess for the periodic orbit where orbitguess[end] is an estimate of the period of the orbit. It could be a vector of size N * M + 1 where M is the number of time slices, N is the dimension of the phase space. This must be compatible with the numbers N, M in prob.\np0 initial parameter, must be a real number\ncontParams same as for the regular continuation method\nlinearPO = :BorderedLU. Same as newton when applied to PeriodicOrbitTrapProblem.\n\nNote that by default, the methods prints the period of the periodic orbit as function of the parameter. This can be changed by providing your printSolution argument.\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"continuationPOShooting(prob, orbitguess, p0::Real, contParams::ContinuationPar; printPeriod = true, kwargs...)","category":"page"},{"location":"library/#PseudoArcLengthContinuation.continuationPOShooting-Tuple{Any,Any,Real,ContinuationPar}","page":"Library","title":"PseudoArcLengthContinuation.continuationPOShooting","text":"continuationPOShooting(prob, orbitguess, p0::Real, contParams::ContinuationPar; printPeriod = true, kwargs...)\n\nThis is the continuation routine for computing a periodic orbit using a functional G based on a Shooting method.\n\nArguments\n\np -> prob(p) is a function or family such that prob(p)::AbstractShootingProblem encodes the functional G\norbitguess a guess for the periodic orbit. For the type of orbitguess, please see the information concerning ShootingProblem and PoincareShootingProblem.\np0 initial parameter, must be a real number\ncontParams same as for the regular continuation method\nprintPeriod in the case of Poincaré Shooting, plot the period of the cycle.\n\n\n\n\n\n","category":"method"},{"location":"library/#Plotting-1","page":"Library","title":"Plotting","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"plotBranch(contres::ContResult; kwargs...)","category":"page"},{"location":"library/#PseudoArcLengthContinuation.plotBranch-Tuple{ContResult}","page":"Library","title":"PseudoArcLengthContinuation.plotBranch","text":"plotBranch(contres::ContResult, plot_fold = true; kwargs...)\n\nPlot the branch of solutions from a ContResult. You can also pass parameters like plotBranch(br, marker = :dot). For the continuation diagram, the legend is as follows (:fold => :black, :hopf => :red, :bp => :blue, :nd => :magenta, :none => :yellow)\n\n\n\n\n\n","category":"method"},{"location":"library/#","page":"Library","title":"Library","text":"plotBranch!(contres::ContResult; kwargs...)","category":"page"},{"location":"library/#PseudoArcLengthContinuation.plotBranch!-Tuple{ContResult}","page":"Library","title":"PseudoArcLengthContinuation.plotBranch!","text":"plotBranch!(contres, plot_fold = true; putbifptlegend = true, filterbifpoints::Bool = false, kwargs...)\n\nAppend to the current plot, the plot of the branch of solutions from a ContResult. You can also pass parameters like plotBranch!(br, marker = :dot). Options to filter the bifurcation points (which are mostly guesses) are provided. For example, filterbifpoints = true merges the nearby Fold and Branch points.\n\n\n\n\n\n","category":"method"},{"location":"library/#","page":"Library","title":"Library","text":"plotBranch(brs::Vector; kwargs...)","category":"page"},{"location":"library/#PseudoArcLengthContinuation.plotBranch-Tuple{Array{T,1} where T}","page":"Library","title":"PseudoArcLengthContinuation.plotBranch","text":"plotBranch(contres::ContResult, plot_fold = true; kwargs...)\n\nPlot the branch of solutions from a ContResult. You can also pass parameters like plotBranch(br, marker = :dot). For the continuation diagram, the legend is as follows (:fold => :black, :hopf => :red, :bp => :blue, :nd => :magenta, :none => :yellow)\n\n\n\n\n\nplotBranch(brs::Vector, plot_fold = true; putbifptlegend = true, filterbifpoints = false, kwargs...)\n\nPlot all the branches contained in brs in a single figure. Convenient when many bifurcation diagram have been computed.\n\n\n\n\n\n","category":"method"},{"location":"tutorials1b/#Temperature-model-with-ApproxFun-1","page":"2/ Temperature model with Spectral Collocation","title":"Temperature model with ApproxFun","text":"","category":"section"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"We reconsider the first example by relying on spectral collocations using the package ApproxFun.jl which allows very precise function approximation. ","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"This is one example where the state space, the space of solutions to the nonlinear equation, is not a subtype of AbstractArray. See Requested methods for Custom State for more informations.","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"We start with some imports:","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"using ApproxFun, LinearAlgebra, Parameters\n\nusing PseudoArcLengthContinuation, Plots\nconst PALC = PseudoArcLengthContinuation","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"We then need to add some methods not available in ApproxFun because the state space is not a subtype of AbstractArray:","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"# specific methods for ApproxFun\nimport Base: eltype, similar, copyto!, length\nimport LinearAlgebra: mul!, rmul!, axpy!, axpby!, dot, norm\n\nsimilar(x::ApproxFun.Fun, T) = (copy(x))\nsimilar(x::ApproxFun.Fun) = copy(x)\nmul!(w::ApproxFun.Fun, v::ApproxFun.Fun, α) = (w .= α * v)\n\neltype(x::ApproxFun.Fun) = eltype(x.coefficients)\nlength(x::ApproxFun.Fun) = length(x.coefficients)\n\ndot(x::ApproxFun.Fun, y::ApproxFun.Fun) = sum(x * y)\n\naxpy!(a::Float64, x::ApproxFun.Fun, y::ApproxFun.Fun) = (y .= a * x + y)\naxpby!(a::Float64, x::ApproxFun.Fun, b::Float64, y::ApproxFun.Fun) = (y .= a * x + b * y)\nrmul!(y::ApproxFun.Fun, b::Float64) = (y.coefficients .*= b; y)\nrmul!(y::ApproxFun.Fun, b::Bool) = b == true ? y : (y.coefficients .*= 0; y)\n\ncopyto!(x::ApproxFun.Fun, y::ApproxFun.Fun) = ( (x.coefficients = copy(y.coefficients);x))","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"We can easily write our functional with boundary conditions in a convenient manner using ApproxFun:","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"N(x; a = 0.5, b = 0.01) = 1 + (x + a*x^2)/(1 + b*x^2)\ndN(x; a = 0.5, b = 0.01) = (1-b*x^2+2*a*x)/(1+b*x^2)^2\n\nfunction F_chan(u, alpha::Float64, beta = 0.01)\n\treturn [Fun(u(0.), domain(u)) - beta,\n\t\tFun(u(1.), domain(u)) - beta,\n\t\tΔ * u + alpha * N(u, b = beta)]\nend\n\nfunction Jac_chan(u, alpha, beta = 0.01)\n\treturn [Evaluation(u.space, 0.),\n\t\tEvaluation(u.space, 1.),\n\t\tΔ + alpha * dN(u, b = beta)]\nend","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"We want to call a Newton solver. We first need an initial guess and the Laplacian operator:","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"sol = Fun(x -> x * (1-x), Interval(0.0, 1.0))\nconst Δ = Derivative(sol.space, 2)","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"Finally, we need to provide some parameters for the Newton iterations. This is done by calling","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"optnewton = NewtonPar(tol = 1e-12, verbose = true)","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"We call the Newton solver:","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"out, _, _ = @time PALC.newton(\n\t\t\tx -> F_chan(x, 3.0),\n\t\t\tu -> Jac_chan(u, 3.0),\n\t\t\tsol, optnewton, normN = x -> norm(x, Inf64))","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"and you should see","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     1.5707e+00         0\n        1                2     1.1546e-01         1\n        2                3     8.0149e-04         1\n        3                4     3.9038e-08         1\n        4                5     7.9049e-13         1\n  0.086784 seconds (354.58 k allocations: 14.264 MiB)","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"We can also perform numerical continuation with respect to the parameter alpha. Again, we need to provide some parameters for the continuation:","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"optcont = ContinuationPar(dsmin = 0.0001, dsmax = 0.05, ds= 0.005, pMax = 4.1, plotEveryNsteps = 10, newtonOptions = NewtonPar(tol = 1e-8, maxIter = 20, verbose = true), maxSteps = 200)","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"We provide a callback function to check how the ApproxFun solution vector grows during the continuation:","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"function finalise_solution(z, tau, step, contResult)\n\tprintstyled(color=:red,\"--> AF length = \", (z, tau) .|> length ,\"\\n\")\n\ttrue\nend","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"Then, we can call the continuation routine","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"br, _ = @time continuation(\n\t\t(x, p) ->   F_chan(x, p),\n\t\t(x, p) -> Jac_chan(x, p),\n\t\tout, 3.0, optcont,\n\t\tplot = true,\n\t\tplotSolution = (x; kwargs...) -> plot!(x; label = \"l = $(length(x))\", kwargs...),\n\t\tverbosity = 2,\n\t\tnormC = x -> norm(x, Inf64))","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"and you should see","category":"page"},{"location":"tutorials1b/#","page":"2/ Temperature model with Spectral Collocation","title":"2/ Temperature model with Spectral Collocation","text":"(Image: )","category":"page"},{"location":"tutorials2/#Snaking-in-the-2d-Swift-Hohenberg-equation-1","page":"3/ Swift-Hohenberg","title":"Snaking in the 2d Swift-Hohenberg equation","text":"","category":"section"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"We study the following PDE","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"-(I+Delta)^2 u+lcdot u +nu u^2-u^3 = 0","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"with Neumann boundary conditions. This full example is in the file example/SH2d-fronts.jl. This example is also treated in the MATLAB package pde2path. We use a Sparse Matrix to express the operator L_1=(I+Delta)^2","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"using DiffEqOperators, Setfield, Parameters\nusing PseudoArcLengthContinuation, LinearAlgebra, Plots, SparseArrays\nconst PALC = PseudoArcLengthContinuation\n\n# helper function to plot solution\nheatmapsol(x) = heatmap(reshape(x,Nx,Ny)',color=:viridis)\n\nNx = 151\nNy = 100\nlx = 4*2pi\nly = 2*2pi/sqrt(3)\n\n# we use DiffEqOperators to compute the Laplacian operator\nfunction Laplacian2D(Nx, Ny, lx, ly)\n\thx = 2lx/Nx\n\thy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\tQx = Neumann0BC(hx)\n\tQy = Neumann0BC(hy)\n\t\n\tA = kron(sparse(I, Ny, Ny), sparse(D2x * Qx)[1]) + kron(sparse(D2y * Qy)[1], sparse(I, Nx, Nx))\n\treturn A, D2x\nend","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"We also write the functional and its Jacobian which is a Sparse Matrix","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"function F_sh(u, p)\n\t@unpack l, ν, L1 = p\n\treturn -L1 * u .+ (l .* u .+ ν .* u.^2 .- u.^3)\nend\n\nfunction dF_sh(u, p)\n\t@unpack l, ν, L1 = p\n\treturn -L1 .+ spdiagm(0 => l .+ 2 .* ν .* u .- 3 .* u.^2)\nend","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"We first look for hexagonal patterns. This is done with","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"X = -lx .+ 2lx/(Nx) * collect(0:Nx-1)\nY = -ly .+ 2ly/(Ny) * collect(0:Ny-1)\n\n# initial guess for hexagons\nsol0 = [(cos(x) + cos(x/2) * cos(sqrt(3) * y/2) ) for x in X, y in Y]\n\tsol0 .= sol0 .- minimum(vec(sol0))\n\tsol0 ./= maximum(vec(sol0))\n\tsol0 = sol0 .- 0.25\n\tsol0 .*= 1.7\n\theatmap(sol0',color=:viridis)\n\n# define parameters for the PDE\nΔ, D2x = Laplacian2D(Nx, Ny, lx, ly, :Neumann)\nL1 = (I + Δ)^2\npar = (l = -0.1, ν = 1.3, L1 = L1)\n\n# newton corrections of the initial guess\noptnewton = NewtonPar(verbose = true, tol = 1e-8, maxIter = 20)\n\tsol_hexa, _, _ = @time newton(\n\t\tx ->  F_sh(x, par),\n\t\tu -> dF_sh(u, par),\n\t\tvec(sol0),\n\t\toptnewton)\n\tprintln(\"--> norm(sol) = \",norm(sol_hexa,Inf64))\n\theatmapsol(sol_hexa)","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"which produces the results","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     1.7391e+02         0\n        1                2     5.0465e+03         1\n        2                3     1.4878e+03         1\n        3                4     4.3529e+02         1\n        4                5     1.2560e+02         1\n        5                6     3.5512e+01         1\n        6                7     9.5447e+00         1\n        7                8     2.1763e+00         1\n        8                9     3.3503e-01         1\n        9               10     7.7259e-02         1\n       10               11     7.4767e-03         1\n       11               12     7.9505e-05         1\n       12               13     8.8395e-09         1\n  1.442878 seconds (43.22 k allocations: 664.210 MiB, 1.45% gc time)","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"with sol_hexa being","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"(Image: )","category":"page"},{"location":"tutorials2/#Continuation-and-bifurcation-points-1","page":"3/ Swift-Hohenberg","title":"Continuation and bifurcation points","text":"","category":"section"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"We can now continue this solution as follows. We want to detect bifurcations along the branches. We thus need an eigensolver. However, if we use an iterative eigensolver, like eig = EigArpack(), it has trouble computing the eigenvalues. One can see that using ","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"# compute the jacobian\nJ0 = dF_sh(sol_hexa, par)\n\n# compute 10 eigenvalues\neig(J0, 10)","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"The reason is that the jacobian operator is not very well conditioned unlike its inverse. We thus opt for the shift-invert method (see Eigen solvers for more information) with shift 0.1:","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"EigArpack(0.1, :LM)","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"If we want to compute the bifurcation points along the branches, we have to tell the solver by setting detectBifurcation = 1. However, this won't be very precise and each bifurcation point will be located at best at the step size precision. We can use bisection to locate this points more precisely using the option detectBifurcation = 2 (see Detection of bifurcation points for more information).","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"We are now ready to compute the branches:","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"optcont = ContinuationPar(dsmin = 0.0001, dsmax = 0.005, ds= -0.001, pMax = 0.00, pMin = -1.0,\n\tnewtonOptions = setproperties(optnew; tol = 1e-9, maxIter = 15), maxSteps = 125,\n\tdetectBifurcation = 2, nev = 40, detectFold = false, \n\tdsminBisection =1e-7, saveSolEveryNsteps = 4)\n\toptcont = @set optcont.newtonOptions.eigsolver = EigArpack(0.1, :LM)\n\n\tbr, u1 = @time PALC.continuation(\n\t\t(x, p) ->  F_sh(x, @set par.l = p),\n\t\t(x, p) -> dF_sh(x, @set par.l = p),\n\t\tsol_hexa, -0.1, optcont;\n\t\tplot = true, verbosity = 3,\n\t\ttangentAlgo = BorderedPred(),\n\t\tplotSolution = (x; kwargs...) -> (heatmap!(X, Y, reshape(x, Nx, Ny)'; color=:viridis, label=\"\", kwargs...);ylims!(-1,1,subplot=4);xlims!(-.5,.3,subplot=4)),\n\t\tprintSolution = (x, p) -> norm(x),\n\t\tnormC = x -> norm(x, Inf))","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"Note that we can get some information about the branch as follows. The [converged] indicates if the bisection routine was successful, otherwise it shows [guess]. Finally δ = ( 2,  0) says that the bifurcation point has been detected by 2 new eigenvalues with zero real part among which zero have non zero imaginary part. A Hopf bifurcation point would thus have δ = ( 2,  2) or δ = ( -2,  2).","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"julia> br\nBranch number of points: 43\nBifurcation points:\n-   1,      bp point around p ≈ -0.21554685, step =  21, idx =  22, ind_bif =   1 [converged], δ = ( 1,  0)\n-   2,      bp point around p ≈ -0.21504230, step =  22, idx =  23, ind_bif =   3 [converged], δ = ( 2,  0)\n-   3,      bp point around p ≈ -0.21095557, step =  24, idx =  25, ind_bif =   5 [converged], δ = ( 2,  0)\n-   4,      bp point around p ≈ -0.21001596, step =  25, idx =  26, ind_bif =   6 [converged], δ = ( 1,  0)\n-   5,      bp point around p ≈ -0.20684791, step =  26, idx =  27, ind_bif =   8 [converged], δ = ( 2,  0)\n-   6,      bp point around p ≈ -0.19986385, step =  28, idx =  29, ind_bif =   9 [converged], δ = ( 1,  0)\n-   7,      bp point around p ≈ -0.18895070, step =  30, idx =  31, ind_bif =  10 [converged], δ = ( 1,  0)\n-   8,      bp point around p ≈ -0.18103775, step =  32, idx =  33, ind_bif =  11 [converged], δ = ( 1,  0)\n-   9,      bp point around p ≈ -0.13841646, step =  37, idx =  38, ind_bif =  10 [converged], δ = (-2,  0)\n-  10,      bp point around p ≈ -0.11180884, step =  40, idx =  41, ind_bif =   9 [converged], δ = (-1,  0)","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"We get the following plot during computation:","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"tip: Tip\nWe don't need to call newton first in order to use continuation.","category":"page"},{"location":"tutorials2/#Snaking-computed-with-deflation-1","page":"3/ Swift-Hohenberg","title":"Snaking computed with deflation","text":"","category":"section"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"We know that there is snaking near the left fold. Let us look for other solutions like fronts. The problem is that if the guess is not precise enough, the newton iterations will converge to the solution with hexagons sol_hexa. We appeal to the technique initiated by P. Farrell and use a deflated problem (see DeflationOperator and DeflatedProblem for more information). More precisely, we apply the newton iterations to the following functional uto fracF_sh(u)Pi_i=1^n_s u-sol_hexai^p + sigma which penalizes sol_hexa.","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"# this define the above penalizing factor with p=2, sigma=1, norm associated to dot\n# and the set of sol_{hexa} is of length ns=1\ndeflationOp = DeflationOperator(2.0,(x,y) -> dot(x,y),1.0,[sol_hexa])\noptnewton = @set optnewton.maxIter = 250\noutdef, _, flag, _ = @time newton(\n\t\t\t\tx ->  F_sh(x, par),\n\t\t\t\tx -> dF_sh(x, par),\n\t\t\t\t0.2vec(sol_hexa) .* vec([exp.(-(x+lx)^2/25) for x in X, y in Y]),\n\t\t\t\toptnewton,deflationOp, normN = x -> norm(x,Inf64))\n\t\theatmapsol(outdef) |> display\n\t\tflag && push!(deflationOp, outdef)","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"which gives:","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"Note that push!(deflationOp, outdef) deflates the newly found solution so that by repeating the process we find another one:","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"outdef, _, flag, _ = @time newton(\n\t\t\t\tx ->  F_sh(x, par),\n\t\t\t\tx -> dF_sh(x, par),\n\t\t\t\t0.2vec(sol_hexa) .* vec([exp.(-(x)^2/25) for x in X, y in Y]),\n\t\t\t\toptnewton,deflationOp, normN = x -> norm(x,Inf64))\n\t\theatmapsol(outdef) |> display\n\t\tflag && push!(deflationOp, outdef)","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"Again, repeating this from random guesses, we find several more solutions, like for example","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"We can now continue the solutions located in deflationOp.roots","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"br, _ = @time continuation(\n\t(x, p) ->  F_sh(x, @set par.l = p),\n\t(x, p) -> dF_sh(x, @set par.l = p),,\n\tdeflationOp[2], -0.1, optcont;\n\tplot = true, \n\tplotSolution = (x; kwargs...) -> (heatmap!(X,Y,reshape(x,Nx,Ny)'; color=:viridis, label=\"\", kwargs...)))","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"and using plotBranch(br), we obtain:","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"3/ Swift-Hohenberg","title":"3/ Swift-Hohenberg","text":"Note that the plot provides the stability of solutions and bifurcation points. Interested readers should consult the associated file example/SH2d-fronts.jl in the example folder.","category":"page"},{"location":"tutorials2b/#The-Swift-Hohenberg-equation-on-the-GPU-1","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"The Swift-Hohenberg equation on the GPU","text":"","category":"section"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"Here we give an example where the continuation can be done entirely on the GPU, e.g. on a single Tesla K80.","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"We choose the 2d Swift-Hohenberg as an example and consider a larger grid. See Snaking in the 2d Swift-Hohenberg equation for more details. Solving the sparse linear problem in v","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"-(I+Delta)^2 v+(l +2nu u-3u^2)v = rhs","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"with a direct solver becomes prohibitive. Looking for an iterative method, the conditioning of the jacobian is not good enough to have fast convergence, mainly because of the Laplacian operator. However, the above problem is equivalent to:","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"-v + L cdot (d cdot v) = Lcdot rhs","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"where","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"L = ((I+Delta)^2 + I)^-1","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"is very well conditioned and","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"d = l+1+2nu v-3v^2","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"Hence, to solve the previous equation, only a few GMRES iterations are required.","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"In effect, the preconditioned PDE is an example of nonlocal problem.","category":"page"},{"location":"tutorials2b/#Computing-the-inverse-of-the-differential-operator-1","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"Computing the inverse of the differential operator","text":"","category":"section"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"The issue now is to compute L but this is easy using Fourier transforms.","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"Hence, that's why we slightly modify the previous Example by considering periodic boundary conditions. Let us now show how to compute L. Although the code looks quite technical, it is based on two facts. First, the Fourier transform symbol associated to L is","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"l_1 = 1+(1-k_x^2-k_y^2)^2","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"which is pre-computed in the composite type SHLinearOp. Then, the effect of L on u is as simple as real.(ifft( l1 .* fft(u) )) and the inverse L\\u is real.(ifft( fft(u) ./ l1 )). However, in order to save memory on the GPU, we use inplace FFTs to reduce temporaries which explains the following code.","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"using Revise\nusing AbstractFFTs, FFTW, KrylovKit, Setfield, Parameters\nusing PseudoArcLengthContinuation, LinearAlgebra, Plots\nconst PALC = PseudoArcLengthContinuation\n\n# the following struct encodes the operator L1\n# Making the linear operator a subtype of PALC.AbstractLinearSolver is handy as it will be used\n# in the Newton iterations.\nstruct SHLinearOp{Treal, Tcomp, Tl1, Tplan, Tiplan} <: PALC.AbstractLinearSolver\n\ttmp_real::Treal         # temporary\n\ttmp_complex::Tcomp      # temporary\n\tl1::Tl1\n\tfftplan::Tplan\n\tifftplan::Tiplan\nend\n\n# this is a constructor for the above struct\nfunction SHLinearOp(Nx, lx, Ny, ly; AF = Array{TY})\n\t# AF is a type, it could be CuArray{TY} to run the following on GPU\n\tk1 = vcat(collect(0:Nx/2), collect(Nx/2+1:Nx-1) .- Nx)\n\tk2 = vcat(collect(0:Ny/2), collect(Ny/2+1:Ny-1) .- Ny)\n\td2 = [(1-(pi/lx * kx)^2 - (pi/ly * ky)^2)^2 + 1. for kx in k1, ky in k2]\n\ttmpc = Complex.(AF(zeros(Nx, Ny)))\n\treturn SHLinearOp(AF(zeros(Nx, Ny)), tmpc, AF(d2), plan_fft!(tmpc), plan_ifft!(tmpc))\nend\n\nimport Base: *, \\\n\n# action of L\nfunction *(c::SHLinearOp, u)\n\tc.tmp_complex .= Complex.(u)\n\tc.fftplan * c.tmp_complex\n\tc.tmp_complex .= c.l1 .* c.tmp_complex\n\tc.ifftplan * c.tmp_complex\n\tc.tmp_real .= real.(c.tmp_complex)\n\treturn copy(c.tmp_real)\nend\n\n# inverse of L\nfunction \\(c::SHLinearOp, u)\n\tc.tmp_complex .= Complex.(u)\n\tc.fftplan * c.tmp_complex\n\tc.tmp_complex .=  c.tmp_complex ./ c.l1\n\tc.ifftplan * c.tmp_complex\n\tc.tmp_real .= real.(c.tmp_complex)\n\treturn copy(c.tmp_real)\nend","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"Before applying a Newton solver, we need to tell how to solve the linear equation arising in the Newton Algorithm.","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"# inverse of the jacobian of the PDE\nfunction (sh::SHLinearOp)(J, rhs; shift = 0., tol =  1e-9)\n\tu, l, ν = J\n\tudiag = l .+ 1 .+ 2ν .* u .- 3 .* u.^2 .- shift\n\tres, info = KrylovKit.linsolve( du -> -du .+ sh \\ (udiag .* du), sh \\ rhs, tol = tol, maxiter = 6)\n\treturn res, true, info.numops\nend","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"Now that we have our operator L, we can encode our functional:","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"function F_shfft(u, p)\n\t@unpack l, ν, L = p\n\treturn -(L * u) .+ ((l+1) .* u .+ ν .* u.^2 .- u.^3)\nend","category":"page"},{"location":"tutorials2b/#Linear-Algebra-on-the-GPU-1","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"Linear Algebra on the GPU","text":"","category":"section"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"We plan to use KrylovKit on the GPU. For this to work, we need to redefine some functions for CuArrays.jl.","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"note: Overloading specific functions for CuArrays.jl\nNote that the following code will not be needed in the future when CuArrays improves.","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"using CuArrays\nCuArrays.allowscalar(false)\nimport LinearAlgebra: mul!, axpby!\nmul!(x::CuArray, y::CuArray, α::T) where {T <: Number} = (x .= α .* y)\nmul!(x::CuArray, α::T, y::CuArray) where {T <: Number} = (x .= α .* y)\naxpby!(a::T, X::CuArray, b::T, Y::CuArray) where {T <: Number} = (Y .= a .* X .+ b .* Y)\n\n# type used for the arrays, can be Float32 is GPU requires it\nTY = Float64\n# put the AF = Array{TY} instead to make the code on the CPU\nAF = CuArray{TY}","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"We can now define our operator L and an initial guess sol0.","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"using LinearAlgebra, Plots\n\n# to simplify plotting of the solution\nheatmapsol(x) = heatmap(reshape(Array(x), Nx, Ny)', color=:viridis)\n\n# norm compatible with CuArrays\nnorminf(x) = maximum(abs.(x))\n\nNx = 2^10\nNy = 2^10\nlx = 8pi * 2\nly = 2*2pi/sqrt(3) * 2\n\nX = -lx .+ 2lx/(Nx) * collect(0:Nx-1)\nY = -ly .+ 2ly/(Ny) * collect(0:Ny-1)\n\nsol0 = [(cos(x) .+ cos(x/2) * cos(sqrt(3) * y/2) ) for x in X, y in Y]\n\t\tsol0 .= sol0 .- minimum(vec(sol0))\n\t\tsol0 ./= maximum(vec(sol0))\n\t\tsol0 = sol0 .- 0.25\n\t\tsol0 .*= 1.7\n\nL = SHLinearOp(Nx, lx, Ny, ly, AF = AF)\n# parameters of the PDE\npar = (l = -0.15, ν = 1.3, L = L)","category":"page"},{"location":"tutorials2b/#Newton-iterations-and-deflation-1","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"Newton iterations and deflation","text":"","category":"section"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"We are now ready to perform Newton iterations:","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"opt_new = NewtonPar(verbose = true, tol = 1e-6, maxIter = 100, linsolver = L)\n\tsol_hexa, hist, flag = @time PALC.newton(\n\t\tx -> F_shfft(x, par),\n\t\tu -> (u, par.l, par.ν),\n\t\tAF(sol0),\n\t\topt_new, normN = norminf)\n\t\t\t\t\n\tprintln(\"--> norm(sol) = \", maximum(abs.(sol_hexa)))\n\theatmapsol(sol_hexa)","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"You should see this:","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":" Newton Iterations\n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     2.7383e-01         0\n        1                2     1.2891e+02        14\n        2                3     3.8139e+01        70\n        3                4     1.0740e+01        37\n        4                5     2.8787e+00        22\n        5                6     7.7522e-01        17\n        6                7     1.9542e-01        13\n        7                8     3.0292e-02        13\n        8                9     1.1594e-03        12\n        9               10     1.8842e-06        11\n       10               11     4.2642e-08        10\n  2.261527 seconds (555.45 k allocations: 44.849 MiB, 1.61% gc time)\n--> norm(sol) = 1.26017611779702","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"Note that this is about the same computation time as in Example 2 but for a problem almost 100x larger!","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"The solution is:","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"(Image: )","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"We can also use the deflation technique (see DeflationOperator and DeflatedProblem for more information) on the GPU as follows","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"deflationOp = DeflationOperator(2.0, (x, y)->dot(x, y), 1.0, [sol_hexa])\n\nopt_new = @set opt_new.maxIter = 250\noutdef, _, flag, _ = @time newton(\n\t\tx -> F_shfft(x, par),\n\t\tu -> (u, par.l, par.ν),\n\t\t0.4 .* sol_hexa .* AF([exp(-1(x+0lx)^2/25) for x in X, y in Y]),\n\t\topt_new, deflationOp, normN = x-> maximum(abs.(x)))\n\tprintln(\"--> norm(sol) = \", norm(outdef))\n\theatmapsol(outdef) |> display\n\tflag && push!(deflationOp, outdef)","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"and get:","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"(Image: )","category":"page"},{"location":"tutorials2b/#Computation-of-the-branches-1","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"Computation of the branches","text":"","category":"section"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"Finally, we can perform continuation of the branches on the GPU:","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"opts_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.007, ds= -0.005, pMax = 0.2, pMin = -1.0, theta = 0.5, plotEveryNsteps = 5, \n\tnewtonOptions = setproperties(opt_new; tol = 1e-6, maxIter = 15), maxSteps = 100)\n\n\tbr, _ = @time continuation(\n\t\t(u, p) -> F_shfft(u, @set par.l = p),\n\t\t(u, p) -> (u, p, par.ν),\n\t\tdeflationOp[1],\n\t\t-0.1,\n\t\topts_cont, plot = true,\n\t\tplotSolution = (x;kwargs...)->heatmap!(reshape(Array(x), Nx, Ny)'; color=:viridis, kwargs...), normC = x->maximum(abs.(x)))","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"We did not detail how to compute the eigenvalues on the GPU and detect the bifurcations. It is based on a simple Shift-Invert strategy, please look at examples/SH2d-fronts-cuda.jl.","category":"page"},{"location":"tutorials2b/#","page":"4/ The Swift-Hohenberg on the GPU (non-local)","title":"4/ The Swift-Hohenberg on the GPU (non-local)","text":"(Image: )","category":"page"},{"location":"borderedlinearsolver/#Bordered-linear-solvers-1","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"","category":"section"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The bordered linear solvers must be subtypes of AbstractBorderedLinearSolver <: AbstractLinearSolver. ","category":"page"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The methods provided here solve bordered linear equations. More precisely, one is interested in the solution to Jcdot u = v where","category":"page"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"tag E J=left(beginarrayll\nA  b \nc  d\nendarrayright) text  and  v=left(beginarrayl\nv_1 \nv_2\nendarrayright)","category":"page"},{"location":"borderedlinearsolver/#Full-matrix-1","page":"Bordered linear solvers","title":"Full matrix","text":"","category":"section"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"This easiest way to solve (E) is by forming the matrix J. In case it is sparse, it should be relatively efficient. You can create such bordered linear solver using bls = MatrixBLS(ls) where ls::AbstractLinearSolver is a linear solver which defaults to \\ and which is used to solve (E) with J.","category":"page"},{"location":"borderedlinearsolver/#Bordering-method-1","page":"Bordered linear solvers","title":"Bordering method","text":"","category":"section"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The general solution to (E) when A is non singular is x_1=A^-1v_1 x_2=A^-1b, u_2 = frac1d - (cx_2)(v_2 - (cx_1)) and u_1=x_1-u_2x_2. This is the default method used in the package. It is very efficient for large scale problems because it is entirely Matrix-Free and one can use preconditioners. You can create such bordered linear solver using bls = BorderingBLS(ls) where ls::AbstractLinearSolver is a linear solver which defaults to \\. The intermediate solutions x_1=A^-1v_1 x_2=A^-1b are formed using ls.","category":"page"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"Using such method with ls being a GMRES method is the main way to solve (E) in this package.\nIn the case where ls = DefaultLS(), the factorisation of A is cached so the second linear solve is very fast ","category":"page"},{"location":"borderedlinearsolver/#Full-Matrix-Free-1","page":"Bordered linear solvers","title":"Full Matrix-Free","text":"","category":"section"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"In cases where A is singular but J is not, the bordering method may fail. It can thus be advantageous to form the Matrix-Free version of J and call a generic linear solver to find the solution to (E). You can create such bordered linear solver using bls = MatrixFreeBLS(ls) where ls::AbstractLinearSolver is a (Matrix Free) linear solver which is used to invert J.","category":"page"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"For now, this linear solver only works with AbstractArray","category":"page"},{"location":"faq/#FAQ-1","page":"Frequently Asked Questions","title":"FAQ","text":"","category":"section"},{"location":"faq/#How-can-I-save-a-solution-every-n-steps,-or-at-specific-parameter-values?-1","page":"Frequently Asked Questions","title":"How can I save a solution every n steps, or at specific parameter values?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can use the callback finaliseSolution in the function call continuation. For example, you can use something like this to save all steps","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"function mySave(u, tau, step, contResult, personaldata)\n\tpush!(personaldata, u)\nend","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"and pass it like continuation(F, J, u, p0, finaliseSolution = (z, tau, step, contResult) -> mySave(z, tau, step, contResult, myData))","category":"page"},{"location":"faq/#The-Fold-/-Hopf-Continuation-does-not-work,-why?-1","page":"Frequently Asked Questions","title":"The Fold / Hopf Continuation does not work, why?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This requires some precise computations. Have you tried passing the expression of the Jacobian instead of relying on finite differences.","category":"page"},{"location":"faq/#What-is-the-parameter-theta-about-in-ContinuationPar?-1","page":"Frequently Asked Questions","title":"What is the parameter theta about in ContinuationPar?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"See the description of continuation on the page Library.","category":"page"},{"location":"faq/#How-can-I-change-the-preconditioner-during-computations?-1","page":"Frequently Asked Questions","title":"How can I change the preconditioner during computations?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The easiest way to achieve this is by using the callbacks provided by newton and continuation. See the documentation about these two methods. See also the example Complex Ginzburg-Landau 2d","category":"page"},{"location":"faq/#How-can-I-implement-my-own-bifurcation-detection-method?-1","page":"Frequently Asked Questions","title":"How can I implement my own bifurcation detection method?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can use the callback finaliseSolution but the best way is probably to use the Iterator Interface to inject your code anywhere in the continuation procedure. ","category":"page"},{"location":"faq/#How-do-I-dissociate-the-computation-of-eigenvalues-from-the-jacobian-that-I-passed?-1","page":"Frequently Asked Questions","title":"How do I dissociate the computation of eigenvalues from the jacobian that I passed?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Sometimes, for example when implementing boundary conditions, you pass a jacobian J but the eigenvalues, and the bifurcation points are not simply related to J. One way to do bypass this issue is to define a new eigensolver <: AbstractEigenSolver and pass it to NewtonPar field eigsolver. This is done for example in example/SH2d-fronts-cuda.jl.","category":"page"},{"location":"faq/#How-can-I-print-the-eigenvalues?-1","page":"Frequently Asked Questions","title":"How can I print the eigenvalues?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can print the eigenvalues using the following callback:","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"finaliseSolution = (z, tau, step, contResult) -> \n\t\t(Base.display(contResult.eig[end].eigenvals) ;true)","category":"page"},{"location":"constrainedproblem/#Constrained-problems-1","page":"Constrained problem","title":"Constrained problems","text":"","category":"section"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"This section is dedicated to the study of an equation (in x) F(x,p)=0 where one wishes to add a constraint g(x,p)=0. Hence, one is interested in solving in the couple (xp):","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"left\nbeginarrayl\nF(xp)=0 \ng(xp)=0\nendarrayright","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"There are several situations where this proves useful:","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"the pseudo-arclength continuation method is such a constrained problem, see continuation for more details.\nwhen the equation F(x) has a continuous symmetry described by a Lie group G and action gcdot x for gin G. One can reduce the symmetry of the problem by considering the constrained problem:","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"left\nbeginarrayl\nF(x) + pcdot Tcdot x=0 \nlangle Tcdot x_refx-x_refrangle=0\nendarrayright","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"where T is a generator of the Lie algebra associated to G and x_ref is a reference solution. This is known as the freezing method.","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"unknown: Reference\nSee Beyn and Thümmler, Phase Conditions, Symmetries and PDE Continuation. for more information on the freezing method.","category":"page"},{"location":"constrainedproblem/#Encoding-of-the-functional-1","page":"Constrained problem","title":"Encoding of the functional","text":"","category":"section"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"A composite type which implements this functional:","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"BorderedProblem","category":"page"},{"location":"constrainedproblem/#PseudoArcLengthContinuation.BorderedProblem","page":"Constrained problem","title":"PseudoArcLengthContinuation.BorderedProblem","text":"pb = BorderedProblem(;F, dxF, dpF, g, ∇g, dpg)\n\nThis composite type encodes a bordered problem, one by which we add a scalar constraint g(x, p) = 0 to an equation F(x, p) = 0. This composite type thus allows to define the functional G((x, p)) = [F(x, p) g(x, p)] and solve G = 0.\n\nYou can then evaluate the functional using or pb(z) where z = BorderedArray(x, p) or z = vcat(x, p), i.e. the last component of the vector is the Lagrange Multiplier.\n\nArguments\n\nThe arguments correspond to the functions F, g and their derivatives.\n\nSimplified constructor\n\nYou can create such functional as pb = BorderedProblem(F, g).\n\nwarning: Multidimensional constraint (Experimental)\nIt is in fact possible, using this composite type, to define a bordered problem with constraint of dimension npar > 1. One has to pass the dimension to pb = BorderedProblem(F, g, npar) and possibly the derivatives as well. The second argument of F,g is npar dimensional (for now an AbstractVector). Finally, the only possible linear (bordered) solver in this case is ::MatrixBLS.\n\n\n\n\n\n","category":"type"},{"location":"constrainedproblem/#Computation-with-newton-1","page":"Constrained problem","title":"Computation with newton","text":"","category":"section"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"We provide a simplified call to newton to solve a bordered problem:","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"newtonBordered","category":"page"},{"location":"constrainedproblem/#PseudoArcLengthContinuation.newtonBordered","page":"Constrained problem","title":"PseudoArcLengthContinuation.newtonBordered","text":"newtonBordered(pb::BorderedProblem, z0, options::NewtonPar{T, L, S}; kwargs...)\n\nThis function solves the equation associated with the functional pb with initial guess\n\n\n\n\n\n","category":"function"},{"location":"constrainedproblem/#Continuation-1","page":"Constrained problem","title":"Continuation","text":"","category":"section"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"We provide a simplified call to continue to solve a bordered problem:","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"continuationBordered","category":"page"},{"location":"constrainedproblem/#PseudoArcLengthContinuation.continuationBordered","page":"Constrained problem","title":"PseudoArcLengthContinuation.continuationBordered","text":"continuationBordered(prob, z0, p0::Real, contParams::ContinuationPar; kwargs...)\n\nThis is the continuation routine for finding the curve of solutions of a family of Bordered problems p->prob(p).\n\nArguments\n\np -> prob(p) is a family such that prob(p)::BorderedProblem encodes the functional G\nz0 a guess for the constrained problem.\np0 initial parameter, must be a real number\ncontParams same as for the regular continuation method\n\n\n\n\n\n","category":"function"},{"location":"Borderedarrays/#Bordered-Arrays-1","page":"Bordered arrays","title":"Bordered Arrays","text":"","category":"section"},{"location":"Borderedarrays/#","page":"Bordered arrays","title":"Bordered arrays","text":"warning: Advanced usage\nYou can skip this in a first read","category":"page"},{"location":"Borderedarrays/#","page":"Bordered arrays","title":"Bordered arrays","text":"Here are some informations on a composite type which is used all over the package to hold a couple (array, array) or (array, scalar) while implementing the methods described in Requested methods for Custom State. ","category":"page"},{"location":"Borderedarrays/#","page":"Bordered arrays","title":"Bordered arrays","text":"BorderedArray","category":"page"},{"location":"Borderedarrays/#PseudoArcLengthContinuation.BorderedArray","page":"Bordered arrays","title":"PseudoArcLengthContinuation.BorderedArray","text":"x = BorderedArray(vec1, vec2)\n\nThis defines an array (although not <: AbstractArray) to hold two arrays or an array and a scalar. This is useful when one wants to add constraints (phase, ...) to a functional for example. It is used throughout the package for the Pseudo Arc Length Continuation, for the continuation of Fold / Hopf points, for periodic orbits... It is also used to define periodic orbits as (orbit, period). As such, it is a convenient alternative to cat, vcat and friends. We chose not make it a subtype of AbstractArray as we wish to apply the current package to general \"arrays\", see Requested methods for Custom State. Finally, it proves useful for the GPU where the operation x[end] can be slow.\n\n\n\n\n\n","category":"type"},{"location":"iterator/#Iterator-Interface-1","page":"Iterator Interface","title":"Iterator Interface","text":"","category":"section"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"The iterator interface gives the possibility of stepping through the numerical steps of the continuation procedure. It thus allows to inject custom monitoring function (saving, plotting, bifurcation detection, ...) at will and during the continuation run. In short, it allows to completely re-write the continuation algorithm as one sees fit and this, in a straightforward manner.","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"The general method continuation is built upon this iterator interface and we refer to the source code for a complete example of use.","category":"page"},{"location":"iterator/#Initialization-1","page":"Iterator Interface","title":"Initialization","text":"","category":"section"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"More information about iterators can be found on the page of julialang.","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"The interface is set by defining an iterator, pretty much in the same way one calls continuation:","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"iter = PALCIterable(F, J, x0, p0, opts; kwargs...)","category":"page"},{"location":"iterator/#Stepping-1","page":"Iterator Interface","title":"Stepping","text":"","category":"section"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"Once an iterator iter has been defined, one can step through the numerical continuation using a for loop:","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"for state in iter\n\tprintln(\"Continuation step = \", state.step)\nend","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"The state::PALCStateVariables has the following description. It is a mutable object which holds the current state of the continuation procedure from which one can step to the next state.","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"The for loop stops when done(iter, state) returns false. The condition which is implemented is basically that the number of iterations should be smaller than maxIter, that the parameters should be in (pMin, pMax)...","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"PALCStateVariables","category":"page"},{"location":"iterator/#PseudoArcLengthContinuation.PALCStateVariables","page":"Iterator Interface","title":"PseudoArcLengthContinuation.PALCStateVariables","text":"state = PALCStateVariables(ds = 1e-4,...)\n\nReturns a variable containing the state of the continuation procedure.\n\nArguments\n\nz_pred current solution on the branch\ntau_new tangent predictor\nz_old previous solution\ntau_old previous tangent\nisconverged Boolean for newton correction\nit_number Number of newton iteration (in corrector)\nstep current continuation step\nds step size\ntheta theta parameter for constraint equation in PALC\nstopcontinuation Boolean to stop continuation\n\nUseful functions\n\ncopy(state) returns a copy of state\nsolution(state) returns the current solution (u,p)\ngetu(state) returns the u component of the current solution\ngetp(state) returns the p component of the current solution\nisstable(state) whether the current solution is linearly stable\n\n\n\n\n\n","category":"type"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"tip: continuation\nYou can also call continuation(iter) to have access to the regular continuation method used throughout the tutorials.","category":"page"},{"location":"iterator/#Example-1","page":"Iterator Interface","title":"Example","text":"","category":"section"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"We show a quick and simple example of use. Note that it is not very optimized because of the use of global variables.","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"using PseudoArcLengthContinuation, SparseArrays, LinearAlgebra, Plots, Setfield\nconst PALC = PseudoArcLengthContinuation\n\n# define a norm\nnormInf = x -> norm(x, Inf)\n\nk = 2\n\n# functional we want to study\nF = (x, p) -> (@. p + x - x^(k+1)/(k+1))\n\n# Jacobian for the fonctional\nJac_m = (x, p) -> diagm(0 => 1  .- x.^k)\n\n\n# parameters for the continuation\nopts = PALC.ContinuationPar(dsmax = 0.1, dsmin = 1e-3, ds = -0.001, maxSteps = 130, pMin = -3., pMax = 3., saveSolEveryNsteps = 0, computeEigenValues = true, detectBifurcation = true, newtonOptions = NewtonPar(tol = 1e-8, verbose = true))\n\n# we define an iterator to hold the continuation routine\niter = PALC.PALCIterable(F, Jac_m, [0.8], 1., opts; verbosity = 2)\n\nresp = Float64[]\nresu = Float64[]\n\n# this is the PALC algorithm\nfor state in iter\n\t# we save the current solution on the branch\n\tpush!(resu, getu(state)[1])\n\tpush!(resp, getp(state))\nend\n\n# plot the result\nplot(resp, resu; label = \"\", xlabel = \"p\")","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"and you should see:","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"(Image: )","category":"page"},{"location":"detectionBifurcation/#Detection-of-bifurcation-points-1","page":"Bifurcations","title":"Detection of bifurcation points","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"The bifurcations are detected during a call to br, _ = continuation(F, J, u0, p0::Real, contParams::ContinuationPar;kwargs...) by turning on the following flags:","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"contParams.detectBifurcation = 1 which also turns on contParams.computeEigenValues = true","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"The bifurcation points are first located by looking at the spectrum e.g. by monitoring the unstable eigenvalues. The eigenvalues lambda are declared unstable if real(λ) > contParams.precisionStability. The located bifurcation points are then returned in br.bifpoint. ","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"danger: Danger\nNote that these points are only approximate bifurcation points when detectBifurcation = 1. If detectBifurcation = 2, a bisection algorithm is used to locate them more precisely. They can also be refined using the methods described here after.","category":"page"},{"location":"detectionBifurcation/#Large-scale-computations-1","page":"Bifurcations","title":"Large scale computations","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"The user must specify the number of eigenvalues to be computed (like nev = 10) in the parameters ::ContinuationPar passed to continuation. Note that nev is automatically incremented whenever a bifurcation point is detected [1]. Also, there is an option in ::ContinuationPar to save (or not) the eigenvectors. This can be useful in memory limited environments (like on GPUs).","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"[1] In this case, the Krylov dimension is not increased because the eigensolver could be a direct solver. You might want to increase this dimension using the callbacks in continuation. ","category":"page"},{"location":"detectionBifurcation/#List-of-detected-bifurcation-points-1","page":"Bifurcations","title":"List of detected bifurcation points","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"Bifurcation index used\nFold fold\nHopf hopf\nBranch point (single eigenvalue stability change) bp\nNeimark-Sacker ns\nPeriod doubling pd\nNot documented nd","category":"page"},{"location":"detectionBifurcation/#Eigensolver-1","page":"Bifurcations","title":"Eigensolver","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"The user must provide an eigensolver by setting NewtonOptions.eigsolver where NewtonOptions is located in the parameter ::ContinuationPar passed to continuation. See NewtonPar and ContinuationPar for more information on the composite type of the options passed to newton and continuation.","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"The eigensolver is highly problem dependent and this is why the user should implement / parametrize its own eigensolver through the abstract type AbstractEigenSolver or select one among List of implemented eigen solvers.","category":"page"},{"location":"detectionBifurcation/#Fold-bifurcation-1","page":"Bifurcations","title":"Fold bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"The detection of Fold point is done by monitoring  the monotonicity of the parameter.","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"The detection is triggered by setting detectFold = true in the parameter ::ContinuationPar passed to continuation. When a Fold is detected on a branch br, a point is added to br.bifpoint allowing for later refinement using the function newtonFold.","category":"page"},{"location":"detectionBifurcation/#Generic-bifurcation-1","page":"Bifurcations","title":"Generic bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"By this we mean a change in the dimension of the Jacobian kernel. The detection of Branch point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"The detection is triggered by setting detectBifurcation = true in the parameter ::ContinuationPar passed to continuation. ","category":"page"},{"location":"detectionBifurcation/#Hopf-bifurcation-1","page":"Bifurcations","title":"Hopf bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"The detection of Branch point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"The detection is triggered by setting detectBifurcation = true in the parameter ::ContinuationPar passed to continuation. When a Hopf point is detected, a point is added to br.bifpoint allowing for later refinement using the function newtonHopf.","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"guessFromHopf(br, ind_hopf, eigsolver::AbstractEigenSolver, M, amplitude; phase = 0)","category":"page"},{"location":"detectionBifurcation/#PseudoArcLengthContinuation.guessFromHopf-Tuple{Any,Any,AbstractEigenSolver,Any,Any}","page":"Bifurcations","title":"PseudoArcLengthContinuation.guessFromHopf","text":"guessFromHopf(br, ind_hopf, eigsolver::AbstractEigenSolver, M, amplitude; phase = 0)\n\nThis function returns several useful quantities regarding a Hopf bifurcation point. More precisely, it returns:\n\nthe parameter value at which a Hopf bifurcation occurs\nthe period of the bifurcated periodic orbit\na guess for the bifurcated periodic orbit\nthe equilibrium at the Hopf bifurcation point\nthe eigenvector at the Hopf bifurcation point.\n\nThe arguments are\n\nbr: the continuation branch which lists the Hopf bifurcation points\nind_hopf: index of the bifurcation branch, as in br.bifpoint\neigsolver: the eigen solver used to find the eigenvectors\nM number of time slices in the periodic orbit guess\namplitude: amplitude of the periodic orbit guess\n\n\n\n\n\n","category":"method"},{"location":"detectionBifurcation/#Bifurcations-of-periodic-orbits-1","page":"Bifurcations","title":"Bifurcations of periodic orbits","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"The detection is triggered by setting detectBifurcation = true in the parameter ::ContinuationPar passed to continuation. The detection of bifurcation points is done by analysis of the spectrum of the Monodromy matrix composed of the Floquet multipliers. The following bifurcations are currently detected:","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"Fold of periodic orbit\nNeimark-Sacker \nPeriod doubling","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcations","title":"Bifurcations","text":"danger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of the eigensolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.   ","category":"page"},{"location":"linearsolver/#Linear-solvers-1","page":"Linear / Eigen Solvers","title":"Linear solvers","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"The linear solvers must be subtypes of AbstractLinearSolver. ","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"The linear solvers provide a way of inverting the Jacobian J or computing J \\ x.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Here is an example of the simplest of them (see src/LinearSolver.jl for the true implementation) to give you an idea, the backslash operator:","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"struct DefaultLS <: AbstractLinearSolver end\n\nfunction (l::DefaultLS)(J, rhs)\n\treturn J \\ rhs, true, 1\nend","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Note that for newton to work, the linear solver must return 3 arguments. The first one is the result, the second one is whether the computation was successful and the third is the number of iterations required to perform the computation.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"You can then call it as follows (and it will be called like this in newton)","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"ls = DefaultLS()\nls(rand(2,2), rand(2))","category":"page"},{"location":"linearsolver/#List-of-implemented-linear-solvers-1","page":"Linear / Eigen Solvers","title":"List of implemented linear solvers","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Default \\ solver based on LU or Cholesky depending on the type of the Jacobian. This works for sparse matrices as well. You can create one via linsolver = DefaultLS().\nGMRES from IterativeSolvers.jl. You can create one via linsolver = GMRESIterativeSolvers() and pass appropriate options.\nGMRES from KrylovKit.jl. You can create one via linsolver = GMRESKrylovKit() and pass appropriate options.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"note: Other solvers\nIt is very straightforward to implement the Conjugate Gradients from IterativeSolvers.jl by copying the interface done for gmres. Same goes for minres,... Not needing them, I did not implement this.","category":"page"},{"location":"linearsolver/#Preconditioner-1","page":"Linear / Eigen Solvers","title":"Preconditioner","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Preconditioners should be considered when using Matrix Free methods such as GMRES. GMRESIterativeSolvers provides a very simple interface for using them. For GMRESKrylovKit, we implemented a left preconditioner. Note that, for GMRESKrylovKit, you are not restricted to use Vectors anymore. Finally, here are some packages to use preconditioner","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"IncompleteLU.jl an ILU like preconditioner\nAlgebraicMultigrid.jl Algebraic Multigrid (AMG) preconditioners. This works especially well for symmetric positive definite matrices.\nPreconditioners.jl A convenient interface to conveniently called most of the above preconditioners using a single syntax.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"tip: Using Preconditioners\nApart from setting a preconditioner for a linear solver, it can be advantageous to change the preconditioner during computations, e.g. during a call to continuation or newton. This can be achieved by taking advantage of the callbacks to these methods. See the example Complex Ginzburg-Landau 2d.","category":"page"},{"location":"linearsolver/#Eigen-solvers-1","page":"Linear / Eigen Solvers","title":"Eigen solvers","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"The eigen solvers must be subtypes of AbstractEigenSolver. ","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"They provide a way of computing the eigen elements of the Jacobian J.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Here is an example of the simplest of them (see src/EigSolver.jl for the true implementation) to give you an idea:","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"struct DefaultEig <: AbstractEigenSolver end\n\nfunction (l::DefaultEig)(J, nev::Int64)\n\t# I put Array so we can call it on small sparse matrices\n\tF = eigen(Array(J))\n\tI = sortperm(F.values, by = x-> real(x), rev = true)\n\tnev2 = min(nev, length(I))\n\treturn F.values[I[1:nev2]], F.vectors[:, I[1:nev2]], 1\nend","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"warning: Eigenvalues\nThe eigenvalues must be ordered by increasing real part for the detection of bifurcations to work properly.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"warning: Eigenvectors\nYou have to implement the method geteigenvector(eigsolver, eigenvectors, i::Int) for newtonHopf to work properly.","category":"page"},{"location":"linearsolver/#Methods-for-computing-eigenvalues-1","page":"Linear / Eigen Solvers","title":"Methods for computing eigenvalues","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Like for the linear solvers, computing the spectrum of operators A associated to PDE is a highly non trivial task because of the clustering of eigenvalues. Most methods are based on the so-called power method but this only yields the eigenvalues with largest modulus. In case of the Laplacian operator, this can be disastrous and it is better to apply the power method to (sigma I-A)^-1 instead. ","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"This method, called Shift-invert, is readily available for the solver EigArpack, see below. It is mostly used to compute interior eigenvalues. For the solver EigKrylovKit, one must implement its own shift invert operator, using for example GMRESKrylovKit.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"In some cases, it may be advantageous to consider the Cayley transform (sigma I-A)^-1(tau I+A) to focus on a specific part of the spectrum. As it is mathematically equivalent to the Shift-invert method, we did not implement it.","category":"page"},{"location":"linearsolver/#List-of-implemented-eigen-solvers-1","page":"Linear / Eigen Solvers","title":"List of implemented eigen solvers","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Default Julia eigensolver for matrices. You can create it via eigsolver = DefaultEig(). Note that you can also specify how the eigenvalues are ordered (by decreasing real part by default)\nEigensolver from Arpack.jl. You can create it via eigsolver = EigArpack() and pass appropriate options. For example, you can compute eigenvalues using Shift-Inverse method with shift σ by using EigArpack(σ, :LR). Note that you can also specify how the eigenvalues are ordered (by decreasing real part by default). Also, this method can be used for (sparse) matrix or Matrix-Free formulation. In the case of a matrix J, you can create a solver like eig = EigArpack(). Then, you compute 3 eigen-elements using eig(J, 3). In the case of a Matrix-Free jacobian dx -> J(dx), you need to tell to tell the eigensolver the dimension of the state space by giving an example of vector: eig = EigArpack(v0 = zeros(10)). You can then compute 3 eigen-elements using eig(dx -> J(dx), 3). \nEigensolver from KrylovKit.jl. You create it via eigsolver = EigKrylovKit() and pass appropriate options. This method can be used for (sparse) matrix or Matrix-Free formulation. In the case of a matrix J, you can create a solver like this eig = EigKrylovKit(). Then, you compute 3 eigen-elements using eig(J, 3). In the case of a Matrix-Free jacobian dx -> J(dx), you need to tell to tell the eigensolver the dimension of the state space by giving an example of vector: eig = EigKrylovKit(x₀ = zeros(10)). You can then compute 3 eigen-elements using eig(dx -> J(dx), 3).","category":"page"},{"location":"tutorials3/#Brusselator-1d-1","page":"5/ Brusselator 1d","title":"Brusselator 1d","text":"","category":"section"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"unknown: References\nThis example is taken from Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust, 1997.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We look at the Brusselator in 1d. The equations are as follows","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"beginaligned frac  partial X   partial t   = frac  D _  1    l ^  2   frac  partial ^  2  X   partial z ^  2   + X ^  2  Y - ( β + 1 ) X + α  frac  partial Y   partial t   = frac  D _  2    l ^  2   frac  partial ^  2  Y   partial z ^  2   + β X - X ^  2  Y endaligned","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"with Dirichlet boundary conditions","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"beginarray  l   X ( t  z = 0 ) = X ( t  z = 1 ) = α    Y ( t  z = 0 ) = Y ( t  z = 1 ) = β  α  endarray","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"These equations have been introduced to reproduce an oscillating chemical reaction. There is an obvious equilibrium (α β  α). Here, we consider bifurcation with respect to the parameter l.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We start by writing the PDE","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"using Revise\nusing PseudoArcLengthContinuation, LinearAlgebra, Plots, SparseArrays, Setfield, Parameters\nconst PALC = PseudoArcLengthContinuation\n\nf1(u, v) = u * u * v\nnorminf = x -> norm(x, Inf)\n\nfunction Fbru(x, p)\n\t@unpack α, β, D1, D2, l = p\n\tf = similar(x)\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\tc1 = D1 / l^2 / h2\n\tc2 = D2 / l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\t# Dirichlet boundary conditions\n\tf[1]   = c1 * (α      - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])\n\tf[end] = c2 * (v[n-1] - 2v[n] + β / α)\t\t\t + β * u[n] - f1(u[n], v[n])\n\n\tf[n]   = c1 * (u[n-1] - 2u[n] +  α  )  + α - (β + 1) * u[n] + f1(u[n], v[n])\n\tf[n+1] = c2 * (β / α  - 2v[1] + v[2])\t\t\t + β * u[1] - f1(u[1], v[1])\n\n\tfor i=2:n-1\n\t\t  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])\n\t\tf[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])\t\t\t  + β * u[i] - f1(u[i], v[i])\n\tend\n\treturn f\nend","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"For computing periodic orbits, we will need a Sparse representation of the Jacobian:","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"function Jbru_sp(x, p)\n\t@unpack α, β, D1, D2, l = p\n\t# compute the Jacobian using a sparse representation\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\n\tc1 = D1 / p.l^2 / h2\n\tc2 = D2 / p.l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\tdiag   = zeros(eltype(x), 2n)\n\tdiagp1 = zeros(eltype(x), 2n-1)\n\tdiagm1 = zeros(eltype(x), 2n-1)\n\n\tdiagpn = zeros(eltype(x), n)\n\tdiagmn = zeros(eltype(x), n)\n\n\t@. diagmn = β - 2 * u * v\n\t@. diagm1[1:n-1] = c1\n\t@. diagm1[n+1:end] = c2\n\n\t@. diag[1:n]    = -2c1 - (β + 1) + 2 * u * v\n\t@. diag[n+1:2n] = -2c2 - u * u\n\n\t@. diagp1[1:n-1] = c1\n\t@. diagp1[n+1:end] = c2\n\n\t@. diagpn = u * u\n\treturn spdiagm(0 => diag, 1 => diagp1, -1 => diagm1, n => diagpn, -n => diagmn)\nend","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"tip: Tip\nWe could have used DiffEqOperators.jl like for the Swift-Hohenberg tutorial.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We shall now compute the equilibria and their stability.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"n = 500\n\n# parameters of the Brusselator model and guess for the stationary solution\npar_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)\nsol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"For the eigensolver, we use a Shift-Invert algorithm (see Eigen solvers)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"eigls = EigArpack(1.1, :LM)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We continue the trivial equilibrium to find the Hopf points","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"opt_newton = NewtonPar(eigsolver = eigls, verbose = false)\nopts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.01, ds = 0.001, pMax = 1.9, detectBifurcation = 2, nev = 21, plotEveryNsteps = 50, newtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 1060)\n\n\tbr, _ = @time continuation(\n\t\t(x, p) ->    Fbru(x, @set par_bru.l = p),\n\t\t(x, p) -> Jbru_sp(x, @set par_bru.l = p),\n\t\tsol0, par_bru.l,\n\t\topts_br_eq, verbosity = 0,\n\t\tplot = true,\n\t\tprintSolution = (x,p) -> x[div(n,2)], normC = norminf)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We obtain the following bifurcation diagram with 3 Hopf bifurcation points","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"(Image: )","category":"page"},{"location":"tutorials3/#Continuation-of-Hopf-points-1","page":"5/ Brusselator 1d","title":"Continuation of Hopf points","text":"","category":"section"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We use the bifurcation points guesses located in br.bifpoint to turn them into precise bifurcation points. For the second one, we have","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"# index of the Hopf point in br.bifpoint\nind_hopf = 2\nhopfpoint, _, flag = @time newtonHopf(\n\t(x, p) ->    Fbru(x, @set par_bru.l = p),\n\t(x, p) -> Jbru_sp(x, @set par_bru.l = p),\n\tbr, ind_hopf,\n\topts_br_eq.newtonOptions, normN = norminf)\nflag && printstyled(color=:red, \"--> We found a Hopf Point at l = \", hopfpoint.p[1], \", ω = \", hopfpoint.p[2], \", from l = \", br.bifpoint[ind_hopf].param, \"\\n\")","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"which produces","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"--> We found a Hopf Point at l = 1.0239851696548035, ω = 2.1395092895339842, from l = 1.0353910524340078","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We now perform a Hopf continuation with respect to the parameters l, β","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"tip: Tip\nYou don't need to call newtonHopf first in order to use continuationHopf.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"br_hopf, _ = @time continuationHopf(\n\t(x, l, β) ->  Fbru(x, setproperties(par_bru, (l=l, β=β))),\n\t(x, l, β) -> Jbru_sp(x, setproperties(par_bru, (l=l, β=β))),\n\tbr, ind_hopf, par_bru.β,\n\tContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 6.5, pMin = 0.0, newtonOptions = opt_newton), verbosity = 2, normC = norminf)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"which gives using plotBranch(br_hopf, xlabel=\"beta\", ylabel = \"l\")","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"(Image: )","category":"page"},{"location":"tutorials3/#Continuation-of-periodic-orbits-(Finite-differences)-1","page":"5/ Brusselator 1d","title":"Continuation of periodic orbits (Finite differences)","text":"","category":"section"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"Here, we perform continuation of periodic orbits branching from the Hopf bifurcation points. Note that the Hopf normal form is not included in the current version of the package, so we need an educated guess for the periodic orbit which is given by guessFromHopf:","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"# number of time slices\nM = 51\n\nl_hopf, Th, orbitguess2, hopfpt, vec_hopf = guessFromHopf(br, ind_hopf,\n\topts_br_eq.newtonOptions.eigsolver,\n\tM, 2.7; phase = 0.25)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We wish to make two remarks at this point. The first is that an initial guess is composed of a space time solution and of the guess for the period Th of the solution. Note that the argument 2.7 is a guess for the amplitude of the orbit.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"# orbit initial guess from guessFromHopf, is not a vector, so we reshape it\norbitguess_f2 = reduce(vcat, orbitguess2)\norbitguess_f = vcat(vec(orbitguess_f2), Th) |> vec","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"The second remark concerns the phase 0.25 written above. To account for the additional unknown (i.e. the period), periodic orbit localisation using Finite Differences requires an additional constraint (see Periodic orbits based on finite differences for more details). In the present case, this constraint is","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":" u(0) - u_hopf phi = 0","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"where u_{hopf} is the equilibrium at the Hopf bifurcation and phi is real.(vec_hopf) where vec_hopf is the eigenvector. This is akin to a Poincaré section.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"The phase of the periodic orbit is set so that the above constraint is satisfied. We shall now use Newton iterations to find a periodic orbit.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"Given our initial guess, we create a (family of) problem which encodes the functional associated to finding periodic orbits based on finite differences (see Periodic orbits based on finite differences for more information):","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"poTrap = p -> PeriodicOrbitTrapProblem(\n\tx ->    Fbru(x, @set par_bru.l = p),    # pass the vector field\n\tx -> Jbru_sp(x, @set par_bru.l = p),    # pass the jacobian of the vector field\n\treal.(vec_hopf),                        # used to set ϕ, see the phase constraint\n\thopfpt.u,                               # used to set uhopf, see the phase constraint\n\tM)\t\t\t                # number of time slices","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"To evaluate the functional at x, you call it like a function: poTrap(l_hopf + 0.01)(x) for the parameter l_hopf + 0.01. ","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"note: Using the functional for deflation, Fold of limit cycles...\nThe functional poTrap gives you access to the underlying methods to call a regular newton. For example the functional is x -> poTrap(l_hopf + 0.01)(x) at parameter l_hopf + 0.01. The (sparse) Jacobian at (x,p) is computed like this poTrap(p)(Val(:JacFullSparse), x) while the Matrix Free version is dx -> poTrap(p)(x, dx). This also allows you to call the newton deflated method (see Newton with deflation) or Newton for Fold / Hopf to locate Fold point of limit cycles see PeriodicOrbitTrapProblem. You can also use preconditioners. In the case of more computationally intense problems (like the 2d Brusselator), this might be mandatory as using LU decomposition for the linear solve will use too much memory. See Newton for Periodic Orbits for more information and the example Complex Ginzburg-Landau 2d","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"For convenience, we provide a simplified newton / continuation methods for periodic orbits. One has just to pass a PeriodicOrbitTrapProblem.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"opt_po = NewtonPar(tol = 1e-10, verbose = true, maxIter = 20)\n\toutpo_f, _, flag = @time newton(poTrap(l_hopf + 0.01),\n\t\t\torbitguess_f, opt_po, normN = norminf,\n\t\t\tcallback = (x, f, J, res, iteration, options; kwargs...) -> (println(\"--> amplitude = \", PALC.amplitude(x, n, M; ratio = 2));true))\nflag && printstyled(color=:red, \"--> T = \", outpo_f[end], \", amplitude = \", PALC.amplitude(outpo_f, n, M; ratio = 2),\"\\n\")\n# plot of the periodic orbit\nPALC.plotPeriodicPOTrap(outpo_f, n, M; ratio = 2)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"and obtain","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     1.5492e-03         0\n--> amplitude = 0.48837364060021904\n        1                2     1.4482e-02         2\n--> amplitude = 0.5444815902638647\n        2                3     1.6588e-03         2\n--> amplitude = 0.5114497102285744\n        3                4     3.6207e-05         2\n--> amplitude = 0.5153024440971214\n        4                5     5.8333e-07         2\n--> amplitude = 0.5152672386060477\n        5                6     4.8436e-11         2\n  6.710838 seconds (742.76 k allocations: 7.356 GiB, 20.12% gc time)\n--> T = 3.0206156984967505, amplitude = 0.5152672386060477","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"and","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"(Image: )","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"Finally, we can perform continuation of this periodic orbit using the specialized call continuationPOTrap","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"opt_po = @set opt_po.eigsolver = EigArpack(; tol = 1e-5, v0 = rand(2n))\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.03, ds= 0.01, pMax = 3.0, maxSteps = 30, newtonOptions = opt_po, nev = 5, precisionStability = 1e-8, detectBifurcation = 0)\nbr_po, _ , _= @time continuationPOTrap(poTrap,\n\t\t\toutpo_f, l_hopf + 0.01,\n\t\t\topts_po_cont;\n\t\t\tverbosity = 2,\tplot = true,\n\t\t\tplotSolution = (x;kwargs...) -> heatmap!(reshape(x[1:end-1], 2*n, M)'; ylabel=\"time\", color=:viridis, kwargs...), normC = norminf)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"to obtain the period of the orbit as function of l","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"(Image: )","category":"page"},{"location":"tutorials3/#Deflation-for-periodic-orbit-problems-1","page":"5/ Brusselator 1d","title":"Deflation for periodic orbit problems","text":"","category":"section"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"Looking for periodic orbits branching of bifurcation points, it is very useful to use newton algorithm with deflation. We thus define a deflation operator (see previous example)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"deflationOp = DeflationOperator(2.0, (x,y) -> dot(x[1:end-1], y[1:end-1]),1.0, [zero(orbitguess_f)])","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"which allows to find periodic orbits different from orbitguess_f. Note that the dot product removes the last component, i.e. the period of the cycle is not considered during this particular deflation. We can now use ","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"outpo_f, hist, flag = @time newton(poTrap(l_hopf + 0.01),\n\t\t\torbitguess_f, opt_po, deflationOp, :BorderedLU; normN = norminf)","category":"page"},{"location":"tutorials3/#Floquet-coefficients-1","page":"5/ Brusselator 1d","title":"Floquet coefficients","text":"","category":"section"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"A basic method for computing Floquet cofficients based on the eigenvalues of the monodromy operator is available (see FloquetQaDTrap). It is precise enough to locate bifurcations. Their computation is triggered like in the case of a regular call to continuation:","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"opt_po = @set opt_po.eigsolver = DefaultEig()\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.04, ds= -0.01, pMax = 3.0, maxSteps = 200, saveSolEveryNsteps = 1, newtonOptions = opt_po, nev = 5, precisionStability = 1e-6, detectBifurcation = 2)\nbr_po, _ , _= @time continuationPOTrap(poTrap,\n\toutpo_f, l_hopf + 0.01,\n\topts_po_cont;\n\tverbosity = 2,\tplot = true,\n\tplotSolution = (x;kwargs...) -> heatmap!(reshape(x[1:end-1], 2*n, M)'; ylabel=\"time\", color=:viridis, kwargs...), normC = norminf)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"A more complete diagram can be obtained combining the methods (essentially deflation and Floquet) described above. It shows the period of the periodic orbits as function of l. See example/brusselator.jl for more information.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"(Image: )","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"danger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of the eigensolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set when the computation of Floquet multipliers is requested.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"tip: Performances\nThis example is clearly not optimized because we wanted to keep it simple. We can use a Matrix-Free version of the functional and preconditioners to speed this up. Floquet multipliers could also be computed in a Matrix-Free manner. See examples/brusselator.jl for more efficient methods. See also Complex Ginzburg-Landau 2d for a more advanced example where we introduce those methods.","category":"page"},{"location":"tutorials3/#Continuation-of-periodic-orbits-(Standard-Shooting)-1","page":"5/ Brusselator 1d","title":"Continuation of periodic orbits (Standard Shooting)","text":"","category":"section"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"Note that what follows is not really optimized on the DifferentialEquations.jl side. Indeed, we do not use automatic differentiation, we do not pass the sparsity pattern,...","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We now turn to a different method based on the flow of the Brusselator. To compute this flow (time stepper), we need to be able to solve the differential equation (actually a PDE) associated to the vector field Fbru. We will show how to do this with an implicit method Rodas4P from DifferentialEquations.jl. Note that the user can pass its own time stepper but for convenience, we use the ones in DifferentialEquations.jl. More information regarding the shooting method is contained in Periodic orbits based on the shooting method. To define the flow, it is better to have an inplace version of the vector field:","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"function Fbru!(f, x, p)\n\t@unpack α, β, D1, D2, l = p\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\tc1 = D1 / l^2 / h2\n\tc2 = D2 / l^2 / h2\n\t\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\t\n\t# Dirichlet boundary conditions\n\tf[1]   = c1 * (α\t  - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])\n\tf[end] = c2 * (v[n-1] - 2v[n] + β / α)\t\t\t + β * u[n] - f1(u[n], v[n])\n\t\n\tf[n]   = c1 * (u[n-1] - 2u[n] +  α   ) + α - (β + 1) * u[n] + f1(u[n], v[n])\n\tf[n+1] = c2 * (β / α  - 2v[1] + v[2])\t\t\t + β * u[1] - f1(u[1], v[1])\n\t\n\tfor i=2:n-1\n\t\t  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])\n\t\tf[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])\t\t\t  + β * u[i] - f1(u[i], v[i])\n\tend\n\treturn f\nend\n\nfunction Fbru(x, p)\n\tf = similar(x)\n\tFbru!(f, x, p)\nend","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We then recompute the locus of the Hopf bifurcation points using the same method as above.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"n = 100\n\n# different parameters to define the Brusselator model and guess for the stationary solution\npar_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)\nsol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))\n\neigls = EigArpack(1.1, :LM)\nopts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.00615, ds = 0.0061, pMax = 1.9, \n\tdetectBifurcation = 1, nev = 21, plotEveryNsteps = 50, \n\tnewtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 1060)\n\nbr, _ = @time continuation(\n\t(x, p) ->    Fbru(x, @set par_bru.l = p),\n\t(x, p) -> Jbru_sp(x, @set par_bru.l = p),\n\tsol0, par_bru.l,\n\topts_br_eq, verbosity = 0,\n\tplot = false,\n\tprintSolution = (x, p)->x[div(n,2)], normC = norminf)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We need to create a guess for the periodic orbit. We proceed as previously:","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"# number of time slices\nM = 10\n\n# index of the Hopf point in the branch br\nind_hopf = 1\n\nl_hopf, Th, orbitguess2, hopfpt, vec_hopf = guessFromHopf(br, ind_hopf, \n\topts_br_eq.newtonOptions.eigsolver, M, 22*0.05)\n\norbitguess_f2 = reduce(hcat, orbitguess2)\norbitguess_f = vcat(vec(orbitguess_f2), Th) |> vec","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"Let us now initiate the Standard Shooting method. To this aim, we need to provide a guess of the periodic orbit at times TM_sh where T is the period of the cycle and M_sh is the number of slices along the periodic orbits. If M_sh = 1, this the Standard Simple Shooting and the Standard Multiple one otherwise. See ShootingProblem for more information.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"dM = 3\norbitsection = reduce(vcat, orbitguess2[1:dM:M])\n# M_sh = size(orbitsection, 2)\n\n# the last component is an estimate of the period of the cycle.\ninitpo = vcat(vec(orbitsection), 3.0)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"Finally, we need to build a problem which encodes the Shooting functional. This done as follows where we first create the time stepper:","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"using DifferentialEquations, DiffEqOperators\n\nFOde(f, x, p, t) = Fbru!(f, x, p)\n\nu0 = sol0 .+ 0.01 .* rand(2n)\n\n# parameter close to the Hopf bifurcation point\npar_hopf = (@set par_bru.l = l_hopf + 0.01)\n\n# this is the ODE time stepper when used with `solve`\nprobsundials = ODEProblem(FOde, u0, (0., 1000.), par_hopf)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We create the problem:","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"# this encodes the functional for the Shooting problem\nprobSh = p -> ShootingProblem(\n\t# pass the vector field and parameter (to be passed to the vector field)\n\tu -> Fbru(u, p), p, \n\t\n\t# we pass the ODEProblem encoding the flow and the time stepper\n\tprobsundials, Rodas4P(),\n\t\n\t# we pass M_{sh}\n\tlength(1:dM:M),\n\t\n\t# this is the phase condition, you can pass your own function\n\tx -> PALC.sectionShooting(x, Array(orbitguess_f2[:,1:dM:M]), p, Fbru); \n\t\n\t# these are options passed to the ODE time stepper\n\tatol = 1e-10, rtol = 1e-8)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We are now ready to call newton ","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"ls = GMRESIterativeSolvers(tol = 1e-7, N = length(initpo), maxiter = 100, verbose = false)\noptn_po = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 20, linsolver = ls)\noutpo ,_ = @time newton(probSh(par_hopf),\n\tinitpo, optn_po;\n\tnormN = norminf)\nplot(initpo[1:end-1], label = \"Init guess\")\nplot!(outpo[1:end-1], label = \"sol\")","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"which gives (note that we did not have a really nice guess...)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     1.2983e-01         0\n        1                2     3.2046e-01        49\n        2                3     5.4818e-02        49\n        3                4     1.6409e-02        49\n        4                5     8.1653e-03        49\n        5                6     3.9391e-04        49\n        6                7     2.2715e-07        49\n        7                8     8.7713e-11        53\n 26.499964 seconds (33.54 M allocations: 4.027 GiB, 3.38% gc time)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"and","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"(Image: )","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"Note that using Simple Shooting, the convergence is much faster. Indeed, running the code above with dM = 10 gives:","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     3.1251e-03         0\n        1                2     4.7046e-03         6\n        2                3     1.4468e-03         7\n        3                4     2.7600e-03         8\n        4                5     2.2756e-03         8\n        5                6     7.0376e-03         8\n        6                7     5.0430e-03         8\n        7                8     1.7595e-02         8\n        8                9     2.2254e-03         7\n        9               10     2.6376e-04         7\n       10               11     1.0260e-05         7\n       11               12     1.0955e-06         8\n       12               13     6.9387e-08         7\n       13               14     4.7182e-09         7\n       14               15     2.7187e-11         7\n  3.398485 seconds (2.78 M allocations: 342.794 MiB, 1.40% gc time)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"info: Convergence and speedup\nThe convergence is much worse for the multiple shooting than for the simple one. This is reflected above in the number of linear iterations made during the newton solve. The reason for this is because of the cyclic structure of the jacobian which impedes GMRES from converging fast. This can only be resolved with an improved GMRES which we'll provide in the future.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"Finally, we can perform continuation of this periodic orbit using a specialized version of continuation:","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"# note the eigensolver computes the eigenvalues of the monodromy matrix. Hence\n# the dimension of the state space for the eigensolver is 2n\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 1.5, \n\tmaxSteps = 500, newtonOptions = (@set optn_po.tol = 1e-7), nev = 25,\n\tprecisionStability = 1e-8, detectBifurcation = 0)\n\nbr_po, _, _= @time continuationPOShooting(\n\tp -> probSh(@set par_hopf.l = p),\n\toutpo, par_hopf.l,\n\topts_po_cont; verbosity = 2,\n\tplot = true,\n\tplotSolution = (x; kwargs...) -> PALC.plotPeriodicShooting!(x[1:end-1], length(1:dM:M); kwargs...),\n\tprintSolution = (u, p) -> u[end], normC = norminf)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We can observe that simple shooting is faster but the Floquet multipliers are less accurate than for multiple shooting. Also, when the solution is very unstable, simple shooting can have spurious branch switching. Finally, note the 0=log 1 eigenvalue of the monodromy matrix in the graph below.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"(Image: )","category":"page"},{"location":"tutorials3/#Continuation-of-periodic-orbits-(Poincaré-Shooting)-1","page":"5/ Brusselator 1d","title":"Continuation of periodic orbits (Poincaré Shooting)","text":"","category":"section"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"compat: Experimental\nThis computation of periodic orbits via Poincaré shooting is still experimenntal and not tested as much as the Standard shooting.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We now turn to another Shooting method, namely the Poincaré one. We can provide this method thanks to the unique functionalities of DifferentialEquations.jl. More information is provided at PoincareShootingProblem and Periodic orbits based on the shooting method but basically, it is a shooting method between Poincaré sections Sigma_i (along the orbit) defined by hyperplanes. As a consequence, the dimension of the unknowns is M_sh(N-1) where N is the dimension of the phase space. Indeed, each time slice lives in an hyperplane Sigma_i. Additionally, the period T is not an unknown of the method but rather a by-product. However, the method requires the time stepper to find when the flow hits an hyperplane Sigma_i, something called event detection.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We show how to use this method, the code is very similar to the case of the Standard Shooting. We first define the functional for Poincaré Shooting Problem","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"dM = 10\n\n# vectors to define the hyperplanes Sigma_i\nnormals = [Fbru(orbitguess_f2[:,ii], par_hopf)/(norm(Fbru(orbitguess_f2[:,ii], par_hopf))) for ii = 1:dM:M]\ncenters = [orbitguess_f2[:,ii] for ii = 1:dM:M]\n\n# functional to hold the Poincare Shooting Problem\nprobHPsh = p -> PoincareShootingProblem(\n\t# vector field and parameter\n\tu -> Fbru(u, p), p, \n\t\n\t# ODEProblem, ODE solver used to compute the flow\n\tprobsundials, Rodas4P(), \n\t\n\t# parameters for the Poincaré sections\n\tnormals, centers; \n\t\n\t# Parameters passed to the ODE solver\n\tatol = 1e-10, rtol = 1e-8)","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"Let us now compute an initial guess for the periodic orbit which must live in the hyperplanes Sigma_i. Fortunately, we provide projections on these hyperplanes.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"# variable to hold the initial guess\ninitpo_bar = zeros(size(orbitguess_f2,1)-1, length(normals))\n\n# projection of the initial guess on the hyperplanes. We assume that the centers[ii]\n# form the periodic orbit initial guess.\nfor ii=1:length(normals)\n\tinitpo_bar[:, ii] .= PALC.R(hyper, centers[ii], ii)\nend","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We can now call continuation to get the first branch.","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"# eigen / linear solver\neig = EigKrylovKit(tol= 1e-12, x₀ = rand(2n-1), verbose = 0, dim = 40)\nls = GMRESIterativeSolvers(tol = 1e-11, N = length(vec(initpo_bar)), maxiter = 500, verbose = false)\n\n# newton options\t\noptn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 140, linsolver = ls)\n\n# continuation options\nopts_po_cont_floquet = ContinuationPar(dsmin = 0.0001, dsmax = 0.05, ds= 0.001, \n\tpMax = 2.5, maxSteps = 500, nev = 10, \n\tprecisionStability = 1e-5, detectBifurcation = 2, plotEveryNsteps = 3)\nopts_po_cont_floquet = @set opts_po_cont_floquet.newtonOptions = \n\tNewtonPar(linsolver = ls, eigsolver = eig, tol = 1e-9, verbose = true)\n\n# continuation run\nbr_po, _ , _ = @time PALC.continuationPOShooting(\n\tp -> probHPsh(@set par_hopf.l = p),\n\toutpo_psh, 0.6,\n\topts_po_cont_floquet; verbosity = 3,\n\tplot = true,\n\tplotSolution = (x; kwargs...) -> PALC.plot!(x; label=\"\", kwargs...),\n\tnormC = norminf)\t\t","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"(Image: )","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"We also obtain the following information:","category":"page"},{"location":"tutorials3/#","page":"5/ Brusselator 1d","title":"5/ Brusselator 1d","text":"julia> br_po\nBranch number of points: 41\nBifurcation points:\n-   1,      bp point around p ≈ 1.22791659, step =  18, idx =  19, ind_bif =   1 [converged], δ = ( 1,  0)\n-   2,      ns point around p ≈ 1.76774516, step =  27, idx =  28, ind_bif =   3 [converged], δ = ( 2,  2)\n-   3,      ns point around p ≈ 1.85809384, step =  29, idx =  30, ind_bif =   5 [converged], δ = ( 2,  2)\n-   4,      bp point around p ≈ 1.87009173, step =  30, idx =  31, ind_bif =   5 [converged], δ = (-1,  0)\n-   5,      bp point around p ≈ 2.47577299, step =  39, idx =  40, ind_bif =   5 [converged], δ = ( 1,  0)","category":"page"},{"location":"#PseudoArcLengthContinuation.jl-1","page":"Home","title":"PseudoArcLengthContinuation.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package aims at solving equations F(ulambda)=0 where lambda inmathbb R starting from an initial guess (u_0lambda_0). It relies on the pseudo arclength continuation algorithm which provides a predictor (u_1lambda_1) from (u_0lambda_0). A Newton method is then used to correct this predictor.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The current package focuses on large scale problem and multiple hardware. Hence, the goal is to use Matrix Free / Sparse methods on GPU or a cluster in order to solve non linear equations (for example PDE, nonlocal problems, sub-manifolds...).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"One design choice is that we do not require u to be a subtype of an AbstractArray as this would forbid the use of spectral methods like the one from ApproxFun.jl. So far, our implementation does not allow this for Hopf continuation and computation of periodic orbits. It will be improved later.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, we leave it to the user to take advantage of automatic differentiation as this field is moving too fast for now, albeit there are several well established packages like ForwardDiff.jl and Zygote.jl to name just a few.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package requires Julia >= v1.3.0 because of the use of methods added to abtract types (see #31916).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To install it, please run","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add https://github.com/rveltz/PseudoArcLengthContinuation.jl","category":"page"},{"location":"#Citing-this-work-1","page":"Home","title":"Citing this work","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you use this package for your work, please cite it!! Open source development strongly depends on this. It is referenced on HAL-Inria as follows:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@misc{veltz:hal-02071874,\n  TITLE = {{PseudoArcLengthContinuation.jl}},\n  AUTHOR = {Veltz, Romain},\n  URL = {https://hal.inria.fr/hal-02071874},\n  YEAR = {2019},\n  MONTH = Mar,\n  KEYWORDS = {Pseudo Arclength Continuation},\n  PDF = {https://hal.inria.fr/hal-02071874/file/PseudoArcLengthContinuation.jl-master.zip},\n  HAL_ID = {hal-02071874},\n  HAL_VERSION = {v1},\n}","category":"page"},{"location":"#Other-softwares-1","page":"Home","title":"Other softwares","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"There are many good softwares already available, most of them are listed on DSWeb. One can mention the venerable AUTO, or also, XPPAUT, MATCONT and COCO. For large scale problems, there is Trilinos, the versatile pde2path, CL_MATCONTL and the python library pyNCT. Finally, there is also a MATLAB continuation code by D. Avitabile.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In Julia, we have for now a wrapper to PyDSTools, and also Bifurcations.jl.","category":"page"},{"location":"#A-word-on-performance-1","page":"Home","title":"A word on performance","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The examples which follow have not all been written with the goal of performance but rather simplicity (except maybe Complex Ginzburg-Landau 2d). One could surely turn them into more efficient codes. The intricacies of PDEs make the writing of efficient code highly problem dependent and one should take advantage of every particularity of the problem under study.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For example, in the first tutorial on Temperature model, one could use BandedMatrices.jl for the jacobian and an inplace modification when the jacobian is called ; using a composite type would be favored. Porting them to GPU would be another option.","category":"page"},{"location":"#Main-features-1","page":"Home","title":"Main features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Matrix Free Newton solver with generic linear / eigen preconditioned solver. Idem for the arc-length continuation.\nMatrix Free Newton solver with deflation and preconditioner. It can be used for branch switching for example.\nBifurcation points are located using a bisection algorithm\nBranch, Fold, Hopf bifurcation point detection of stationary solutions.\nFold / Hopf continuation based on Minimally Augmented formulation, with Matrix Free / Sparse Jacobian.\nPeriodic orbit computation and continuation using Shooting or Finite Differences.\nBranch, Fold, Neimark-Sacker, Period Doubling bifurcation point detection of periodic orbits.\nComputation and Continuation of Fold of periodic orbits","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Custom state means, we can use something else than AbstractArray, for example your own struct (see Requested methods for Custom State). ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that you can combine most of the solvers, like use Deflation for Periodic orbit computation or Fold of periodic orbits family.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Features Matrix Free Custom state Tutorial\nNewton Y Y All\nNewton + Deflation Y Y 3, 4\nContinuation (Natural, Secant, Tangent) Y Y All\nBranching point detection Y Y All\nFold point detection Y Y All\nHopf detection Y Y 5 - 8\nFold Point continuation Y Y 1, 7\nHopf continuation Y AbstractArray 5\nPeriodic Orbit (FD) Newton / continuation Y AbstractVector 5, 7\nPeriodic Orbit with Poincaré / Standard Shooting Newton / continuation Y AbstractArray 5, 6, 8\nFold, Neimark-Sacker, Period doubling detection Y AbstractVector 5 - 8\nContinuation of Fold of periodic orbits Y AbstractVector 7","category":"page"},{"location":"#Requested-methods-for-Custom-State-1","page":"Home","title":"Requested methods for Custom State","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Needless to say, if you use regulars arrays, you don't need to worry about what follows.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We make the same requirements than KrylovKit.jl. Hence, we refer to its docs for more information. We additionally require the following methods to be available:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Base.length(x): it is used in the constraint equation of the pseudo arclength continuation method (see continuation for more details). If length is not available for your \"vector\", define it length(x) = 1 and adjust tuning the parameter theta in ContinuationPar.","category":"page"},{"location":"tutorialsCGLShoot/#Complex-Ginzburg-Landau-2d-(shooting)-1","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"","category":"section"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"In this tutorial, we re-visit the example Complex Ginzburg-Landau 2d using a Standard Simple Shooting method. In the tutorial Brusselator 1d, we used the implicit solver Rodas4P for the shooting. We will use the exponential-RK scheme ETDRK2 ODE solver to compute the solution of cGL equations. This method is convenient for solving solving semilinear problems of the form ","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"dot x = Ax+g(x)","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"where A is the infinitesimal generator of a C_0-semigroup. We use the same beginning as in Complex Ginzburg-Landau 2d:","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"using Revise\n\tusing DiffEqOperators, ForwardDiff, DifferentialEquations\n\tusing PseudoArcLengthContinuation, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield\n\tconst PALC = PseudoArcLengthContinuation\n\nnorminf = x -> norm(x, Inf)\n\nfunction Laplacian2D(Nx, Ny, lx, ly)\n\thx = 2lx/Nx\n\thy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\t\n\tQx = Dirichlet0BC(typeof(hx))\n\tQy = Dirichlet0BC(typeof(hy))\n\t\n\tD2xsp = sparse(D2x * Qx)[1]\n\tD2ysp = sparse(D2y * Qy)[1]\n\n\tA = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))\n\treturn A, D2x\nend","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"We then encode the PDE:","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"function NL!(f, u, p, t = 0.)\n\t@unpack r, μ, ν, c3, c5 = p\n\tn = div(length(u), 2)\n\tu1 = @view u[1:n]\n\tu2 = @view u[n+1:2n]\n\n\tua = u1.^2 .+ u2.^2\n\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@. f1 .= r * u1 - ν * u2 - ua * (c3 * u1 - μ * u2) - c5 * ua^2 * u1\n\t@. f2 .= r * u2 + ν * u1 - ua * (c3 * u2 + μ * u1) - c5 * ua^2 * u2\n\n\treturn f\nend\n\nfunction NL(u, p)\n\tout = similar(u)\n\tNL!(out, u, p)\nend\n\nfunction Fcgl!(f, u, p, t = 0.)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\nend\n\nfunction Fcgl(u, p, t = 0.)\n\tf = similar(u)\n\tFcgl!(f, u, p, t)\nend","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"with parameters ","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"Nx = 41\nNy = 21\nn = Nx*Ny\nlx = pi\nly = pi/2\n\nΔ = Laplacian2D(Nx, Ny, lx, ly)[1]\npar_cgl = (r = 0.5, μ = 0.1, ν = 1.0, c3 = -1.0, c5 = 1.0, Δ = blockdiag(Δ, Δ))\nsol0 = 0.1rand(2Nx, Ny)\nsol0_f = vec(sol0)","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"and the ODE problem","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"f1 = DiffEqArrayOperator(par_cgl.Δ)\nf2 = NL!\nprob_sp = SplitODEProblem(f1, f2, sol0_f, (0.0, 120.0), @set par_cgl.r = 1.2)\n# we solve the PDE!!!\nsol = @time solve(prob_sp, ETDRK2(krylov=true); abstol=1e-14, reltol=1e-14, dt = 0.1)","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"We now define the Shooting functional","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"probSh = p -> ShootingProblem(\n\t# pass the vector field and parameter (to be passed to the vector field)\n\tu -> Fcgl(u, p), p,\n\n\t# we pass the ODEProblem encoding the flow and the time stepper\n\tprob_sp, ETDRK2(krylov = true),\n\n\t# we pass M_{sh}\n\t1,\n\n\t# this is the phase condition\n\tx -> PALC.sectionShooting(x, Array(sol[:, end:end]), p, Fcgl);\n\n\t# these are options passed to the ODE time stepper\n\tatol = 1e-14, rtol = 1e-14, dt = 0.1)","category":"page"},{"location":"tutorialsCGLShoot/#Computation-of-the-first-branch-of-periodic-orbits-1","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"Computation of the first branch of periodic orbits","text":"","category":"section"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"We use the solution from the ODE solver as a starting guess for the shooting method.","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"# initial guess with period 6.9 using solution at time t = 116\ninitpo = vcat(sol(116.), 6.9) |> vec\n\n# linear solver for shooting functional\nls = GMRESIterativeSolvers(tol = 1e-4, N = 2Nx * Ny + 1, maxiter=50, verbose = false)\n# newton parameters\noptn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 20, linsolver = ls)\n# continuation parameters\neig = EigKrylovKit(tol=1e-7, x₀ = rand(2Nx*Ny), verbose = 2, dim = 40)\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.01, ds= -0.01, pMax = 1.5, maxSteps = 60, newtonOptions = (@set optn.eigsolver = eig), nev = 5, precisionStability = 1e-3, detectBifurcation = 2)\n\nbr_po, _ , _= @time continuationPOShooting(\n\tp -> probSh(@set par_cgl.r = p),\n\tinitpo, 1.2, opts_po_cont;\n\tverbosity = 3,\n\tplot = true,\n\tplotSolution = (x; kwargs...) -> heatmap!(reshape(x[1:Nx*Ny], Nx, Ny); color=:viridis, kwargs...),\n\tprintSolution = (u, p) -> PALC.getAmplitude(probSh(@set par_cgl.r = p), u; ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsCGLShoot/#","page":"8/ Ginzburg-Landau 2d (Shooting)","title":"8/ Ginzburg-Landau 2d (Shooting)","text":"(Image: )","category":"page"},{"location":"diffeq/#Wrapper-to-the-package-DifferentialEquations.jl-1","page":"DiffEq wrapper","title":"Wrapper to the package DifferentialEquations.jl","text":"","category":"section"},{"location":"diffeq/#","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"Note that this is still work in progress.","category":"page"},{"location":"diffeq/#","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"The current package provides basic methods to wrap some of the functionality of DifferentialEquations.jl. ","category":"page"},{"location":"diffeq/#","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"Basically, the ultimate idea is that you provide a prob::ODEProblem to our newton, continuation... and they will use the expression of the jacobians, the linear solvers... that you already provided for the construction of prob.","category":"page"}]
}
