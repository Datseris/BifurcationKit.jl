var documenterSearchIndex = {"docs":
[{"location":"tutorialsCGLShoot/#Complex-Ginzburg-Landau-2d-(shooting)-1","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"","category":"section"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"Pages = [\"tutorialsCGLShoot.md\"]\nDepth = 3","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"In this tutorial, we re-visit the example Complex Ginzburg-Landau 2d using a Standard Simple Shooting method. In the tutorial Brusselator 1d (advanced user), we used the implicit solver Rodas4P for the shooting. We will use the exponential-RK scheme ETDRK2 ODE solver to compute the solution of cGL equations. This method is convenient for solving semilinear problems of the form ","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"dot x = Ax+g(x)","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"where A is the infinitesimal generator of a C_0-semigroup. We use the same beginning as in Complex Ginzburg-Landau 2d:","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"using Revise\n\tusing DiffEqOperators, DifferentialEquations\n\tusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield\n\tconst BK = BifurcationKit\n\nnorminf = x -> norm(x, Inf)\n\nfunction Laplacian2D(Nx, Ny, lx, ly)\n\thx = 2lx/Nx\n\thy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\t\n\tQx = Dirichlet0BC(typeof(hx))\n\tQy = Dirichlet0BC(typeof(hy))\n\t\n\tD2xsp = sparse(D2x * Qx)[1]\n\tD2ysp = sparse(D2y * Qy)[1]\n\n\tA = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))\n\treturn A, D2x\nend","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"We then encode the PDE:","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"function NL!(f, u, p, t = 0.)\n\t@unpack r, μ, ν, c3, c5 = p\n\tn = div(length(u), 2)\n\tu1 = @view u[1:n]\n\tu2 = @view u[n+1:2n]\n\n\tua = u1.^2 .+ u2.^2\n\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@. f1 .= r * u1 - ν * u2 - ua * (c3 * u1 - μ * u2) - c5 * ua^2 * u1\n\t@. f2 .= r * u2 + ν * u1 - ua * (c3 * u2 + μ * u1) - c5 * ua^2 * u2\n\n\treturn f\nend\n\nfunction NL(u, p)\n\tout = similar(u)\n\tNL!(out, u, p)\nend\n\nfunction Fcgl!(f, u, p, t = 0.)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\nend\n\nfunction Fcgl(u, p, t = 0.)\n\tf = similar(u)\n\tFcgl!(f, u, p, t)\nend\n\nfunction Jcgl(u, p, t = 0.)\n\t@unpack r, μ, ν, c3, c5, Δ = p\n\n\tn = div(length(u), 2)\n\tu1 = @view u[1:n]\n\tu2 = @view u[n+1:2n]\n\n\tua = u1.^2 .+ u2.^2\n\n\tf1u = zero(u1)\n\tf2u = zero(u1)\n\tf1v = zero(u1)\n\tf2v = zero(u1)\n\n\t@. f1u =  r - 2 * u1 * (c3 * u1 - μ * u2) - c3 * ua - 4 * c5 * ua * u1^2 - c5 * ua^2\n\t@. f1v = -ν - 2 * u2 * (c3 * u1 - μ * u2)  + μ * ua - 4 * c5 * ua * u1 * u2\n\t@. f2u =  ν - 2 * u1 * (c3 * u2 + μ * u1)  - μ * ua - 4 * c5 * ua * u1 * u2\n\t@. f2v =  r - 2 * u2 * (c3 * u2 + μ * u1) - c3 * ua - 4 * c5 * ua * u2 ^2 - c5 * ua^2\n\n\tjacdiag = vcat(f1u, f2v)\n\n\tΔ + spdiagm(0 => jacdiag, n => f1v, -n => f2u)\nend","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"with parameters ","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"Nx = 41\nNy = 21\nn = Nx*Ny\nlx = pi\nly = pi/2\n\nΔ = Laplacian2D(Nx, Ny, lx, ly)[1]\npar_cgl = (r = 0.5, μ = 0.1, ν = 1.0, c3 = -1.0, c5 = 1.0, Δ = blockdiag(Δ, Δ))\nsol0 = 0.1rand(2Nx, Ny)\nsol0_f = vec(sol0)","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"and the ODE problem","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"f1 = DiffEqArrayOperator(par_cgl.Δ)\nf2 = NL!\nprob_sp = SplitODEProblem(f1, f2, sol0_f, (0.0, 120.0), (@set par_cgl.r = 1.2), dt = 0.1)\n# we solve the PDE!!!\nsol = @time solve(prob_sp, ETDRK2(krylov=true); abstol=1e-14, reltol=1e-14)","category":"page"},{"location":"tutorialsCGLShoot/#Automatic-branch-switching-from-the-Hopf-points-1","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Automatic branch switching from the Hopf points","text":"","category":"section"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"We show how to use automatic branch switching from the Hopf points computed in the previous section. To compute the periodic orbits, we use a Standard Shooting method. ","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"We first recompute the Hopf points as in the previous tutorial:","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"eigls = EigArpack(1.0, :LM)\nopt_newton = NewtonPar(tol = 1e-9, verbose = true, eigsolver = eigls, maxIter = 20)\nopts_br = ContinuationPar(dsmax = 0.02, ds = 0.01, pMax = 2., detectBifurcation = 3, nev = 15, newtonOptions = (@set opt_newton.verbose = false), nInversion = 4)\n\nbr, = @time continuation(Fcgl, Jcgl, vec(sol0), par_cgl, (@lens _.r), opts_br, verbosity = 0)","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"We then compute the differentials of the vector field, this is needed by the branch switching method because it first computes the Hopf normal form. Thankfully, this is little work using Automatic Differentiation:","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"using ForwardDiff\n\nD(f, x, p, dx) = ForwardDiff.derivative(t -> f(x .+ t .* dx, p), 0.)\nd1Fcgl(x,p,dx1) = D((z, p0) -> Fcgl(z, p0), x, p, dx1)\nd2Fcgl(x,p,dx1,dx2) = D((z, p0) -> d1Fcgl(z, p0, dx1), x, p, dx2)\nd3Fcgl(x,p,dx1,dx2,dx3) = D((z, p0) -> d2Fcgl(z, p0, dx1, dx2), x, p, dx3)\n\njet = (Fcgl, Jcgl, d2Fcgl, d3Fcgl)","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"We define the linear solvers to be use by the (Matrix-Free) shooting method","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"ls = GMRESIterativeSolvers(tol = 1e-4, maxiter = 50, verbose = false)\neig = EigKrylovKit(tol = 1e-7, x₀ = rand(2Nx*Ny), verbose = 2, dim = 40)\noptn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 25, linsolver = ls, eigsolver = eig)\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.02, ds= -0.01, pMax = 2.5, maxSteps = 32, newtonOptions = optn, nev = 15, precisionStability = 1e-3, detectBifurcation = 3, plotEveryStep = 1)","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"as","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"br_po, = continuation(\n\t# we want to compute the bifurcated branch from \n\t# the first Hopf point\n\tjet..., br, 1,\n\t# arguments for continuation\n\topts_po_cont,\n\t# this is how to pass the method to compute the periodic\n\t# orbits. We shall use 1 section and the ODE solver ETDRK2\n\tShootingProblem(1, par_cgl, prob_sp, ETDRK2(krylov = true)) ;\n\t# regular parameters for the continuation\n\tverbosity = 3, plot = true, ampfactor = 1.5, δp = 0.01,\n\tfinaliseSolution = (z, tau, step, contResult) ->\n\t\t(Base.display(contResult.eig[end].eigenvals) ;true),\n\tnormC = norminf)","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"(Image: )","category":"page"},{"location":"tutorialsCGLShoot/#Manual-branch-switching-from-the-Hopf-points-1","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Manual branch switching from the Hopf points","text":"","category":"section"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"The goal of this section is to show how to use the package in case automatic branch switching fails. This can happen for tedious PDEs and \"one has to get his hands dirty\".","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"We decide to use Standard Shooting and thus define a Shooting functional","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"probSh = ShootingProblem(\n\t# pass the vector field and parameter (to be passed to the vector field)\n\tFcgl, par_cgl,\n\n\t# we pass the ODEProblem encoding the flow and the time stepper\n\tprob_sp, ETDRK2(krylov = true),\n\n\t# this is the phase condition\n\t[sol[:, end]];\n\n\t# these are options passed to the ODE time stepper\n\tatol = 1e-14, rtol = 1e-14)","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"We use the solution from the ODE solver as a starting guess for the shooting method.","category":"page"},{"location":"tutorialsCGLShoot/#","page":"Complex Ginzburg-Landau 2d (shooting)","title":"Complex Ginzburg-Landau 2d (shooting)","text":"# initial guess with period 6.9 using solution at time t = 116\ninitpo = vcat(sol(116.), 6.9) |> vec\n\n# linear solver for shooting functional\nls = GMRESIterativeSolvers(tol = 1e-4, N = 2Nx * Ny + 1, maxiter = 50, verbose = true)\n\n# newton parameters\noptn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 20, linsolver = ls)\n\n# continuation parameters\neig = EigKrylovKit(tol=1e-7, x₀ = rand(2Nx*Ny), verbose = 2, dim = 40)\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.01, ds= -0.01, pMax = 1.5, maxSteps = 60, newtonOptions = (@set optn.eigsolver = eig), nev = 5, precisionStability = 1e-3, detectBifurcation = 3)\n\nbr_po, = @time continuation(probSh,\n\tinitpo, (@set par_cgl.r = 1.2), (@lens _.r), opts_po_cont;\n\tverbosity = 3,\n\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> heatmap!(reshape(x[1:Nx*Ny], Nx, Ny); color=:viridis, kwargs...),\n\tprintSolution = (u, p) -> BK.getAmplitude(probSh, u, (@set par_cgl.r = p); ratio = 2), normC = norminf)","category":"page"},{"location":"tutorials/#Tutorials-1","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/#","page":"Tutorials","title":"Tutorials","text":"There are three levels of tutorials:","category":"page"},{"location":"tutorials/#","page":"Tutorials","title":"Tutorials","text":"fully automatic bifurcation diagram (aBD) computation (only for equilibria): one uses the function bifurcationdiagram and let it compute the diagram fully automatically. Note that you may have to tune the options before hand. Another possibility is to use deflated continuation.\nsemi-automatic bifurcation diagram computation: one uses automatic branch switching (aBS) to compute branches at specified bifurcation points\nmanual bifurcation diagram computation: one does not uses automatic branch switching. This has only educational purposes and for complex problems where aBS fails.","category":"page"},{"location":"tutorials/#Bifurcation-of-Equilibria-1","page":"Tutorials","title":"Bifurcation of Equilibria","text":"","category":"section"},{"location":"tutorials/#","page":"Tutorials","title":"Tutorials","text":"Pages = [\"tutorials1.md\", \"tutorials2.md\", \"mittelmann.md\", \"tutorials1b.md\",\"tutorials2b.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/#Automatic-bifurcation-diagram-1","page":"Tutorials","title":"Automatic bifurcation diagram","text":"","category":"section"},{"location":"tutorials/#","page":"Tutorials","title":"Tutorials","text":"Pages = [\"Swift-Hohenberg1d.md\", \"mittelmannAuto.md\", \"tutorialCarrier.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/#Solving-PDEs-using-Finite-elements-with-[Gridap.jl](https://github.com/gridap/Gridap.jl)-1","page":"Tutorials","title":"Solving PDEs using Finite elements with Gridap.jl","text":"","category":"section"},{"location":"tutorials/#","page":"Tutorials","title":"Tutorials","text":"Pages = [\"mittelmannGridap.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/#Bifurcation-diagrams-with-periodic-orbits-1","page":"Tutorials","title":"Bifurcation diagrams with periodic orbits","text":"","category":"section"},{"location":"tutorials/#","page":"Tutorials","title":"Tutorials","text":"Pages = [\"tutorials3.md\",\"tutorials3b.md\", \"tutorialsPD.md\", \"tutorialsCGL.md\", \"tutorialsCGLShoot.md\"]\nDepth = 1","category":"page"},{"location":"simplebp/#Simple-bifurcation-branch-point-1","page":"Simple branch point","title":"Simple bifurcation branch point","text":"","category":"section"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"unknown: References\nThe general method is exposed in Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295","category":"page"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"A simple branch point (x_0p_0) for the problem F(xp)=0 satisfies dim ker dF(x_0p_0) = 1. At such point, we can apply Lyapunov-Schmidt reduction to transform the initial problem in large dimensions to a scalar polynomial (delta p equiv p-p_0): ","category":"page"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"adelta p + zleft(b_1delta p + fracb_22z + fracb_36z^2right) = 0 tagE","category":"page"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"whose solutions give access to all solutions in a neighborhood of (xp).","category":"page"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"More precisely, if ker dF(x_0p_0) = mathbb Rzeta, one can show that x_0+zzeta is close to a solution on a new branch, thus satisfying F(x_0+zzetap_0+delta p)approx 0.","category":"page"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"In the above scalar equation,","category":"page"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"if aneq 0, this is a Saddle-Node bifurcation\nif a=0b_2neq 0, the bifurcation point is a Transcritical one where the bifurcated branch exists on each side of p.\nif a=0b_2=0 b_3neq 0, the bifurcation point is a Pitchfork one where the bifurcated branch only exists on one side of p. If it exists at smaller values then p, this is a subcritical Pitchfork bifurcation. In the other case, this is a supercritical Pitchfork bifurcation.","category":"page"},{"location":"simplebp/#Normal-form-computation-1","page":"Simple branch point","title":"Normal form computation","text":"","category":"section"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"The reduced equation (E) can be automatically computed as follows","category":"page"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"computeNormalForm(F, dF, d2F, d3F, br::ContResult, ind_bif::Int ; δ = 1e-8,\n\tnev = 5, Jt = nothing, verbose = false, ζs = nothing, lens = br.param_lens)","category":"page"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"where dF, d2F,d3F are the differentials of F. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to computeNormalForm. The result returns the following:","category":"page"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"mutable struct SimpleBranchPoint{Tv, T, Tevl, Tevr, Tnf} <: BranchPoint\n\t\"bifurcation point\"\n\tx0::Tv\n\n\t\"Parameter value at the bifurcation point\"\n\tp::T\n\n\t\"Right eigenvector(s)\"\n\tζ::Tevr\n\n\t\"Left eigenvector(s)\"\n\tζstar::Tevl\n\n\t\"Normal form coefficients\"\n\tnf::Tnf\n\n\t\"Type of bifurcation point\"\n\ttype::Symbol\nend","category":"page"},{"location":"simplebp/#","page":"Simple branch point","title":"Simple branch point","text":"info: Note\nYou should not need to call computeNormalForm except if you need the full information about the branch point.","category":"page"},{"location":"tutorialsPD/#Period-doubling-in-the-Barrio-Varea-Aragon-Maini-model-1","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"","category":"section"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"Pages = [\"tutorialsPD.md\"]\nDepth = 3","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"The purpose of this example is to show how to handle period doubling bifurcations of periodic orbits.","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"unknown: References\nThis example is taken from Aragón, J. L., R. A. Barrio, T. E. Woolley, R. E. Baker, and P. K. Maini. “Nonlinear Effects on Turing Patterns: Time Oscillations and Chaos.” Physical Review E 86, no. 2 (2012)","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"info: Method and performance\nWe focus on the Shooting method but we could have based the computation of periodic orbits on finite differences instead. Performances of the current tutorial are directly linked to the ones of DifferentialEquations.jl.     ","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We focus on the following 1D model:","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"tagEbeginaligned\nfracpartial upartial t=D nabla^2 u+etaleft(u+a v-C u v-u v^2right)\nfracpartial vpartial t=nabla^2 v+etaleft(b v+H u+C u v+u v^2right)\nendaligned","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"with Neumann boundary conditions. We start by encoding the model","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"using Revise\nusing DiffEqOperators, ForwardDiff, DifferentialEquations, SparseArrays\nusing BifurcationKit, LinearAlgebra, Plots, Setfield\nconst BK = BifurcationKit\n\nnorminf = x -> norm(x, Inf)\nf(u, v, p) = p.η * (      u + p.a * v - p.C * u * v - u * v^2)\ng(u, v, p) = p.η * (p.H * u + p.b * v + p.C * u * v + u * v^2)\n\nfunction Laplacian(N, lx, bc = :Dirichlet)\n\thx = 2lx/N\n\tD2x = CenteredDifference(2, 2, hx, N)\n\tif bc == :Neumann\n\t\tQx = Neumann0BC(hx)\n\telseif bc == :Dirichlet\n\t\tQx = Dirichlet0BC(typeof(hx))\n\tend\n\tD2xsp = sparse(D2x * Qx)[1]\nend\n\nfunction NL!(dest, u, p, t = 0.)\n\tN = div(length(u), 2)\n\tu1 =  @view (u[1:N])\n\tu2 =  @view (u[N+1:end])\n\tdest[1:N]     .= f.(u1, u2, Ref(p))\n\tdest[N+1:end] .= g.(u1, u2, Ref(p))\n\treturn dest\nend\n\nfunction Fbr!(f, u, p)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\nend\n\nfunction NL(u, p)\n\tout = similar(u)\n\tNL!(out, u, p)\n\tout\nend\n\nfunction Fbr(x, p, t = 0.)\n\tf = similar(x)\n\tFbr!(f, x, p)\nend\n\n# this is not very efficient but simple enough ;)\nJbr(x,p) = sparse(ForwardDiff.jacobian(x -> Fbr(x, p), x))","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We can now perform bifurcation of the following Turing solution:","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"N = 100\nn = 2N\nlx = 3pi /2\nX = LinRange(-lx,lx, N)\n\nΔ = Laplacian(N, lx, :Neumann)\nD = 0.08\npar_br = (η = 1.0, a = -1., b = -3/2., H = 3.0, D = D, C = -0.6, Δ = blockdiag(D*Δ, Δ))\n\nu0 = 1.0 * cos.(2X)\nsolc0 = vcat(u0, u0)\n\n# parameters for continuation\neigls = EigArpack(0.5, :LM)\nopt_newton = NewtonPar(eigsolver = eigls, verbose=true, maxIter = 3200, tol=1e-9)\nopts_br = ContinuationPar(dsmax = 0.04, ds = -0.01, pMin = -1.8,\n\tdetectBifurcation = 3, nev = 21, plotEveryStep = 50, newtonOptions = opt_newton, maxSteps = 400)\n\nbr, = @time continuation(Fbr, Jbr, solc0, (@set par_br.C = -0.2), (@lens _.C), opts_br;\n\tplot = true, verbosity = 3,\n\tprintSolution = (x, p) -> norm(x, Inf),\n\tplotSolution = (x, p; kwargs...) -> plot!(x[1:end÷2];label=\"\",ylabel =\"u\", kwargs...))","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"which yields","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"(Image: )","category":"page"},{"location":"tutorialsPD/#Periodic-orbits-from-the-Hopf-point-(Shooting)-1","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Periodic orbits from the Hopf point (Shooting)","text":"","category":"section"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We continue the periodic orbit form the first Hopf point around Capprox -08598 using a Standard Simple Shooting method (see Periodic orbits based on the shooting method). To this end, we define a SplitODEProblem from DifferentialEquations.jl which is convenient for solving semilinear problems of the form ","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"dot x = Ax+g(x)","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"where A is the infinitesimal generator of a C_0-semigroup. We use the exponential-RK scheme ETDRK2 ODE solver to compute the solution of (E) just after the Hopf point. ","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"# parameters close to the Hopf bifurcation\npar_br_hopf = @set par_br.C = -0.86\n# parameters for the ODEProblem\nf1 = DiffEqArrayOperator(par_br.Δ)\nf2 = NL!\nprob_sp = SplitODEProblem(f1, f2, solc0, (0.0, 280.0), @set par_br.C = -0.86)\n\nsol = @time solve(prob_sp, ETDRK2(krylov=true); abstol=1e-14, reltol=1e-14, dt = 0.1)","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We estimate the period of the limit cycle to be around Tapprox 3. We then use this as a guess for the shooting method:","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"# compute the guess for the shooting method\norbitsection = Array(sol[:, end])\ninitpo = vcat(vec(orbitsection), 3.)\n\n# define the functional for the standard simple shooting based on the \n# ODE solver ETDRK2. SectionShooting implements an appropriate phase condition\nprobSh = ShootingProblem(Fbr, par_br_hopf, prob_sp, ETDRK2(krylov=true),\n\t[sol(280.0)]; abstol=1e-14, reltol=1e-14, dt = 0.1)\n\t\t\n# parameters for the Newton-Krylov solver\nls = GMRESIterativeSolvers(tol = 1e-7, N = length(initpo), maxiter = 50, verbose = false)\noptn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 120, linsolver = ls)\n# Newton-Krylov solver\nout_po_sh, _, flag = @time newton(probSh , initpo, par_br_hopf, optn; normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", out_po_sh[end], \", amplitude = \", BK.getAmplitude(probSh, out_po_sh, par_br_hopf; ratio = 2),\"\\n\")","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"which gives","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"--> T = 2.94557883943451, amplitude = 0.05791350025709674","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We can now continue this periodic orbit:","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"eig = DefaultEig()\nopts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.01, ds= 0.005, pMin = -1.8, maxSteps = 170, newtonOptions = (@set optn.eigsolver = eig),\n\tnev = 10, precisionStability = 1e-2, detectBifurcation = 3)\nbr_po_sh, = @time continuation(probSh, out_po_sh, par_br_hopf, (@lens _.C), opts_po_cont; verbosity = 3,\n\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicShooting!(x[1:end-1], 1; kwargs...),\n\tprintSolution = (u, p) -> BK.getMaximum(probSh, u, (@set par_br_hopf.C = p); ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We plot the result using plot(br_po_sh, br, label = \"\"):","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"(Image: )","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"tip: Numerical precision for stability\nThe Floquet multipliers are not very precisely computed here using the Shooting method. We know that 1=exp(0) should be a Floquet multiplier but this is only true here at precision ~1e-3. In order to prevent spurious bifurcation detection, there is a threshold precisionStability in ContinuationPar for declaring an unstable eigenvalue. Another way would be to use Poincaré Shooting so that this issue does not show up.","category":"page"},{"location":"tutorialsPD/#Periodic-orbits-from-the-PD-point-(Shooting)-1","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Periodic orbits from the PD point (Shooting)","text":"","category":"section"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We now compute the periodic orbits branching of the first Period-Doubling bifurcation point. It is straightforward to obtain an initial guess using the flow around the bifurcation point:","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"par_br_pd = @set par_br.C = -1.32\nprob_sp = SplitODEProblem(f1, f2, solc0, (0.0, 300.0), par_br_pd)\n# solution close to the PD point.\nsolpd = @time solve(prob_sp, ETDRK2(krylov=true); abstol=1e-14, reltol=1e-14, dt = 0.1)","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"The estimated period is T_pd=62:","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"orbitsectionpd = Array(solpd[:,end-100])\ninitpo_pd = vcat(vec(orbitsectionpd), 6.2)","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"For educational purposes, we show the newton outputs:","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"out_po_sh_pd, _, flag = @time newton(probSh, initpo_pd, par_br_pd , optn; normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", out_po_sh_pd[end], \", amplitude = \", BK.getAmplitude(probSh, out_po_sh_pd, par_br_pd; ratio = 2),\"\\n\")","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"which gives","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     5.2811e-01         0\n        1                2     3.0518e-02        13\n        2                3     6.4500e-03        14\n        3                4     1.8029e-03        13\n        4                5     6.9716e-05        11\n        5                6     6.6815e-07        12\n        6                7     2.6769e-08        14\n        7                8     1.0727e-09        13\n        8                9     4.3002e-11        13\n  6.941868 seconds (3.59 M allocations: 2.286 GiB, 8.26% gc time)\n--> T = 6.126399996979465, amplitude = 1.410164896740365","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"We also compute the branch of periodic orbits using the following command:","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"opts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.005, ds= 0.001, pMin = -1.8, maxSteps = 100, newtonOptions = (@set optn.eigsolver = eig), nev = 5, precisionStability = 1e-3, detectBifurcation = 2)\nbr_po_sh_pd, = @time continuation(probSh, out_po_sh_pd, par_br_pd, (@lens _.C),\n\topts_po_cont; verbosity = 2, plot = true,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicShooting!(x[1:end-1], 1; kwargs...),\n\tprintSolution = (u, p) -> BK.getMaximum(probSh, u, (@set par_br_pd.C = p); ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"and plot it using plot(br_po_sh, br, br_po_sh_pd, label = \"\"):","category":"page"},{"location":"tutorialsPD/#","page":"Period doubling in the Barrio-Varea-Aragon-Maini model","title":"Period doubling in the Barrio-Varea-Aragon-Maini model","text":"(Image: )","category":"page"},{"location":"guidelines/#Guidelines-1","page":"Overview","title":"Guidelines","text":"","category":"section"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"The goal of this package is to find solutions x to nonlinear equations ","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"F(xp) = 0 quadtagE","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"in large dimensions as function of a real parameter p. We want to be able to do so on GPU, distributed systems...","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"The core of the package is built around a Newton-Krylov solver (see newton) which allows to solve equations of the form F(x)=0, or a solution x_0 to (E) for a particular p_0.","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"Once such a solution (or several) (x_0p_0) is known, we can continue it by building a 1d curve of solutions gamma = (x(s)p(s))_sin I passing through (x_0p_0) (see continuation and Deflated Continuation.","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"In practice, you don't need to know exactly (x_0p_0) to compute gamma. Indeed, continuation will call newton to refine any initial guess that you will pass.","category":"page"},{"location":"guidelines/#Bifurcation-analysis-of-Equilibria-1","page":"Overview","title":"Bifurcation analysis of Equilibria","text":"","category":"section"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"We can detect if the curve of solutions gamma crosses another curve of solutions gamma^bif without knowing gamma^bif! The intersection point (x^bp^b)ingamma is called a bifurcation point and is such that partial_xF(x^bp^b) is non invertible. When calling continuation, γ, _ = continuation(...) with the option detectBifurcation > 0 inside ContinuationPar, the bifurcation points are automatically detected and stored in γ.bifpoints.","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"warning: Eigenvalues\nThe rightmost eigenvalues are computed by default to detect bifurcations. Hence, the number of eigenvalues with positive real parts must be finite (e.g. small). This might require to consider -F(xp)=0 instead of (E).","category":"page"},{"location":"guidelines/#Branch-switching-1","page":"Overview","title":"Branch switching","text":"","category":"section"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"In the simple cases, e.g. when dimker partial_xF(x^bp^b) = 1, we can compute automatically the bifurcated branch gamma^bif by calling continuation and passing gamma. This is explained in Branch switching from simple branch point to equilibria. Recursively, we can compute the curves of solutions which are connected to (x_0p_0), this is called a bifurcation diagram. This bifurcation diagram can be automatically computed using the function bifurcationdiagram with minimum input from the user. More information is provided in Automatic Bifurcation diagram computation and examples of use are Swift-Hohenberg equation 1d (Automatic) and Automatic diagram of 2d Bratu–Gelfand problem (Intermediate).","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"When dequiv dimker partial_xF(x^bp^b)  1, you can still compute automatically the bifurcated branches gamma^bifs by calling continuation but note that this is experimental method. It is based on a reduction of (E) to a system of d dimensional multivariate polynomial equations in d unknowns whose solutions gives the local topology of branches in the neighborhood of the bifurcation point (x^b p^b). The solutions of this reduced equation are then used as initial guesses. This is explained in Branch switching from non simple branch point to equilibria and examples of use are shown in A generalized Bratu–Gelfand problem in two dimensions and Automatic diagram of 2d Bratu–Gelfand problem (Intermediate).\t","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"In the case d=1, the reduced equation can be further simplified into a normal form. This is also automatically computed by the package.","category":"page"},{"location":"guidelines/#Bifurcation-analysis-of-Cauchy-problems-1","page":"Overview","title":"Bifurcation analysis of Cauchy problems","text":"","category":"section"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"The goal of this section is to study the dynamics of Cauchy problems","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"fracddtx - F(xp) = 0 quadtagC","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"The equilibria are time independent solutions of (C) hence solving (E). The previous section can be applied to compute curves of equilibria. However, we can do more. By discretizing time, we can recast (C) in the general form (E) and look for time dependent solutions as well. ","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"We can detect the existence of periodic solutions close to gamma. This is done automatically and those bifurcation points are stored in γ.bifpoint as well with the name of Hopf bifurcation points.  ","category":"page"},{"location":"guidelines/#Branch-switching-at-Hopf-points-1","page":"Overview","title":"Branch switching at Hopf points","text":"","category":"section"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"We will not review the bifurcation of equilibria (see above). Therefore, we focus on computing the branch of periodic solutions branching of a Hopf point. This is done automatically by calling again continuation, passing gamma and choosing a time discretization algorithm (see Periodic orbits computation). Some details about this branch switching is given in Branch switching from Hopf point to periodic orbits.","category":"page"},{"location":"guidelines/#Branch-switching-at-bifurcation-points-of-periodic-orbits-1","page":"Overview","title":"Branch switching at bifurcation points of periodic orbits","text":"","category":"section"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"Let us consider the case where a branch of periodic orbits gamma^po have been computed (see for example previous section) and several bifurcation points have been detected (branch point, period doubling and Neimark Sacker). Can we compute bifurcated branches from gamma^po? Automatically?","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"We do not provide an automatic branch switching for those points for all methods (Shooting, Finite differences). However, for branch points of periodic orbits, you can call continuation by passing gamma^po and some simple arguments (amplitude of the periodic orbits) to perform branch switching in a semi-automatic way. For the case of Periodic orbits based on finite differences, see Branch switching from Branch point of curve of periodic orbits.","category":"page"},{"location":"guidelines/#","page":"Overview","title":"Overview","text":"tip: Manual Branch switching\nYou can perform manual branch switching by computing the nearby solutions close to a bifurcation point using a deflated newton (see Deflated problems), which provides a way to compute solutions other than a set of already known solutions.  You can then use these solutions to compute branches by calling continuation. Many, if not all tutorials give example of doing so like A generalized Bratu–Gelfand problem in two dimensions or Brusselator 1d (automatic).","category":"page"},{"location":"mittelmannGridap/#d-Bratu–Gelfand-problem-with-[Gridap.jl](https://github.com/gridap/Gridap.jl)-(Intermediate)-1","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"","category":"section"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"Pages = [\"mittelmannGridap.md\"]\nDepth = 3","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We re-consider the problem of Mittelmann treated in the previous tutorial but using a finite elements method (FEM) implemented in the package Gridap.jl. ","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"Recall that the problem is defined by solving","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"Delta u +NL(lambdau) = 0","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"with Neumann boundary condition on Omega = (01)^2 and where NL(lambdau)equiv-10(u-lambda e^u).","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We start by installing the package GridapBifurcationKit.jl. Then, we can import the different packages:","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"using Revise\nusing Plots, Gridap,Setfield\nusing Gridap.FESpaces\nusing GridapBifurcationKit, BifurcationKit\n\n# custom plot function to deal with Gridap\nplotgridap!(x; k...) = (n=Int(sqrt(length(x)));heatmap!(reshape(x,n,n); color=:viridis, k...))\nplotgridap(x; k...) =( plot();plotgridap!(x; k...))","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We are now ready to specify the problem using the setting of Gridap.jl: it allows to write the equations very closely to the mathematical formulation:","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"@law NL(u) = exp(u)\n\n# residual\nres(u,p,v) = -∇(v)⋅∇(u) -  v ⋅ (u - p.λ * NL(u)) * 10\n\n# jacobian of the residual\njac(u,p,du,v) = -∇(v)⋅∇(du) - v ⋅ du ⋅ (1 - p.λ * NL(u)) * 10\n\n# 3rd and 4th derivatives, used for aBS\nd2res(u,p,du1,du2,v) = v ⋅ du1 ⋅ du2 ⋅ NL(u) * 10 * p.λ\nd3res(u,p,du1,du2,du3,v) = v ⋅ du1 ⋅ du2 ⋅ du3 ⋅ NL(u) * 10 * p.λ\n\n# discretisation\nn = 40\ndomain = (0,1,0,1)\ncells = (n,n)\nmodel = CartesianDiscreteModel(domain,cells)\n\n# function spaces\norder = 1\nV = TestFESpace(\n\tmodel=model,reffe=:Lagrangian,valuetype=Float64,\n\torder=order,conformity=:H1,)#dirichlet_tags=\"boundary\")\nU = TrialFESpace(V)\n\ntrian = Triangulation(model)\ndegree = 2*order\nquad = CellQuadrature(trian,degree)\n\n# example of initial guess\nuh = zero(U)\n\n# model parameter\npar_bratu = (λ = 0.01,)\n\n# problem definition\nprob = GridapProblem(res, jac, d2res, d3res, trian, quad, V, U)","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We can call then the newton solver:","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"optn = NewtonPar(eigsolver = EigArpack())\nsol, = newton(prob, uh, par_bratu, NewtonPar(optn; verbose = true))","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"which gives","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":" Newton Iterations\n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     2.4687e-03         0\n        1                2     1.2637e-07         1\n        2                3     3.3579e-16         1","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"In the same vein, we can continue this solution as function of lambda:","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"opts = ContinuationPar(pMax = 40., pMin = 0.01, ds = 0.01,\n\tmaxSteps = 1000, detectBifurcation = 3, newtonOptions = optn, nev = 20)\nbr, = continuation(prob, uh, par_bratu, (@lens _.λ), opts;\n\tplot = true, verbosity = 2,\n\tplotSolution = (x, p; k...) -> plotgridap!(x;  k...))","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We obtain:","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"julia> br\n Branch number of points: 53\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at p ≈ +0.36782970 ∈ (+0.36782970, +0.36787920), |δp|=5e-05, [converged], δ = ( 1,  0), step =  12, eigenelements in eig[ 13], ind_ev =   1\n- #  2,    nd at p ≈ +0.27168226 ∈ (+0.27168226, +0.27286757), |δp|=1e-03, [converged], δ = ( 2,  0), step =  19, eigenelements in eig[ 20], ind_ev =   3\n- #  3,    bp at p ≈ +0.15186464 ∈ (+0.15186464, +0.15187849), |δp|=1e-05, [converged], δ = ( 1,  0), step =  26, eigenelements in eig[ 27], ind_ev =   4\n- #  4,    nd at p ≈ +0.03484879 ∈ (+0.03484879, +0.03491029), |δp|=6e-05, [converged], δ = ( 2,  0), step =  41, eigenelements in eig[ 42], ind_ev =   6\n- #  5,    nd at p ≈ +0.01556655 ∈ (+0.01556655, +0.01559518), |δp|=3e-05, [converged], δ = ( 2,  0), step =  48, eigenelements in eig[ 49], ind_ev =   8\nFold points:\n- #  1, fold at p ≈ 0.36782970 ∈ (0.36782970, 0.36782970), |δp|=-1e+00, [    guess], δ = ( 0,  0), step =  13, eigenelements in eig[ 13], ind_ev =   0\n\n","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannGridap/#Computation-of-the-first-branches-1","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"Computation of the first branches","text":"","category":"section"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"Let us now compute the first branches from the bifurcation points. We start with the one with 1d kernel:","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"br1, = continuation(prob, br, 3,\n\tsetproperties(opts;ds = 0.001, dsmax = 0.05, maxSteps = 140, detectBifurcation = 3);\n\tverbosity = 0, plot = true, nev = 10,\n\ttangentAlgo = BorderedPred(),\n\tusedeflation = true,\n\tplotSolution = (x, p; k...) -> plotgridap!(x;  k...))","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We also compute the branch from the first bifurcation point on this branch br1:","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"br2, = continuation(prob, br1, 1,\n\tsetproperties(opts;ds = 0.005, dsmax = 0.05, maxSteps = 140, detectBifurcation = 0);\n\tverbosity = 0, plot = true, nev = 10,\n\ttangentAlgo = BorderedPred(),\n\tusedeflation = true,\n\tplotSolution = (x, p; k...) -> plotgridap!(x;  k...))\n\nplot(br, br1, br2)","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"We get:","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"Finally, we compute the branches from the 2d bifurcation point:","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"br3, = continuation(prob, br, 2,\n\tsetproperties(opts;ds = 0.005, dsmax = 0.05, maxSteps = 140, detectBifurcation = 3);\n\tverbosity = 0, plot = true, nev = 10,\n\tusedeflation = true,\n\tplotSolution = (x, p; k...) -> plotgridap!(x;  k...))\n\nplot(br, br1, br2, br3...)","category":"page"},{"location":"mittelmannGridap/#","page":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","title":"2d Bratu–Gelfand problem with Gridap.jl (Intermediate)","text":"(Image: )","category":"page"},{"location":"BifurcationDiagram/#Automatic-Bifurcation-diagram-computation-1","page":"Bifurcation diagram","title":"Automatic Bifurcation diagram computation","text":"","category":"section"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"info: Experimental\nThis feature is still experimental. It has not been tested thoroughly.","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"Thanks to the functionality presented in this part, we can compute the bifurcation diagram of a system recursively and fully automatically. More precisely, the function bifurcationdiagram allows to:","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"compute a branch gamma of equilibria\ndetect all bifurcations on the branch\nrecursively compute the branches emanating from branch points on gamma.","category":"page"},{"location":"BifurcationDiagram/#Pitfalls-1","page":"Bifurcation diagram","title":"Pitfalls","text":"","category":"section"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"For now, there is no way to decide if two branches gamma_1gamma_2 are the same. As a consequence:","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"there is no loop detection. Hence, if the branch gamma has a component akin to a circle, you may experience a large number of branches\nif the bifurcation diagram itself has loops (see example below), you may experience a large number of branches","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"warning: Memory\nThe whole diagram is stored in RAM and you might be careful computing it on GPU. We'll add a file system for this in the future. ","category":"page"},{"location":"BifurcationDiagram/#Basic-example-with-simple-branch-points-1","page":"Bifurcation diagram","title":"Basic example with simple branch points","text":"","category":"section"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using Revise, Plots\nusing BifurcationKit, Setfield, ForwardDiff\nconst BK = BifurcationKit\n\nfunction FbpSecBif(u, p)\n\treturn @. -u * (p + u * (2-5u)) * (p -.15 - u * (2+20u))\nend\n\nD(f, x, p, dx) = ForwardDiff.derivative(t -> f(x .+ t .* dx, p), 0.)\ndFbpSecBif(x,p)         =  ForwardDiff.jacobian( z-> FbpSecBif(z,p), x)\nd1FbpSecBif(x,p,dx1)         = D((z, p0) -> FbpSecBif(z, p0), x, p, dx1)\nd2FbpSecBif(x,p,dx1,dx2)     = D((z, p0) -> d1FbpSecBif(z, p0, dx1), x, p, dx2)\nd3FbpSecBif(x,p,dx1,dx2,dx3) = D((z, p0) -> d2FbpSecBif(z, p0, dx1, dx2), x, p, dx3)\njet = (FbpSecBif, dFbpSecBif, d2FbpSecBif, d3FbpSecBif)\n\n# options for Krylov-Newton\nopt_newton = NewtonPar(tol = 1e-9, verbose = false, maxIter = 20)\n# options for continuation\nopts_br = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds = 0.01, pMax = 0.4, pMin = -0.5, detectBifurcation = 3, nev = 2, newtonOptions = opt_newton, maxSteps = 100, nInversion = 4, tolBisectionEigenvalue = 1e-8, dsminBisection = 1e-9)\n\ndiagram = bifurcationdiagram(jet..., \n\t# initial point and parameter\n\t[0.0], -0.2, \n\t# specify the continuation parameter\n\t(@lens _), \n\t# very important parameter. This specifies the maximum amount of recursion\n\t# when computing the bifurcation diagram. It means we allow computing branches of branches \n\t# at most in the present case.\n\t2,\n\t(args...) -> setproperties(opts_br; pMin = -1.0, pMax = .3, ds = 0.001, dsmax = 0.005, nInversion = 8, detectBifurcation = 3,dsminBisection =1e-18, tolBisectionEigenvalue=1e-11, maxBisectionSteps=20, newtonOptions = (@set opt_newton.verbose=false));\n\tprintSolution = (x, p) -> x[1])","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"This gives","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"julia> diagram\nBifurcation diagram. Root branch (level 1) has 4 children and is such that:\nBranch number of points: 76\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,      bp point around p ≈ 0.00000281, step =  31, eigenelements in eig[ 32], ind_ev =   1 [converged], δ = ( 1,  0)\n- #  2,      bp point around p ≈ 0.15000005, step =  53, eigenelements in eig[ 54], ind_ev =   1 [converged], δ = (-1,  0)","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"You can plot the diagram like plot(bdiag; putbifptlegend=false, markersize=2, plotfold=false, title = \"#branches = $(size(bdiag))\") and it gives:","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"(Image: )","category":"page"},{"location":"BifurcationDiagram/#Example-with-nonsimple-branch-points-1","page":"Bifurcation diagram","title":"Example with nonsimple branch points","text":"","category":"section"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"To show the ability of the branch switching method to cope with non simple branch points, we look at the normal form of the Pitchfork with D6 symmetry which occurs frequently in problems with hexagonal symmetry. You may want to look at Automatic diagram of 2d Bratu–Gelfand problem (Intermediate) for a non trivial example of use.","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using Revise, Plots\nusing BifurcationKit, Setfield, ForwardDiff, LinearAlgebra\nconst BK = BifurcationKit\nnorminf = x -> norm(x, Inf)\n\nfunction FbpD6(x, p)\n\treturn [ p.μ * x[1] + (p.a * x[2] * x[3] - p.b * x[1]^3 - p.c*(x[2]^2 + x[3]^2) * x[1]),\n\t\t\t p.μ * x[2] + (p.a * x[1] * x[3] - p.b * x[2]^3 - p.c*(x[3]^2 + x[1]^2) * x[2]),\n\t\t\t p.μ * x[3] + (p.a * x[1] * x[2] - p.b * x[3]^3 - p.c*(x[2]^2 + x[1]^2) * x[3])]\nend\n\n# computation of the differentials\nD(f, x, p, dx) = ForwardDiff.derivative(t -> f(x .+ t .* dx, p), 0.)\nd1FbpD6(x,p,dx1) = D((z, p0) -> FbpD6(z, p0), x, p, dx1)\nd2FbpD6(x,p,dx1,dx2)     = D((z, p0) -> d1FbpD6(z, p0, dx1), x, p, dx2)\nd3FbpD6(x,p,dx1,dx2,dx3) = D((z, p0) -> d2FbpD6(z, p0, dx1, dx2), x, p, dx3)\n\njet = (FbpD6, (x, p) -> ForwardDiff.jacobian(z -> FbpD6(z, p), x), d2FbpD6, d3FbpD6)\n\npard6 = (μ = -0.2, a = 0.3, b = 1.5, c = 2.9)\n\n# newton options\nopt_newton = NewtonPar(tol = 1e-9, maxIter = 20)\n# continuation options\nopts_br = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds = 0.01, pMax = 0.4, pMin = -0.5, detectBifurcation = 2, nev = 2, newtonOptions = opt_newton, maxSteps = 100, nInversion = 4, tolBisectionEigenvalue = 1e-8, dsminBisection = 1e-9)\n\nbdiag = bifurcationdiagram(jet..., zeros(3), pard6, (@lens _.μ), 3,\n\t(args...) -> setproperties(opts_br; pMin = -0.250, pMax = .4, ds = 0.001, dsmax = 0.005, nInversion = 4, detectBifurcation = 3, dsminBisection =1e-18, tolBisectionEigenvalue=1e-11, maxBisectionSteps=20, newtonOptions = (@set opt_newton.verbose=false));\n\tprintSolution = (x, p) -> norminf(x),\n\tplot = false, verbosity = 0, normC = norminf)","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"We can now plot the result:","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"plot(bdiag; putbifptlegend=false, markersize=2,plotfold=false);title!(\"#branch = $(size(bdiag))\")","category":"page"},{"location":"BifurcationDiagram/#","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"(Image: )","category":"page"},{"location":"periodicOrbitFD/#Periodic-orbits-based-on-finite-differences-1","page":"Finite Differences","title":"Periodic orbits based on finite differences","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"We have implemented a method where we compute M slices of a periodic orbit. This is done by the structure PeriodicOrbitTrapProblem for which the problem of finding periodic orbits is discretized using Finite Differences based on a trapezoidal rule. ","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"unknown: References\nThe general method is very well exposed in Hopf Bifurcation and Time Periodic Orbits with Pde2path – Algorithms and Applications., Uecker, Hannes, Communications in Computational Physics 25, no. 3 (2019) and in the PhD thesis Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust, Kurt, 1997. We adopt the notations of the first reference.","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"We look for periodic orbits as solutions (x(0)T) of","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"dot x = Tcdot F(x) x(0)=x(1)","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"In order to have a unique solution, we need to remove the phase freedom. This is done by imposing a phase condition x(0)-x_piphi = 0 for some x_piphi which are chosen (wisely).","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"By discretizing the above problem, we obtain","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"beginarrayl\n0= left(x_j-x_j-1right)-frach2 left(Fleft(x_jright)+Fleft(x_j-1right)right)equiv G_j(x)quad j=1cdotsm-1  \n0= x_m-x_1 equiv G_m(x) \n0= x_1-x_piphi\nendarray","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"where x_0=x_m and h=Tm. The Jacobian of the system of equations w.r.t. (x_0T) is given by ","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"mathcalJ=left(beginarrayccA_1  partial_TG  star  dendarrayright)","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"where ","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"A_gamma=left(beginarrayccccccc\nM_1  0  0  0  cdots  -H_1  0  \n-H_2  M_2  0  0  cdots  0  0  \n0  -H_3  M_3  0  cdots  0  0  \nvdots  cdots  ddots  ddots  ddots  vdots  vdots  \n0  cdots  cdots  ddots  ddots  0  0  \n0  cdots  cdots  0  -H_m-1  M_m-1  0  \n-gamma I  0  cdots  cdots  cdots  0  I\nendarrayright)","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"with M_i = I-\tfrac h2partial_uF(x_i) and H_i = I+frac h2partial_uF(x_i-1).","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"We solve the linear equation mathcal Jcdot sol = rhs with a bordering strategy (i.e. the linear solver is a subtype of <: AbstractBorderedLinearSolver) which in turn requires to solve A_gamma z=b where z=(xx_m). We also solve this equation with a bordering strategy but this time, it can be simplified as follows. If we write b=(fg), one gets J_c x=f and x_m=g+gamma x_1 where x_1 is the first time slice of x and J_c is the following cyclic matrix:","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"J_c=left(beginarrayccccccc\nM_1  0  0  0  cdots  -H_1  \n-H_2  M_2  0  0  cdots  0  \n0  -H_3  M_3  0  cdots  0  \nvdots  cdots  ddots  ddots  ddots  vdots  \n0  cdots  cdots  ddots  ddots  0  \n0  cdots  cdots  0  -H_m-1  M_m-1  \nendarrayright)","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"Our code thus provides methods to invert J_c and A_gamma using a sparse solver or a Matrix-Free solver. A preconditioner can be used. ","category":"page"},{"location":"periodicOrbitFD/#Encoding-of-the-functional-1","page":"Finite Differences","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"The functional is encoded in the composite type PeriodicOrbitTrapProblem. See the link for more information, in particular on how to access the underlying functional, its jacobian and other matrices related to it like A_gamma J_c...","category":"page"},{"location":"periodicOrbitFD/#Preconditioning-1","page":"Finite Differences","title":"Preconditioning","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"We strongly advise you to use a preconditioner to deal with the above linear problem. See Complex Ginzburg-Landau 2d for an example.","category":"page"},{"location":"periodicOrbitFD/#Floquet-multipliers-computation-1","page":"Finite Differences","title":"Floquet multipliers computation","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"A not very precise algorithm for computing the Floquet multipliers is provided. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations of periodic orbits. It seems to work reasonably well for the tutorials considered here. For more information, have a look at FloquetQaDTrap.","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"note: Algorithm\nA more precise algorithm, based on the periodic Schur decomposition will be implemented in the future.","category":"page"},{"location":"periodicOrbitFD/#Computation-with-newton-1","page":"Finite Differences","title":"Computation with newton","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"We provide a simplified call to newton to locate the periodic orbits. Compared to the regular newton function, there is an additional option linearalgo to select one of the many ways to deal with the above linear problem. The default solver linearalgo is :BorderedLU.","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"Have a look at the Continuation of periodic orbits (Finite differences) example for the Brusselator for a basic example and at Complex Ginzburg-Landau 2d for a more advanced one. ","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"The docs for this specific newton are located at newton.","category":"page"},{"location":"periodicOrbitFD/#Computation-with-newton-and-deflation-1","page":"Finite Differences","title":"Computation with newton and deflation","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"We also provide a simplified call to newton to locate the periodic orbit with a deflation operator. ","category":"page"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"newton(probPO::PeriodicOrbitTrapProblem, orbitguess, par0, options::NewtonPar, defOp::DeflationOperator, linearalgo::Symbol; kwargs...)","category":"page"},{"location":"periodicOrbitFD/#Continuation-1","page":"Finite Differences","title":"Continuation","text":"","category":"section"},{"location":"periodicOrbitFD/#","page":"Finite Differences","title":"Finite Differences","text":"Have a look at the Continuation of periodic orbits (Finite differences) example for the Brusselator. We refer to continuation for more information regarding the arguments.","category":"page"},{"location":"tutorials1/#Temperature-model-(simplest-example-for-equilibria)-1","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"","category":"section"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"Pages = [\"tutorials1.md\"]\nDepth = 3","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"This is a classical example from the Trilinos library.","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"This is a simple example in which we aim at solving Delta T+alpha N(Tbeta)=0 with boundary conditions T(0) = T(1)=beta. This example is coded in examples/chan.jl. We start with some imports:","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"using BifurcationKit, LinearAlgebra, Plots, Parameters, Setfield\n# Setfield.jl is used to provide the parameter axis @lens\nconst BK = BifurcationKit\n\nN(x; a = 0.5, b = 0.01) = 1 + (x + a*x^2)/(1 + b*x^2)","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"We then write our functional:","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"function F_chan(x, p)\n\t@unpack α, β = p\n\tf = similar(x)\n\tn = length(x)\n\tf[1] = x[1] - β\n\tf[n] = x[n] - β\n\tfor i=2:n-1\n\t\tf[i] = (x[i-1] - 2 * x[i] + x[i+1]) * (n-1)^2 + α * N(x[i], b = β)\n\tend\n\treturn f\nend\t","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"We want to call a Newton solver. We first need an initial guess:","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"n = 101\nsol = [(i-1)*(n-i)/n^2+0.1 for i=1:n]\n\n# set of parameters\npar = (α = 3.3, β = 0.01)","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"Finally, we need to provide some parameters for the Newton iterations. This is done by calling","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"optnewton = NewtonPar(tol = 1e-11, verbose = true)","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"We call the Newton solver:","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"out, = @time newton( F_chan, sol, par, optnewton)","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"and you should see","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     2.3440e+01         0\n        1                2     1.3774e+00         1\n        2                3     1.6267e-02         1\n        3                4     2.4521e-06         1\n        4                5     5.9356e-11         1\n        5                6     5.8117e-12         1\n  0.015303 seconds (3.00 k allocations: 2.557 MiB)","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"Note that, in this case, we did not give the Jacobian. It was computed internally using Finite Differences. ","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"This is not as bad as it looks despite the fact that there are so many allocations even with Finite Differences Jacobian. Using BenchmarkTools.jl, one actually finds 1.153 ms (2067 allocations: 2.04 MiB). This is reasonable as we did not code the problem with much care...","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"We can perform numerical continuation w.r.t. the parameter alpha. This time, we need to provide additional parameters, but now for the continuation method:","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"optcont = ContinuationPar(dsmin = 0.01, dsmax = 0.2, ds= 0.1, pMax = 4.1, newtonOptions = NewtonPar(tol = 1e-8))","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"Next, we call the continuation routine as follows.","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"br, = @time continuation(F_chan, out, par, (@lens _.α),\n\t\toptcont; plot = true, verbosity = 0,\n\t\t# function to plot the solution\n\t\tplotSolution = (x, p; k...) -> plot!(x; ylabel=\"solution\", label=\"\", k...))","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"The parameter axis lens = @lens _.α can be used to extract the component of par corresponding to α. Internally, it is used as get(par, lens) which returns 3.3.","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"tip: Tip\nWe don't need to call newton first in order to use continuation.","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"You should see (Image: )","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"The left figure is the norm of the solution as function of the parameter p=alpha, the y-axis can be changed by passing a different printSolution to continuation. The top right figure is the value of alpha as function of the iteration number. The bottom right is the solution for the current value of the parameter. This last plot can be modified by changing the argument plotSolution to continuation.","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"note: Bif. point detection\nTwo Fold points were detected. This can be seen by looking at br.foldpoint or by the black \tdots on the continuation plots. Note that the bifurcation points are located in br.bifpoint.","category":"page"},{"location":"tutorials1/#Continuation-of-Fold-points-1","page":"Temperature model (simplest example for equilibria)","title":"Continuation of Fold points","text":"","category":"section"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"We get a summary of the branch by doing","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"julia> br\nBranch number of points: 78\nBranch of Equilibrium\nFold points:\n- #  1,    fold at p ≈ 4.03926020, step =   6, eigenelements in eig[  6], ind_ev =   0 [    guess]\n- #  2,    fold at p ≈ 3.15599445, step =  24, eigenelements in eig[ 24], ind_ev =   0 [    guess]","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"We can take the first Fold point, which has been guessed during the previous continuation run and locate it precisely. However, this only works well when the jacobian is computed analytically. We use automatic differentiation for that","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"using ForwardDiff\n\n# Jacobian of F_chan\nJac_mat = (x,p) -> ForwardDiff.jacobian(z -> F_chan(z,p),x)\n\n# index of the Fold bifurcation point in br.bifpoint\nindfold = 2\n\noutfold, _, flag = newton(F_chan, Jac_mat,\n\t#index of the fold point\n\tbr, indfold, \n\t# set of parameters and parameter axis to locate the fold\n\tpar, (@lens _.α))\nflag && printstyled(color=:red, \"--> We found a Fold Point at α = \", outfold.p, \", β = 0.01, from \", br.foldpoint[indfold].param,\"\\n\")","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"which gives","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"--> We found a Fold Point at α = 3.1556507316107947, β = 0.01, from 3.155651011218501","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"We can finally continue this fold point in the plane (ab) by performing a Fold Point continuation. In the present case, we find a Cusp point.","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"tip: Tip\nWe don't need to call newton first in order to use continuation for the codim 2 curve of bifurcation points.","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"optcontfold = ContinuationPar(dsmin = 0.001, dsmax = 0.05,ds= 0.01, pMax = 4.1, pMin = 0.)\n\toutfoldco, _, _ = @time continuation(\n\t\tF_chan, Jac_mat,\n\t\tbr, indfold, \n\t\t# set of parameters and 2 parameter axis to trace to codim 2 curve\n\t\tpar, (@lens _.α), (@lens _.β),\n\t\tplot = true, verbosity = 2, optcontfold)\nplot(outfoldco; xlabel=\"beta\", ylabel=\"alpha\")","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"This produces:","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"(Image: )","category":"page"},{"location":"tutorials1/#Using-GMRES-or-another-linear-solver-1","page":"Temperature model (simplest example for equilibria)","title":"Using GMRES or another linear solver","text":"","category":"section"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"We continue the previous example but now using Matrix Free methods. The user can pass its own solver by implementing a version of LinearSolver. Some linear solvers have been implemented from KrylovKit.jl and IterativeSolvers.jl (see Linear solvers for more information), we can use them here. Note that we can also use preconditioners as shown below. The same functionality is present for the eigensolver.","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"# derivative of N\ndN(x; a = 0.5, b = 0.01) = (1-b*x^2+2*a*x)/(1+b*x^2)^2\n\n# Matrix Free version of the differential of F_chan\n# Very easy to write since we have F_chan. \n# We could use Automatic Differentiation as well\nfunction dF_chan(x, dx, p)\n\t@unpack α, β = p\n\tout = similar(x)\n\tn = length(x)\n\tout[1] = dx[1]\n\tout[n] = dx[n]\n\tfor i=2:n-1\n\t\tout[i] = (dx[i-1] - 2 * dx[i] + dx[i+1]) * (n-1)^2 + α * dN(x[i], b = β) * dx[i]\n\tend\n\treturn out\nend\n\n# we create a new linear solver\nls = GMRESKrylovKit(dim = 100)\n\n# and pass it to the newton parameters\noptnewton_mf = NewtonPar(verbose = true, linsolver = ls)\n\n# we can then call the newton solver\nout_mf, _, _ = @time newton(\n\tF_chan,\n\t# we pass the differential a x, \n\t# which is a linear operator in dx\n\t(x, p) -> (dx -> dF_chan(x, dx, p)),\n\tsol, par,\n\toptnewton_mf)","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"which gives:","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     2.3440e+01         0\n        1                2     1.3774e+00        68\n        2                3     1.6267e-02        98\n        3                4     2.4336e-06        73\n        4                5     6.2617e-12        73\n\t0.323253 seconds (1.07 M allocations: 50.779 MiB)","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"We can improve this computation, i.e. reduce the number of Linear-Iterations, by using a preconditioner","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"using SparseArrays\n\n# define preconditioner which is basically Δ\nP = spdiagm(0 => -2 * (n-1)^2 * ones(n), -1 => (n-1)^2 * ones(n-1), 1 => (n-1)^2 * ones(n-1))\nP[1,1:2] .= [1, 0.];P[end,end-1:end] .= [0, 1.]\n\n# define gmres solver with left preconditioner\nls = GMRESIterativeSolvers(tol = 1e-4, N = length(sol), restart = 10, maxiter = 10, Pl = lu(P))\n\toptnewton_mf = NewtonPar(verbose = true, linsolver = ls)\n\tout_mf, _, _ = @time newton(F_chan,\n\t(x, p) -> (dx -> dF_chan(x, dx, p)),\n\tsol, par, optnewton_mf)","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":"which gives","category":"page"},{"location":"tutorials1/#","page":"Temperature model (simplest example for equilibria)","title":"Temperature model (simplest example for equilibria)","text":" Newton Iterations\n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     2.3440e+01         0\n        1                2     1.3777e+00         3\n        2                3     1.6266e-02         3\n        3                4     2.3699e-05         2\n        4                5     4.8930e-09         3\n        5                6     6.3288e-12         4","category":"page"},{"location":"tutorialsCGL/#Complex-Ginzburg-Landau-2d-1","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Pages = [\"tutorialsCGL.md\"]\nDepth = 3","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"This example is also treated in the MATLAB library pde2path.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We look at the Ginzburg-Landau equations in 2d. The code is very similar to the Brusselator example except that some special care has to be taken in order to cope with the \"high\" dimensionality of the problem.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Note that we try to be pedagogical here. Hence, we may write \"bad\" code that we improve later. Finally, we could use all sort of tricks to take advantage of the specificity of the problem. Rather, we stay quite close to the example in the MATLAB library pde2path (and discussed in Hopf Bifurcation and Time Periodic Orbits with Pde2path – Algorithms and Applications., Uecker, Hannes, Communications in Computational Physics 25, no. 3 (2019)) for fair comparison.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"info: Goal\nWe do not use automatic branch switching here. The goal is to show our to use the internals of the package to squeeze most of the performances, use tailored options...","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"The equations are as follows","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"partial_t u=Delta u+(r+mathrmi v) u-left(c_3+mathrmi muright)u^2 u-c_5u^4 u quad u=u(t x) in mathbbC","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"with Dirichlet boundary conditions. We discretize the square Omega = (0L_x)times(0L_y) with 2N_xN_y points. We start by writing the Laplacian:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"using Revise\nusing DiffEqOperators, ForwardDiff\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield\nconst BK = BifurcationKit\n\nnorminf = x -> norm(x, Inf)\n\nfunction Laplacian2D(Nx, Ny, lx, ly)\n\thx = 2lx/Nx; hy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\n\tQx = Dirichlet0BC(typeof(hx))\n\tQy = Dirichlet0BC(typeof(hy))\n\t\n\tD2xsp = sparse(D2x * Qx)[1]\n\tD2ysp = sparse(D2y * Qy)[1]\n\t\n\tA = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))\n\treturn A\nend","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"It is then straightforward to write the vector field","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"# this encodes the nonlinearity\nfunction NL(u, p)\n\t@unpack r, μ, ν, c3, c5 = p\n\tn = div(length(u), 2)\n\tu1 = @view u[1:n]\n\tu2 = @view u[n+1:2n]\n\n\tua = u1.^2 .+ u2.^2\n\n\tf = similar(u)\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@. f1 .= r * u1 - ν * u2 - ua * (c3 * u1 - μ * u2) - c5 * ua^2 * u1\n\t@. f2 .= r * u2 + ν * u1 - ua * (c3 * u2 + μ * u1) - c5 * ua^2 * u2\n\n\treturn f\nend\n\nfunction Fcgl(u, p)\n\tf = similar(u)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\nend","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"and its jacobian:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"function Jcgl(u, p)\n\t@unpack r, μ, ν, c3, c5, Δ = p\n\n\tn = div(length(u), 2)\n\tu1 = @view u[1:n]\n\tu2 = @view u[n+1:2n]\n\n\tua = u1.^2 .+ u2.^2\n\n\tf1u = zero(u1)\n\tf2u = zero(u1)\n\tf1v = zero(u1)\n\tf2v = zero(u1)\n\n\t@. f1u =  r - 2 * u1 * (c3 * u1 - μ * u2) - c3 * ua - 4 * c5 * ua * u1^2 - c5 * ua^2\n\t@. f1v = -ν - 2 * u2 * (c3 * u1 - μ * u2)  + μ * ua - 4 * c5 * ua * u1 * u2\n\t@. f2u =  ν - 2 * u1 * (c3 * u2 + μ * u1)  - μ * ua - 4 * c5 * ua * u1 * u2\n\t@. f2v =  r - 2 * u2 * (c3 * u2 + μ * u1) - c3 * ua - 4 * c5 * ua * u2 ^2 - c5 * ua^2\n\n\tjacdiag = vcat(f1u, f2v)\n\n\tΔ + spdiagm(0 => jacdiag, n => f1v, -n => f2u)\nend","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We now define the parameters and the stationary solution:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Nx = 41\nNy = 21\nn = Nx * Ny\nlx = pi\nly = pi/2\n\nΔ = Laplacian2D(Nx, Ny, lx, ly)\npar_cgl = (r = 0.5, μ = 0.1, ν = 1.0, c3 = -1.0, c5 = 1.0, Δ = blockdiag(Δ, Δ))\nsol0 = zeros(2Nx, Ny)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"and we continue it to find the Hopf bifurcation points. We use a Shift-Invert eigensolver.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"# Shift-Invert eigensolver\neigls = EigArpack(1.0, :LM) # shift = 1.0\nopt_newton = NewtonPar(tol = 1e-10, verbose = true, eigsolver = eigls)\nopts_br = ContinuationPar(dsmin = 0.001, dsmax = 0.005, ds = 0.001, pMax = 2., detectBifurcation = 3, nev = 5, plotEveryStep = 50, newtonOptions = opt_newton, maxSteps = 1060)\n\nbr, = @time continuation(Fcgl, Jcgl, vec(sol0), par_cgl, (@lens _.r), opts_br, verbosity = 0)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"which gives","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Branch number of points: 216\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,  hopf at p ≈ +1.14777610 ∈ (+1.14766562, +1.14777610), |δp|=1e-04, [converged], δ = ( 2,  2), step =  94, eigenelements in eig[ 95], ind_ev =   2\n- #  2,  hopf at p ≈ +1.86107007 ∈ (+1.86018618, +1.86107007), |δp|=9e-04, [converged], δ = ( 2,  2), step = 195, eigenelements in eig[196], ind_ev =   4","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/#Normal-form-computation-1","page":"Complex Ginzburg-Landau 2d","title":"Normal form computation","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We compute the Hopf normal form of the first bifurcation point.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"using ForwardDiff\n\nD(f, x, p, dx)= ForwardDiff.derivative(t->f(x .+ t .* dx, p), 0.)\n\nd1Fcgl(x,p,dx) = D(Fcgl, x, p, dx)\nd2Fcgl(x,p,dx1,dx2) = D((z, p0) -> d1Fcgl(z, p0, dx1), x, p, dx2)\nd3Fcgl(x,p,dx1,dx2,dx3) = D((z, p0) -> d2Fcgl(z, p0, dx1, dx2), x, p, dx3)\njet = (Fcgl, Jcgl, d2Fcgl, d3Fcgl)\n\nhopfpt = BK.computeNormalForm(jet..., br, 1)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We can look at the coefficients of the normal form","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"julia> hopfpt.nf\nSubCritical - Hopf bifurcation point at p ≈ 1.1477761028276166.\nNormal form : (a = 0.9999993820432533 - 8.207477617340401e-9im, b = 0.004870129870129869 + 0.0004870129870129865im)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"So the Hopf branch is subcritical.","category":"page"},{"location":"tutorialsCGL/#Periodic-orbits-continuation-with-stability-1","page":"Complex Ginzburg-Landau 2d","title":"Periodic orbits continuation with stability","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Having found two Hopf bifurcation points, we aim at computing the periodic orbits branching from them. Like for the Brusselator example, we need to find some educated guess for the periodic orbits in order to have a successful Newton call.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"The following code is very close to the one explained in the tutorial Brusselator 1d (advanced user) so we won't give too much details here.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We focus on the first Hopf bifurcation point. Note that, we do not improve the guess for the Hopf bifurcation point, e.g. by calling newtonHopf, as this is not really needed.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"# index of the Hopf point we want to branch from\nind_hopf = 1\n\n# number of time slices in the periodic orbit\nM = 30\n\n# periodic orbit initial guess from Hopf point\nr_hopf, Th, orbitguess2, hopfpt, eigvec = guessFromHopf(br, ind_hopf, opt_newton.eigsolver,\n\t# we pass the number of time slices M, the amplitude 22*sqrt(0.1) and phase\n\tM, 22*sqrt(0.1); phase = 0.25)\n\n# flatten the initial guess\norbitguess_f2 = reduce(hcat, orbitguess2)\norbitguess_f = vcat(vec(orbitguess_f2), Th) |> vec","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We create a problem to hold the functional and compute periodic orbits based on Finite Differences","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"poTrap = PeriodicOrbitTrapProblem(\n# vector field and sparse Jacobian\t\n\tFcgl, Jcgl,\n# parameters for the phase condition\n\treal.(eigvec),\n\thopfpt.u,\n# number of time slices\t\n\tM)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We can use this (family) problem poTrap with newton on our periodic orbit guess to find a periodic orbit. Hence, one can be tempted to use","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"danger: Don't run this!!\nIt uses too much memory opts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.03, ds= 0.001, pMax = 2.5, \t maxSteps = 250, plotEveryStep = 3, newtonOptions = (@set opt_po.linsolver = DefaultLS()))\nbr_po, upo, = @time continuation(Fcgl, Jcgl, vec(sol0), par_cgl, (@lens _.r), opts_po_cont)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"However, the linear system associated to the newton iterations will be solved by forming the sparse jacobian of size (2N_xN_yM+1)^2 and the use of \\ (based on LU decomposition). It takes way too much time and memory.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Instead, we use a preconditioner. We build the jacobian once, compute its incomplete LU decomposition (ILU) and use it as a preconditioner.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"using IncompleteLU\n\n# Sparse matrix representation of the jacobian of the periodic orbit functional\nJpo = poTrap(Val(:JacFullSparse), orbitguess_f, @set par_cgl.r = r_hopf - 0.01)\n\n# incomplete LU factorization with threshold\nPrecilu = @time ilu(Jpo, τ = 0.005)\n\n# we define the linear solver with left preconditioner Precilu\nls = GMRESIterativeSolvers(verbose = false, tol = 1e-3, N = size(Jpo,1), restart = 40, maxiter = 50, Pl = Precilu, log=true)\n\n# we try the linear solver\nls(Jpo, rand(ls.N))","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"This converges in 7 iterations whereas, without the preconditioner, it does not converge after 100 iterations. ","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We set the parameters for the newton solve.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"opt_po = @set opt_newton.verbose = true\noutpo_f, _, flag = @time newton(poTrap,\n   orbitguess_f, (@set par_cgl.r = r_hopf - 0.01),\n   (@set opt_po.linsolver = ls); \n   linearPO = :FullMatrixFree, normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", outpo_f[end], \", amplitude = \", BK.getAmplitude(poTrap, outpo_f, par_cgl; ratio = 2),\"\\n\")\nBK.plotPeriodicPOTrap(outpo_f, M, Nx, Ny; ratio = 2);","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"which gives ","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     6.5412e-03         0\n        1                2     1.4399e-03         8\n        2                3     3.6404e-04         9\n        3                4     6.3013e-05        10\n        4                5     4.3207e-06        11\n        5                6     3.5334e-08        12\n        6                7     1.0874e-10        13\n        7                8     4.4353e-14        15\n  2.021483 seconds (136.39 k allocations: 1.329 GiB, 8.33% gc time)\n--> T = 6.532023020978835, amplitude = 0.2684635643839235","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"and","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"At this point, we are still wasting a lot of resources, because the matrix-free version of the jacobian of the functional uses the jacobian of the vector field x ->  Jcgl(x, p). Hence, it builds M sparse matrices for each evaluation!! Let us create a problem which is fully Matrix Free:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"# computation of the first derivative using automatic differentiation\nd1Fcgl(x, p, dx) = ForwardDiff.derivative(t -> Fcgl(x .+ t .* dx, p), 0.)\n\n# linear solver for solving Jcgl*x = rhs. Needed for Floquet multipliers computation\nls0 = GMRESIterativeSolvers(N = 2Nx*Ny, tol = 1e-9, Pl = lu(I + par_cgl.Δ))\n\n# matrix-free problem\npoTrapMF = PeriodicOrbitTrapProblem(\n\tFcgl,\t(x, p) ->  (dx -> d1Fcgl(x, p, dx)),\n\treal.(eigvec),\n\thopfpt.u,\n\tM, ls0)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We can now use newton","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"outpo_f, _, flag = @time newton(poTrapMF,\n\torbitguess_f, (@set par_cgl.r = r_hopf - 0.01),\n\t(@set opt_po.linsolver = ls); \n\tlinearPO = :FullMatrixFree, normN = norminf)\nflag && printstyled(color=:red, \"--> T = \", outpo_f[end], \", amplitude = \", BK.getAmplitude(poTrapMF, outpo_f, par_cgl; ratio = 2),\"\\n\")","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"which gives ","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     6.5412e-03         0\n        1                2     1.4399e-03         8\n        2                3     3.6404e-04         9\n        3                4     6.3013e-05        10\n        4                5     4.3207e-06        11\n        5                6     3.5334e-08        12\n        6                7     1.0874e-10        13\n        7                8     4.4471e-14        15\n  1.446924 seconds (28.68 k allocations: 486.953 MiB, 6.45% gc time)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"The speedup will increase a lot for larger N_x N_y. Also, for Floquet multipliers computation, the speedup will be substantial.","category":"page"},{"location":"tutorialsCGL/#Removing-most-allocations-(Advanced-and-Experimental)-1","page":"Complex Ginzburg-Landau 2d","title":"Removing most allocations (Advanced and Experimental)","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We show here how to remove most allocations and speed up the computations. This is an experimental feature as the Floquet multipliers computation is not yet readily available in this case. To this end, we rewrite the functional using inplace formulation and trying to avoid allocations. This can be done as follows:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"# compute just the nonlinearity\nfunction NL!(f, u, p, t = 0.)\n\t@unpack r, μ, ν, c3, c5 = p\n\tn = div(length(u), 2)\n\tu1v = @view u[1:n]\n\tu2v = @view u[n+1:2n]\n\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@inbounds for ii = 1:n\n\t\tu1 = u1v[ii]\n\t\tu2 = u2v[ii]\n\t\tua = u1^2+u2^2\n\t\tf1[ii] = r * u1 - ν * u2 - ua * (c3 * u1 - μ * u2) - c5 * ua^2 * u1\n\t\tf2[ii] = r * u2 + ν * u1 - ua * (c3 * u2 + μ * u1) - c5 * ua^2 * u2\n\tend\n\treturn f\nend\n\n# derivative of the nonlinearity\nfunction dNL!(f, u, p, du)\n\t@unpack r, μ, ν, c3, c5 = p\n\tn = div(length(u), 2)\n\tu1v = @view u[1:n]\n\tu2v = @view u[n+1:2n]\n\n\tdu1v = @view du[1:n]\n\tdu2v = @view du[n+1:2n]\n\n\tf1 = @view f[1:n]\n\tf2 = @view f[n+1:2n]\n\n\t@inbounds for ii = 1:n\n\t\tu1 = u1v[ii]\n\t\tu2 = u2v[ii]\n\t\tdu1 = du1v[ii]\n\t\tdu2 = du2v[ii]\n\t\tua = u1^2+u2^2\n\t\tf1[ii] = (-5*c5*u1^4 + (-6*c5*u2^2 - 3*c3)*u1^2 + 2*μ*u1*u2 - c5*u2^4 - c3*u2^2 + r) * du1 +\n\t\t(-4*c5*u2*u1^3 + μ*u1^2 + (-4*c5*u2^3 - 2*c3*u2)*u1 + 3*u2^2*μ - ν) * du2\n\n\t\tf2[ii] = (-4*c5*u2*u1^3 - 3*μ*u1^2 + (-4*c5*u2^3 - 2*c3*u2)*u1 - u2^2*μ + ν) * du1 + (-c5*u1^4 + (-6*c5*u2^2 - c3)*u1^2 - 2*μ*u1*u2 - 5*c5*u2^4 - 3*c3*u2^2 + r) * du2\n\tend\n\n\treturn f\nend\n\n# inplace vector field\nfunction Fcgl!(f, u, p, t = 0.)\n\tNL!(f, u, p)\n\tmul!(f, p.Δ, u, 1., 1.)\nend\n\n# inplace derivative of the vector field\nfunction dFcgl!(f, x, p, dx)\n\tdNL!(f, x, p, dx)\n\tmul!(f, p.Δ, dx, 1., 1.)\nend","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We can now define an inplace functional","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"ls0 = GMRESIterativeSolvers(N = 2Nx*Ny, tol = 1e-9)#, Pl = lu(I + par_cgl.Δ))\npoTrapMFi = PeriodicOrbitTrapProblem(\n\tFcgl!, dFcgl!,\n\treal.(eigvec),\n\thopfpt.u,\n\tM, ls0; isinplace = true)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"and run the newton method:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"outpo_f, _, flag = @time newton(poTrapMFi,\n\torbitguess_f, (@set par_cgl.r = r_hopf - 0.01),\t(@set opt_po.linsolver = ls);\n\tlinearPO = :FullMatrixFree, normN = norminf)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"It gives\t","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     6.5412e-03         0\n        1                2     1.4399e-03         8\n        2                3     3.6404e-04         9\n        3                4     6.3013e-05        10\n        4                5     4.3207e-06        11\n        5                6     3.5334e-08        12\n        6                7     1.0874e-10        13\n        7                8     4.4359e-14        15\n  1.354356 seconds (2.22 k allocations: 153.499 MiB)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Notice the small speed boost but the reduced allocations. At this stage, further improvements could target the use of BlockBandedMatrices.jl for the Laplacian operator, etc.","category":"page"},{"location":"tutorialsCGL/#Other-linear-formulation-1","page":"Complex Ginzburg-Landau 2d","title":"Other linear formulation","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We could use another way to \"invert\" jacobian of the functional based on bordered technics. We try to use an ILU preconditioner on the cyclic matrix J_c (see Periodic orbits based on finite differences) which has a smaller memory footprint:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Jpo2 = poTrap(Val(:JacCyclicSparse), orbitguess_f, @set par_cgl.r = r_hopf - 0.1)\nPrecilu = @time ilu(Jpo2, τ = 0.005)\nls2 = GMRESIterativeSolvers(verbose = false, tol = 1e-3, N = size(Jpo2,1), restart = 30, maxiter = 50, Pl = Precilu, log=true)\n\nopt_po = @set opt_newton.verbose = true\noutpo_f, hist, flag = @time newton(\n\tpoTrapMF,\torbitguess_f, (@set par_cgl.r = r_hopf - 0.1),\n\t(@set opt_po.linsolver = ls2), linearPO = :BorderedMatrixFree,\n\tnormN = norminf)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"but it gives:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     3.3294e-03         0\n        1                2     9.5343e-03        34\n        2                3     1.2791e-03        26\n        3                4     6.6873e-05        30\n        4                5     3.2492e-07        36\n        5                6     9.3987e-10        44\n        6                7     3.5842e-13        58\n  3.567416 seconds (61.43 k allocations: 1.003 GiB, 4.46% gc time)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Hence, it seems better to use the previous preconditioner.","category":"page"},{"location":"tutorialsCGL/#Continuation-of-periodic-solutions-1","page":"Complex Ginzburg-Landau 2d","title":"Continuation of periodic solutions","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We can now perform continuation of the newly found periodic orbit and compute the Floquet multipliers using Matrix-Free methods.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"# set the eigensolver for the computation of the Floquet multipliers\nopt_po = @set opt_po.eigsolver = EigKrylovKit(tol = 1e-3, x₀ = rand(2n), verbose = 2, dim = 25)\n\n# parameters for the continuation\nopts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.02, ds = 0.001, pMax = 2.2, maxSteps = 250, plotEveryStep = 3, newtonOptions = (@set opt_po.linsolver = ls), \n\tnev = 5, precisionStability = 1e-7, detectBifurcation = 0)\n\nbr_po, = @time continuation(poTrapMF, outpo_f, \n\t(@set par_cgl.r = r_hopf - 0.01), (@lens _.r),\topts_po_cont, linearPO = :FullMatrixFree;\n\tverbosity = 2,\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicPOTrap(x, M, Nx, Ny; ratio = 2, kwargs...),\n\tprintSolution = (u, p) -> BK.getAmplitude(poTrapMF, u, par_cgl; ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"This gives the following bifurcation diagram:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"tip: Improved performances\nAlthough it would be \"cheating\" for fair comparisons with existing packages, there is a trick to compute the bifurcation diagram without using preconditionners. We will not detail it here but it allows to handle the case Nx = 200; Ny = 110; M = 30 and above.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We did not change the preconditioner in the previous example as it does not seem needed. Let us show how to do this nevertheless:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"# callback which will be sent to newton. \n# `iteration` in the arguments refers to newton iterations\nfunction callbackPO(x, f, J, res, iteration, itlinear, linsolver = ls, prob = poTrap, p = par_cgl; kwargs...)\n\t# we update the preconditioner every 10 continuation steps\n\tif mod(kwargs[:iterationC], 10) == 9 && iteration == 1\n\t\t@info \"update Preconditioner\"\n\t\tJpo = poTrap(Val(:JacCyclicSparse), x, @set p.r = kwargs[:p])\n\t\tPrecilu = @time ilu(Jpo, τ = 0.003)\n\t\tls.Pl = Precilu\n\tend\n\ttrue\nend\n\nbr_po, = @time continuation(poTrapMF, outpo_f, \n\t(@set par_cgl.r = r_hopf - 0.01), (@lens _.r),\topts_po_cont, linearPO = :FullMatrixFree;\n\tverbosity = 2,\tplot = true,\n\tcallbackN = callbackPO,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicPOTrap(x, M, Nx, Ny; ratio = 2, kwargs...),\n\tprintSolution = (u, p) -> BK.getAmplitude(poTrapMF, u, par_cgl; ratio = 2), normC = norminf)","category":"page"},{"location":"tutorialsCGL/#Continuation-of-Fold-of-periodic-orbits-1","page":"Complex Ginzburg-Landau 2d","title":"Continuation of Fold of periodic orbits","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We continue the Fold point of the first branch of the previous bifurcation diagram in the parameter plane (r c_5). To this end, we need to be able to compute the Hessian of the periodic orbit functional. This is not yet readily available so we turn to automatic differentiation.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"using ForwardDiff\n\n# computation of the second derivative of a function f\nfunction d2Fcglpb(f, x, dx1, dx2)\n   return ForwardDiff.derivative(t2 -> ForwardDiff.derivative( t1-> f(x .+ t1 .* dx1 .+ t2 .* dx2,), 0.), 0.)\nend","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We select the Fold point from the branch br_po and redefine our linear solver to get the ILU preconditioner tuned close to the Fold point.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"indfold = 2\nfoldpt = FoldPoint(br_po, indfold)\n\nJpo = poTrap(Val(:JacFullSparse), orbitguess_f, (@set par_cgl.r = r_hopf - 0.1))\nPrecilu = @time ilu(Jpo, τ = 0.005)\nls = GMRESIterativeSolvers(verbose = false, tol = 1e-4, N = size(Jpo, 1), restart = 40, maxiter = 60, Pl = Precilu)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We can then use our functional to call newtonFold unlike for a regular function (see Tutorial 1). Indeed, we specify the change the parameters too much to rely on a generic algorithm.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"outfold, hist, flag = @time BK.newtonFold(\n\t(x, p) -> poTrap(x, p),\n\t(x, p) -> poTrap(Val(:JacFullSparse), x, p),\n\tbr_po , indfold, #index of the fold point\n\tpar_cgl, (@lens _.r);\n\t# we change the linear solver for the one we \n\t# defined above\n\toptions = (@set opt_po.linsolver = ls),\n\td2F = (x, p, dx1, dx2) -> d2Fcglpb(z -> poTrap(z, p), x, dx1, dx2))\nflag && printstyled(color=:red, \"--> We found a Fold Point at α = \", outfold.p,\" from \", br_po.foldpoint[indfold].param,\"\\n\")","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"and this gives","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     4.6366e-01         0\n        1                2     5.6561e-01        20\n        2                3     3.2592e-02        24\n        3                4     3.2054e-05        32\n        4                5     2.3656e-07        37\n        5                6     1.2573e-10        43\n        6                7     1.9629e-13        49\n 27.289005 seconds (1.07 M allocations: 24.444 GiB, 10.12% gc time)\n--> We found a Fold Point at α = 0.9470569704262517 from 0.9481896723164748","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Finally, one can perform continuation of the Fold bifurcation point as follows","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"optcontfold = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 40.1, pMin = -10., newtonOptions = (@set opt_po.linsolver = ls), maxSteps = 20)\n\noutfoldco, hist, flag = @time BK.continuationFold(\n\t(x, p) -> poTrap(x, p),\n\t(x, p) -> poTrap(Val(:JacFullSparse), x, p),\n\tbr_po, indfold, par_cgl, (@lens _.r), (@lens _.c5), optcontfold;\n\td2F = (x, p, dx1, dx2) -> d2Fcglpb(z->poTrap(z,p), x, dx1, dx2),\n\tplot = true, verbosity = 2)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"which yields:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"(Image: )","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"There is still room for a lot of improvements here. Basically, the idea would be to use full Matrix-Free the jacobian functional and its transpose.","category":"page"},{"location":"tutorialsCGL/#Continuation-of-periodic-orbits-on-the-GPU-(Advanced)-1","page":"Complex Ginzburg-Landau 2d","title":"Continuation of periodic orbits on the GPU (Advanced)","text":"","category":"section"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"tip: \nThis is a very neat example all done on the GPU using the following ingredients: Matrix-Free computation of periodic orbits using preconditioners.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We now take advantage of the computing power of GPUs. The section is run on an NVIDIA Tesla V100. Given the small number of unknowns, we can (only) expect significant speedup in the application of the big preconditioner. ","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Note that we use the parameters Nx = 82; Ny = 42; M=30.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"# computation of the first derivative\nd1Fcgl(x, p, dx) = ForwardDiff.derivative(t -> Fcgl(x .+ t .* dx, p), 0.)\n\nd1NL(x, p, dx) = ForwardDiff.derivative(t -> NL(x .+ t .* dx, p), 0.)\n\nfunction dFcgl(x, p, dx)\n\tf = similar(dx)\n\tmul!(f, p.Δ, dx)\n\tnl = d1NL(x, p, dx)\n\tf .= f .+ nl\nend","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We first load CuArrays","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"using CuArrays\nCuArrays.allowscalar(false)\nimport LinearAlgebra: mul!, axpby!\nmul!(x::CuArray, y::CuArray, α::T) where {T <: Number} = (x .= α .* y)\nmul!(x::CuArray, α::T, y::CuArray) where {T <: Number} = (x .= α .* y)\naxpby!(a::T, X::CuArray, b::T, Y::CuArray) where {T <: Number} = (Y .= a .* X .+ b .* Y)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"and update the parameters","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"par_cgl_gpu = @set par_cgl.Δ = CuArrays.CUSPARSE.CuSparseMatrixCSC(par_cgl.Δ);","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Then, we precompute the preconditioner on the CPU:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Jpo = poTrap(Val(:JacFullSparse), orbitguess_f, @set par_cgl.r = r_hopf - 0.01)\nPrecilu = @time ilu(Jpo, τ = 0.003)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"To invert Precilu on the GPU, we need to define a few functions which are not in CuArrays and which are related to LU decomposition:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"struct LUperso\n\tL\n\tUt\t# transpose of U in LU decomposition\nend\n\nimport Base: ldiv!\nfunction LinearAlgebra.ldiv!(_lu::LUperso, rhs::CuArrays.CuArray)\n\t_x = UpperTriangular(_lu.Ut) \\ (LowerTriangular(_lu.L) \\ rhs)\n\trhs .= vec(_x)\n\tCuArrays.unsafe_free!(_x)\n\trhs\nend","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Finally, for the methods in PeriodicOrbitTrapProblem to work, we need to redefine the following method. Indeed, we disable the use of scalar on the GPU to increase the speed.","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"import BifurcationKit: extractPeriodFDTrap\nextractPeriodFDTrap(x::CuArray) = x[end:end]","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"We can now define our functional:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"# matrix-free problem on the gpu\nls0gpu = GMRESKrylovKit(rtol = 1e-9)\npoTrapMFGPU = PeriodicOrbitTrapProblem(\n\tFcgl, (x, p) ->  (dx -> dFcgl(x, p, dx)),\n\tCuArray(real.(vec_hopf)),\n\tCuArray(hopfpt.u),\n\tM, ls0gpu;\n\tongpu = true) # this is required to alter the way the constraint is handled","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"Let us have a look at the linear solvers and compare the speed on CPU and GPU:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"ls = GMRESKrylovKit(verbose = 2, Pl = Precilu, rtol = 1e-3, dim  = 20)\n   # runs in \t2.990495 seconds (785 allocations: 31.564 MiB, 0.98% gc time)\n\touth, = @time ls((Jpo), orbitguess_f)\n\nPrecilu_gpu = LUperso(LowerTriangular(CuArrays.CUSPARSE.CuSparseMatrixCSR(I+Precilu.L)), UpperTriangular(CuArrays.CUSPARSE.CuSparseMatrixCSR(sparse(Precilu.U'))));\nlsgpu = GMRESKrylovKit(verbose = 2, Pl = Precilu_gpu, rtol = 1e-3, dim  = 20)\n\tJpo_gpu = CuArrays.CUSPARSE.CuSparseMatrixCSR(Jpo);\n\torbitguess_cu = CuArray(orbitguess_f)\n\t# runs in 1.751230 seconds (6.54 k allocations: 188.500 KiB, 0.43% gc time)\n\toutd, = @time lsgpu(Jpo_gpu, orbitguess_cu)","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"So we can expect a pretty descent x2 speed up in computing the periodic orbits. We can thus call newton:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"opt_po = @set opt_newton.verbose = true\n\toutpo_f, hist, flag = @time newton(poTrapMFGPU,\n\t\torbitguess_cu, (@set par_cgl_gpu.r = r_hopf - 0.01),\n\t\t(@set opt_po.linsolver = lsgpu), :FullMatrixFree;\n\t\tnormN = x->maximum(abs.(x))) ","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"The computing time is 6.914367 seconds (2.94 M allocations: 130.348 MiB, 1.10% gc time). The same computation on the CPU, runs in 13.972836 seconds (551.41 k allocations: 1.300 GiB, 1.05% gc time).","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"You can also perform continuation, here is a simple example:","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"opts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.02, ds= 0.001, pMax = 2.2, maxSteps = 250, plotEveryStep = 3, newtonOptions = (@set opt_po.linsolver = lsgpu))\nbr_po, upo , _= @time continuation(poTrapMFGPU,\n   orbitguess_cu, (@set par_cgl_gpu.r = r_hopf - 0.01), (@lens _.r = p),\n   opts_po_cont, linearPO = :FullMatrixFree;\n   verbosity = 2,\n   printSolution = (u,p) -> getAmplitude(poTrapMFGPU, u, par_cgl_gpu), normC = x->maximum(abs.(x)))","category":"page"},{"location":"tutorialsCGL/#","page":"Complex Ginzburg-Landau 2d","title":"Complex Ginzburg-Landau 2d","text":"info: Preconditioner update\nFor now, the preconditioner has been precomputed on the CPU which forbids its (efficient) update during continuation of a branch of periodic orbits. This could be improved using ilu0! and friends in CuArrays.","category":"page"},{"location":"mittelmann/#A-generalized-Bratu–Gelfand-problem-in-two-dimensions-1","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"","category":"section"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"Pages = [\"mittelmann.md\"]\nDepth = 3","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"unknown: References\nThe following example is exposed in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. The Computation of Disconnected Bifurcation Diagrams. ArXiv:1603.00809 [Math], March 2, 2016.","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We consider the problem of Mittelmann:","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"Delta u +NL(lambdau) = 0","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"with Neumann boundary condition on Omega = (01)^2 and where NL(lambdau)equiv-10(u-lambda e^u). This is a good example to show how automatic branch switching works and also nonlinear deflation.","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We start with some imports:","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"using Revise\nusing DiffEqOperators, ForwardDiff\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield\nconst BK = BifurcationKit\n\n# define the sup norm and a L2 norm\nnorminf = x -> norm(x, Inf)\nnormbratu = x-> norm(x) / sqrt(length(x))\n\n# some plotting function to simplify our life\nplotsol!(x, nx = Nx, ny = Ny; kwargs...) = heatmap!(reshape(x, nx, ny); color = :viridis, kwargs...)\nplotsol(x, nx = Nx, ny = Ny; kwargs...) = (plot();plotsol!(x, nx, ny; kwargs...))","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"and with the discretization of the problem","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"function Laplacian2D(Nx, Ny, lx, ly, bc = :Neumann)\n\thx = 2lx/Nx\n\thy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\n\tQx = Neumann0BC(hx)\n\tQy = Neumann0BC(hy)\n\n\tD2xsp = sparse(D2x * Qx)[1]\n\tD2ysp = sparse(D2y * Qy)[1]\n\tA = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))\n\treturn A\nend\n\nϕ(u, λ)  = -10(u-λ*exp(u))\ndϕ(u, λ) = -10(1-λ*exp(u))\n\nfunction NL!(dest, u, p)\n\t@unpack λ = p\n\tdest .= ϕ.(u, λ)\n\treturn dest\nend\n\nNL(u, p) = NL!(similar(u), u, p)\n\nfunction Fmit!(f, u, p)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\n\treturn f\nend\n\nFmit(u, p) = Fmit!(similar(u), u, p)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"It will also prove useful to have the jacobian of our functional: ","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"function JFmit(x,p)\n\tJ = p.Δ\n\tdg = dϕ.(x, p.λ)\n\treturn J + spdiagm(0 => dg)\nend","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We need to pass the parameters associated to this problem:","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"Nx = 30\nNy = 30\nlx = 0.5\nly = 0.5\n\nΔ = Laplacian2D(Nx, Ny, lx, ly)\npar_mit = (λ = .05, Δ = Δ)\n\n# initial guess f for newton\nsol0 = zeros(Nx, Ny) |> vec","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"To compute the eigenvalues, we opt for the shift-invert strategy with shift =0.5","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"# eigensolver\neigls = EigKrylovKit(dim = 70)\n\n# options for Newton solver\nopt_newton = BK.NewtonPar(tol = 1e-8, verbose = true, eigsolver = eigls, maxIter = 20)\n\n# options for continuation\nopts_br = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds = 0.01, pMax = 3.5, pMin = 0.025,\n\tdetectBifurcation = 3, nev = 30, plotEveryStep = 10, newtonOptions = (@set opt_newton.verbose = true), \n\tmaxSteps = 100, precisionStability = 1e-6, nInversion = 4, dsminBisection = 1e-7, maxBisectionSteps = 25)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"Note that we put the option detectBifurcation = 3 to detect bifurcations precisely with a bisection method. Indeed, we need to locate these branch points precisely to be able to call automatic branch switching.","category":"page"},{"location":"mittelmann/#Branch-of-homogenous-solutions-1","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"Branch of homogenous solutions","text":"","category":"section"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"At this stage, we note that the problem has a curve of homogenous (constant in space) solutions u_h solving N(lambda u_h)=0. We shall compute this branch now.","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We can now call continuation with the initial guess sol0 which is homogenous, thereby generating homogenous solutions:","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"br, = @time BK.continuation(\n\tFmit, JFmit,\n\tsol0, par_mit, (@lens _.λ), opts_br;\n\tprintSolution = (x, p) -> normbratu(x),\n\tplotSolution = (x, p; kwargs...) -> plotsol!(x ; kwargs...),\n\tplot = true, verbosity = 3, normC = norminf)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"You should see the following result:","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"(Image: )","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"Several branch point were detected as can be seen using the command","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"julia> br\nBranch number of points: 84\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,      bp at p ≈ 0.36787944 ± 2e-10, step =  18, eigenelements in eig[ 19], ind_ev =   1 [converged], δ = ( 1,  0), bifurcation ∈ (0.36787944, 0.36787944)\n- #  2,      nd at p ≈ 0.27255474 ± 5e-06, step =  33, eigenelements in eig[ 34], ind_ev =   3 [converged], δ = ( 2,  0), bifurcation ∈ (0.27255937, 0.27255474)\n- #  3,      bp at p ≈ 0.15215124 ± 7e-06, step =  48, eigenelements in eig[ 49], ind_ev =   4 [converged], δ = ( 1,  0), bifurcation ∈ (0.15215818, 0.15215124)\n- #  4,      nd at p ≈ 0.03551852 ± 3e-05, step =  76, eigenelements in eig[ 77], ind_ev =   6 [converged], δ = ( 2,  0), bifurcation ∈ (0.03554981, 0.03551852)\nFold points:\n- #  1,    fold at p ≈ 0.36787944, step =  19, eigenelements in eig[ 19], ind_ev =   0 [    guess]","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We notice several simple bifurcation points for which the dimension of the kernel of the jacobian is one dimensional. In the above box, δ = ( 1,  0) gives the change in the stability. In this case, there is one vector in the kernel which is real. The bifurcation point 2 has a 2d kernel and is thus not amenable to automatic branch switching.","category":"page"},{"location":"mittelmann/#Automatic-branch-switching-at-simple-branch-points-1","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"Automatic branch switching at simple branch points","text":"","category":"section"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"To be able to perform branch switching, we need to pass the differentials of our functional. Using automatic differentiation, this is not a big deal:","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"D(f, x, p, dx) = ForwardDiff.derivative(t->f(x .+ t .* dx, p), 0.)\n\nd1Fmit(x,p,dx1) = D((z, p0) -> Fmit(z, p0), x, p, dx1)\nd2Fmit(x,p,dx1,dx2) = D((z, p0) -> d1Fmit(z, p0, dx1), x, p, dx2)\nd3Fmit(x,p,dx1,dx2,dx3) = D((z, p0) -> d2Fmit(z, p0, dx1, dx2), x, p, dx3)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"It is convenient to define the jet of Fmit","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"jet = (Fmit, JFmit, d2Fmit, d3Fmit)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We can now compute the branch off the third bifurcation point:","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"br1, = continuation(jet..., br, 3, \n\tsetproperties(opts_br;ds = 0.001, maxSteps = 40);\n\tverbosity = 3, plot = true,\n\tprintSolution = (x, p) -> normbratu(x),\n\tplotSolution = (x, p; kwargs...) -> plotsol!(x ; kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"and you should see:","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"(Image: )","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"You can also plot the two branches together plot(br,br1,plotfold=false) and get","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"(Image: )","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We continue our journey and compute the branch bifurcating of the first bifurcation point from the last branch we computed:","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"br2, = continuation(jet..., br1, 1, \n\tsetproperties(opts_br;ds = 0.001, maxSteps = 40); \tverbosity = 3, plot = true,\n\tprintSolution = (x, p) -> norm(x),\n\tplotSolution = (x, p; kwargs...) -> plotsol!(x ; kwargs...), normC = norminf)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"(Image: )","category":"page"},{"location":"mittelmann/#Analysis-at-the-2d-branch-points-(manual)-1","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"Analysis at the 2d-branch points (manual)","text":"","category":"section"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"The second bifurcation point on the branch br of homogenous solutions has a 2d kernel. We don't provide automatic branch switching but we provide two methods to deal with such case","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"automatic local bifurcation diagram (see below)\nbranch switching with deflation (see next section)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We provide a generic way to study branch points of arbitrary dimensions by computing a reduced equation. The general method is based on a Lyapunov-Schmidt reduction. We can compute the information about the branch point using the generic function (valid for simple branch points, Hopf bifurcation points,...)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"bp2d = computeNormalForm(jet..., br, 2;  verbose=true, nev = 50)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"You can print the 2d reduced equation as follows. Note that this is a multivariate polynomials. For more information, see Non-simple branch point.","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"julia> BK.nf(bp2d)\n2-element Array{String,1}:\n \" + (-73.897) * x1 ⋅ p + (-0.0012) ⋅ x1³ + (0.003) ⋅ x1 ⋅ x2²\"\n \" + (0.003) ⋅ x1² ⋅ x2 + (-73.897) * x2 ⋅ p + (-0.0012) ⋅ x2³\"","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"You can evaluate this polynomial as follows bp2d(Val(:reducedForm),[0.1,0.2], 0.01) which returns a 2d vector or bp2d([0.1,0.2], 0.01). This last expression actually returns a vector corresponding to the PDE problem.","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"You need to solve these equations to compute the bifurcation diagram in the neighborhood of the bifurcation point. In the present case, we do it using brute force. We suggest to use IntervalConstraintProgramming.jl for a more precise way.","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"using ProgressMeter\nNd = 200; L = 0.9\n# sampling grid\nX = LinRange(-L,L, Nd); Y = LinRange(-L,L, Nd); P = LinRange(-0.0001,0.0001, Nd+1)\n\n# sample reduced equation on the grid for the first component\nV1a = @showprogress [bp2d(Val(:reducedForm),[x1,y1], p1)[1] for p1 in P, x1 in X, y1 in Y]\nInd1 = findall( abs.(V1a) .<= 9e-4 * maximum(abs.(V1a)))\n# intersect with second component\nV2a = @showprogress [bp2d(Val(:reducedForm),[X[ii[2]],Y[ii[3]]], P[ii[1]])[2] for ii in Ind1]\nInd2 = findall( abs.(V2a) .<= 3e-3 * maximum(abs.(V2a)))\n\n# get solutions\nresp = Float64[]; resx = Vector{Float64}[]; resnrm = Float64[]\n\t@showprogress for k in Ind2\n\t\tii = Ind1[k]\n\t\tpush!(resp, P[ii[1]])\n\t\tpush!(resnrm, sqrt(X[ii[2]]^2+Y[ii[3]]^2))\n\t\tpush!(resx, [X[ii[2]], Y[ii[3]]])\n\tend","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We can now plot the local bifurcation diagram as follows","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"using LaTeXStrings\nplot(\n\tscatter(1e4resp, map(x->x[1], resx), map(x->x[2], resx); label = \"\", markerstrokewidth=0, xlabel = L\"10^4 \\cdot \\lambda\", ylabel = L\"x_1\", zlabel = L\"x_2\", zcolor = resnrm, color = :viridis,colorbar=false),\n\tscatter(1e4resp, resnrm; label = \"\", markersize =2, markerstrokewidth=0, xlabel = L\"10^4 \\cdot \\lambda\", ylabel = L\"\\|x\\|\"))","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"(Image: )","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"This looks like a Pitchfork bifurcation with D4 symmetry","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We can see that there are two types of solutions. After the bifurcation point, the solutions are of the form (x_1x_2) = (pm xpm x) for some real x. Before the bifurcation point, the solutions are of the form (x_1x_2) = (pm x0) (0 pm x) for some real x. Here is an example plotsol(bp2d(resx[10], resp[10]))","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"(Image: )","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We could use the solutions saved in resp, resx as initial guesses for a call to continuation but we turn to a different method.","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"tip: Solutions\nThe brute force method provided all solutions in a neighborhood of the bifurcation point.","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"info: Advanced computation\nInstead of using brute force and computing the vector field on a grid. One can rely on IntervalConstraintProgramming.jl to do better using bisection. See also this discourse post where the same example is treated by D. P. Sanders.    ","category":"page"},{"location":"mittelmann/#Branch-switching-with-deflated-newton-(manual)-1","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"Branch switching with deflated newton (manual)","text":"","category":"section"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"At this stage, we know what happens at the 2d bifurcation point of the curve of homogenous solutions. We chose another method based on Deflated problems. We want to find all nearby solutions of the problem close to this bifurcation point. This is readily done by trying several initial guesses in a brute force manner:","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"out = zeros(Nx*Ny)\n# deflation operator to \ndeflationOp = DeflationOperator(2.0, (x, y) -> dot(x, y), 1.0, [zeros(Nx*Ny)])\n\n# options for the newton solver\noptdef = setproperties(opt_newton; tol = 1e-8, maxIter = 100)\n\n# eigen-elements close to the second bifurcation point on the branch\n# of homogenous solutions\nvp, ve, _, _= eigls(JFmit(out, @set par_mit.λ = br.bifpoint[2].param), 5)\n\nfor ii=1:length(ve)\n\toutdef1, _, flag, _ = @time newton(\n\t\tFmit, JFmit,\n\t\t# initial guess for newton\n\t\tbr.bifpoint[2].x .+ 0.01 .*  real.(ve[ii]) .* (1 .+ 0.01 .* rand(Nx*Ny)),\n\t\t(@set par_mit.λ = br.bifpoint[2].param + 0.005),\n\t\toptdef, deflationOp)\n\t\tflag && push!(deflationOp, outdef1)\nend","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"This provides length(deflationOp) = 5 solutions as there are some symmetries in the problem. For example plotsol(deflationOp[5]) gives","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"(Image: )","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We can continue this solution as follows in one direction","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"brdef1, = @time continuation(\n\tFmit, JFmit,\n\tdeflationOp[3], (@set par_mit.λ = br.bifpoint[2].param + 0.005), (@lens _.λ),\n\tsetproperties(opts_br;ds = -0.001, detectBifurcation = 3, dsmax = 0.01, maxSteps = 500);\n\tverbosity = 3, plot = true,\n\tprintSolution = (x, p) -> norm(x),\n\tplotSolution = (x, p; kwargs...) -> plotsol!(x ; kwargs...), normC = norminf)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"If we repeat the above loop but before the branch point by using @set par_mit.λ = br.bifpoint[2].param + 0.005, we get 3 new solutions that we can continue","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"brdef2, = @time continuation(\n\tFmit, JFmit,\n\tdeflationOp[5], (@set par_mit.λ = br.bifpoint[2].param + 0.005), (@lens _.λ),\n\tsetproperties(opts_br;ds = 0.001, detectBifurcation = 3, dsmax = 0.01);\n\tverbosity = 3, plot = true,\n\tprintSolution = (x, p) -> norm(x),\n\tplotSolution = (x, p; kwargs...) -> plotsol!(x ; kwargs...), normC = norminf)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"thereby providing the following bifurcation diagram with plot(br,br1,br2,brdef1, brdef2,plotfold=false, putbifptlegend = false)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"(Image: )","category":"page"},{"location":"mittelmann/#Automatic-branch-switching-at-the-2d-branch-points-1","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"Automatic branch switching at the 2d-branch points","text":"","category":"section"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"We now show how to perform automatic branch switching at the nonsimple branch points. However, we think it is important that the user is able to use the previous tools in case automatic branch switching fails.","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"The call for automatic branch switching is the same as in the case of simple branch points (see above) except that many branches are returned.","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"branches, = continuation(jet..., br, 2,\n\tsetproperties(opts_br; detectBifurcation = 3, ds = 0.001, pMin = 0.01, maxSteps = 32 ) ;\n\tnev = 30, verbosity = 3,\t\n\tplot = true,\n\tplotSolution = (x, p; k...) ->(plotsol!(x; k...); plot!(br,subplot=1)),\n\ttangentAlgo = BorderedPred()\n\t)","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"You can plot the branches using plot(branches). The branches are as follows","category":"page"},{"location":"mittelmann/#","page":"A generalized Bratu–Gelfand problem in two dimensions","title":"A generalized Bratu–Gelfand problem in two dimensions","text":"julia> branches\n8-element Array{Branch,1}:\n  Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,      bp at p ≈ 0.27255723 ± 7e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255723, 0.27255723)\n- #  2,      bp at p ≈ 0.14414814 ± 9e-05, step =  24, eigenelements in eig[ 25], ind_ev =   3 [converged], δ = ( 1,  0), bifurcation ∈ (0.14424073, 0.14414814)\nFold points:\n- #  1,    fold at p ≈ 0.27255723, step =   2, eigenelements in eig[  2], ind_ev =   0 [    guess]\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,      bp at p ≈ 0.27255723 ± 7e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255723, 0.27255723)\n- #  2,      bp at p ≈ 0.14414814 ± 9e-05, step =  24, eigenelements in eig[ 25], ind_ev =   3 [converged], δ = ( 1,  0), bifurcation ∈ (0.14424073, 0.14414814)\nFold points:\n- #  1,    fold at p ≈ 0.27255723, step =   2, eigenelements in eig[  2], ind_ev =   0 [    guess]\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,      bp at p ≈ 0.27255723 ± 7e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255723, 0.27255723)\n- #  2,      bp at p ≈ 0.14414816 ± 9e-05, step =  24, eigenelements in eig[ 25], ind_ev =   3 [converged], δ = ( 1,  0), bifurcation ∈ (0.14424075, 0.14414816)\nFold points:\n- #  1,    fold at p ≈ 0.27255723, step =   2, eigenelements in eig[  2], ind_ev =   0 [    guess]\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,      bp at p ≈ 0.27255723 ± 7e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255723, 0.27255723)\n- #  2,      bp at p ≈ 0.14414814 ± 9e-05, step =  24, eigenelements in eig[ 25], ind_ev =   3 [converged], δ = ( 1,  0), bifurcation ∈ (0.14424073, 0.14414814)\nFold points:\n- #  1,    fold at p ≈ 0.27255723, step =   2, eigenelements in eig[  2], ind_ev =   0 [    guess]\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,      bp at p ≈ 0.27255724 ± 9e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255724, 0.27255724)\n- #  2,      bp at p ≈ 0.27868730 ± 3e-08, step =  15, eigenelements in eig[ 16], ind_ev =   2 [converged], δ = (-1,  0), bifurcation ∈ (0.27868728, 0.27868730)\nFold points:\n- #  1,    fold at p ≈ 0.27868730, step =  16, eigenelements in eig[ 16], ind_ev =   0 [    guess]\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,      bp at p ≈ 0.27255724 ± 9e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255724, 0.27255724)\n- #  2,      bp at p ≈ 0.27868730 ± 3e-08, step =  15, eigenelements in eig[ 16], ind_ev =   2 [converged], δ = (-1,  0), bifurcation ∈ (0.27868728, 0.27868730)\nFold points:\n- #  1,    fold at p ≈ 0.27868730, step =  16, eigenelements in eig[ 16], ind_ev =   0 [    guess]\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,      bp at p ≈ 0.27255724 ± 9e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255724, 0.27255724)\n- #  2,      bp at p ≈ 0.27868730 ± 3e-08, step =  15, eigenelements in eig[ 16], ind_ev =   2 [converged], δ = (-1,  0), bifurcation ∈ (0.27868728, 0.27868730)\nFold points:\n- #  1,    fold at p ≈ 0.27868730, step =  16, eigenelements in eig[ 16], ind_ev =   0 [    guess]\n\n Branch number of points: 33\nBranch of Equilibrium from NonSimpleBranchPoint bifurcation point.\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,      bp at p ≈ 0.27255724 ± 9e-10, step =   1, eigenelements in eig[  2], ind_ev =   3 [converged], δ = (-1,  0), bifurcation ∈ (0.27255724, 0.27255724)\n- #  2,      bp at p ≈ 0.27868730 ± 3e-08, step =  15, eigenelements in eig[ 16], ind_ev =   2 [converged], δ = (-1,  0), bifurcation ∈ (0.27868728, 0.27868730)\nFold points:\n- #  1,    fold at p ≈ 0.27868730, step =  16, eigenelements in eig[ 16], ind_ev =   0 [    guess]","category":"page"},{"location":"periodicOrbit/#Periodic-orbits-computation-1","page":"Introduction","title":"Periodic orbits computation","text":"","category":"section"},{"location":"periodicOrbit/#","page":"Introduction","title":"Introduction","text":"We provide two methods for computing periodic orbits (PO):","category":"page"},{"location":"periodicOrbit/#","page":"Introduction","title":"Introduction","text":"one based on finite differences to discretize a Cauchy problem\none based on the flow associated to a Cauchy problem","category":"page"},{"location":"periodicOrbit/#","page":"Introduction","title":"Introduction","text":"It is important to understand the pro and cons of each method to compute PO in large dimensions.","category":"page"},{"location":"periodicOrbit/#","page":"Introduction","title":"Introduction","text":"The methods based on finite differences are usually faster than the ones based on Shooting but they require more memory as they save the whole orbit. However the main drawback of this method is that the associated linear solver is not \"nice\", being composed of a cyclic matrix for which no generic Matrix-free preconditioner is known. Hence, this method is often used with an ILU preconditioner which is severely constrained by memory. Also, when the period of the cycle is large, finer time discretization (or mesh adaptation which is not yet implemented) must be employed which is also a limiting factor both in term of memory and preconditioning.","category":"page"},{"location":"periodicOrbit/#","page":"Introduction","title":"Introduction","text":"The methods based on Shooting do not share the same drawbacks because the associated linear system is usually well conditioned, at least in the simple shooting case. There are thus often used without preconditioner at all. Even in the case of multiple shooting, this can be alleviated by a simple generic preconditioner based on deflation of eigenvalues (see Linear solvers). Also, the time stepper will automatically adapt to the stiffness of the problem, putting more time points where needed unlike the method based on finite differences which requires an adaptive (time) meshing to provide a similar property. The main drawback of the method is to find a fast time stepper, at least to compete with the method based on finite differences.","category":"page"},{"location":"periodicOrbitShooting/#Periodic-orbits-based-on-the-shooting-method-1","page":"Shooting","title":"Periodic orbits based on the shooting method","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"A set of shooting algorithms is provided which are called either Simple Shooting (SS) if a single shooting is used and Multiple Shooting (MS) otherwise. ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"unknown: References\nFor the exposition, we follow the PhD thesis Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust, Kurt, 1997. ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"We aim at finding periodic orbits for the Cauchy problem ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"tag1 fracd xd t=f(x)","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"and we write phi^t(x_0) the associated flow (or semigroup of solutions).","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"tip: Tip about convenience functions\nFor convenience, we provide some functions plotPeriodicShooting for plotting, getAmplitude (resp. getMaximum) for getting the amplitude (resp. maximum) of the solution encoded by a shooting problem. See the tutorials for examples of use.","category":"page"},{"location":"periodicOrbitShooting/#Standard-Shooting-1","page":"Shooting","title":"Standard Shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/#Simple-shooting-1","page":"Shooting","title":"Simple shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"A periodic orbit is found when we have a couple (x T) such that phi^T(x) = x and the trajectory is non constant. Therefore, we want to solve the equations G(xT)=0 given by","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"tagSS\nbeginarraylphi^T(x)-x=0  s(xT)=0endarray","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"The section s(xT)=0 is a phase condition to remove the indeterminacy of the point on the limit cycle.","category":"page"},{"location":"periodicOrbitShooting/#Multiple-shooting-1","page":"Shooting","title":"Multiple shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"This case is similar to the previous one but more sections are used. To this end, we partition the unit interval with M+1 points 0=s_0s_1cdotss_m-1s_m=1 and consider the equations G(x_1cdotsx_MT)=0","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"beginaligned \nphi^delta s_1T(x_1)-x_2 =0  \nphi^delta s_2T(x_2)-x_3 =0   vdots  \nphi^delta s_m-1T(x_m-1)-x_m =0  \nphi^delta s_mT(x_m)-x_1 =0  s(x_1 x_2 cdots x_m T) =0 endaligned","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"where delta s_i=s_i+1-s_i. The Jacobian of the system of equations w.r.t. (xT) is given by ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"mathcalJ=left(beginarrayccmathcal J_c  partial_TG  star  dendarrayright)","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"where the cyclic matrix mathcal J_c is","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"mathcal J_c = \nleft(beginarrayccccc\nM_1  -I      \n  M_2  -I   \n    ddots  -I \n-I      M_m \nendarrayright)","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"and M_i=partial_xphi^delta s_i T(x_i).","category":"page"},{"location":"periodicOrbitShooting/#Encoding-of-the-functional-1","page":"Shooting","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"The functional is encoded in the composite type ShootingProblem. In particular, the user can pass its own time stepper or one can use the different ODE solvers in  DifferentialEquations.jl which makes it very easy to choose a solver tailored for the a specific problem. See the link ShootingProblem for more information ;  for example on how to access the underlying functional, its jacobian...","category":"page"},{"location":"periodicOrbitShooting/#Poincaré-shooting-1","page":"Shooting","title":"Poincaré shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"The algorithm is based on the one described in Newton–Krylov Continuation of Periodic Orbits for Navier–Stokes Flows., Sánchez, J., M. Net, B. Garcı́a-Archilla, and C. Simó (2004) and Matrix-Free Continuation of Limit Cycles for Bifurcation Analysis of Large Thermoacoustic Systems. Waugh, Iain, Simon Illingworth, and Matthew Juniper (2013). ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"We look for periodic orbits solutions of (1) using the hyperplanes Sigma_i=x   n_icdot(x-x^c_i)=0 for i=1cdotsM, centered on x^c_i, which intersect transversally an initial periodic orbit guess. We write Pi_iSigma_itoSigma_mod(i+1M), the Poincaré return map to Sigma_mod(i+1M). The main idea of the algorithm is to use the fact that the problem is (N-1)cdot M dimensional if x_iinmathbb R^N because each x_i lives in Sigma_i. Hence, one has to constrain the unknowns to these hyperplanes otherwise the Newton algorithm does not converge well.","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"To this end, we introduce the projection operator R_imathbb R^Nto mathbb R^N-1 such that ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"R_ileft(x_1 x_2 ldots x_k_i-1 x_k_i x_k_i+1 ldots x_Nright)=left(x_1 x_2 ldots x_k_i-1 x_k_i+1 ldots x_Nright)","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"where k_i=argmax_p n_ip. The inverse operator is defined as (where bar x=R_i(x))","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"E_i(bar x) = E_ileft(x_1 x_2 ldots x_k_i-1 x_k_i+1 ldots x_Nright)=\nleft(x_1 x_2 ldots x_k_i-1 x^c_ik_i-fracbarn_i cdotleft(overlinex-overlinex^c_iright)n_ik_i x_k_i+1 ldots x_Nright)","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"We note that R_icirc E_i = I_mathbb R^N-1 and E_icirc R_i = I_mathbb R^N.","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"We then look for solutions of the following problem:","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"beginaligned \nbar x_1 - R_MPi_M(E_M(bar x_M))=0  \nbar x_2 - R_1Pi_1(E_i(bar x_1))=0   vdots  \nbar x_M - R_M-1Pi_M-1(E_M-1(bar x_M-1))=0 \nendaligned","category":"page"},{"location":"periodicOrbitShooting/#Computation-of-Floquet-exponents-1","page":"Shooting","title":"Computation of Floquet exponents","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"The (non trivial) Floquet exponents are eigenvalues of the Poincare return map PiSigma_1toSigma_1. We have Pi = Pi_McircPi_M-1circcdotscircPi_2circPi_1. Its differential is thus","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"dPi(x)cdot h = dPi_M(x_M)dPi_M-1(x_M-1)cdots dPi_1(x_1)cdot h","category":"page"},{"location":"periodicOrbitShooting/#Encoding-of-the-functional-2","page":"Shooting","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"The functional is encoded in the composite type PoincareShootingProblem. In particular, the user can pass their own time stepper or he can use the different ODE solvers in  DifferentialEquations.jl which makes it very easy to choose a tailored solver: the partial Poincaré return maps are implemented using callbacks. See the link PoincareShootingProblem for more information, in particular on how to access the underlying functional, its jacobian...","category":"page"},{"location":"periodicOrbitShooting/#Floquet-multipliers-computation-1","page":"Shooting","title":"Floquet multipliers computation","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"These are the eigenvalues of M_Mcdots M_1.","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"Unlike the case with Finite differences, the matrices M_i are not sparse.","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"A not very precise algorithm for computing the Floquet multipliers is provided. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations of periodic orbits. It seems to work reasonably well for the tutorials considered here. For more information, have a look at FloquetQaDShooting.","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"note: Algorithm\nA more precise algorithm, based on the periodic Schur decomposition will be implemented in the future.","category":"page"},{"location":"periodicOrbitShooting/#Computation-with-newton-1","page":"Shooting","title":"Computation with newton","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"We provide a simplified call to newton to locate the periodic orbit. Have a look at the tutorial Continuation of periodic orbits (Standard Shooting) for a simple example on how to use the above methods. ","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"The docs for this specific newton are located at newton.","category":"page"},{"location":"periodicOrbitShooting/#Computation-with-newton-and-deflation-1","page":"Shooting","title":"Computation with newton and deflation","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"We also provide a simplified call to newton to locate the periodic orbit with a deflation operator:","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"newton(prob:: AbstractShootingProblem, orbitguess, par0, options::NewtonPar; kwargs...)","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"and","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"newton(prob:: AbstractShootingProblem, orbitguess, par0, options::NewtonPar, defOp::DeflationOperator; kwargs...)","category":"page"},{"location":"periodicOrbitShooting/#Continuation-1","page":"Shooting","title":"Continuation","text":"","category":"section"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"Have a look at the Continuation of periodic orbits (Standard Shooting) example for the Brusselator.","category":"page"},{"location":"periodicOrbitShooting/#","page":"Shooting","title":"Shooting","text":"The docs for this specific newton are located at continuation.","category":"page"},{"location":"codim2Continuation/#Fold-/-Hopf-Continuation-1","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation","text":"","category":"section"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"For this to work, it is important to have an analytical expression for the jacobian. See the tutorial Temperature model (simplest example for equilibria) for more details.","category":"page"},{"location":"codim2Continuation/#Newton-refinement-1","page":"Fold / Hopf Continuation (codim 2)","title":"Newton refinement","text":"","category":"section"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"Once a Fold/Hopf point has been detected after a call to br, _ = continuation(...), it can be refined using newton iterations. We have implemented a Minimally Augmented formulation. A simplified interface is provided.","category":"page"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"Let us say that ind_bif is the index in br.bifpoint of a Fold/Hopf point. This guess can be refined by newton iterations by doing ","category":"page"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"outfold, hist, flag = newton(F, J, br::ContResult, ind_bif::Int64, \n\tpar, lens::Lens; Jt = nothing, d2F = nothing, normN = norm, \n\toptions = br.contparams.newtonOptions, kwargs...)","category":"page"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"where par is the set of parameters used in the call to continuation to get br and lens is the parameter axis which is used to find the Fold/Hopf point. For the options parameters, we refer to Newton.","category":"page"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"It is important to note that for improved performances, a function implementing the expression of the hessian should be provided. This is by far the fastest. Reader interested in this advanced usage should look at the code example/chan.jl of the tutorial Temperature model (simplest example for equilibria). ","category":"page"},{"location":"codim2Continuation/#Codim-2-continuation-1","page":"Fold / Hopf Continuation (codim 2)","title":"Codim 2 continuation","text":"","category":"section"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"To compute the codim 2 curve of Fold/Hopf points, one can call continuation with the following options","category":"page"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"br_codim2, _ = continuation(F, J, br, ind_bif, \n\tpar, lens1::Lens, lens2::Lens, options_cont::ContinuationPar ;\n\tJt = nothing, d2F = nothing, kwargs...)","category":"page"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"where the options are as above except with have two parameter axis lens1, lens2 which are used to locate the bifurcation points. See Temperature model (simplest example for equilibria) for an example of use. ","category":"page"},{"location":"codim2Continuation/#Advanced-use-1","page":"Fold / Hopf Continuation (codim 2)","title":"Advanced use","text":"","category":"section"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"Here, we expose the solvers that are used to perform newton refinement or codim 2 continuation in case the above methods fails. This is useful in case it is too involved to expose the linear solver options. An example of advanced use is the continuation of Folds of periodic orbits, see Continuation of Fold of periodic orbits.","category":"page"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"newtonFold","category":"page"},{"location":"codim2Continuation/#BifurcationKit.newtonFold","page":"Fold / Hopf Continuation (codim 2)","title":"BifurcationKit.newtonFold","text":"newtonFold(F, J, foldpointguess, par, lens::Lens, eigenvec, options::NewtonPar; Jt = nothing, d2F = nothing, normN = norm, kwargs...)\n\nThis function turns an initial guess for a Fold point into a solution to the Fold problem based on a Minimally Augmented formulation. The arguments are as follows\n\nF   = (x, p) -> F(x, p) where p is a set of parameters.\ndF  = (x, p) -> d_xF(x, p) associated jacobian\nfoldpointguess initial guess (x0, p0) for the Fold point. It should be a BorderedArray as returned by the function FoldPoint\npar parameters used for the vector field\nlens parameter axis used to locate the Fold point.\neigenvec guess for the 0 eigenvector\noptions::NewtonPar options for the Newton-Krylov algorithm, see NewtonPar.\n\nOptional arguments:\n\nJt = (x, p) -> transpose(d_xF(x, p)) jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jt should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass Jt = (x, p) -> transpose(dF(x, p))\nd2F = (x, p, v1, v2) ->  d2F(x, p, v1, v2) a bilinear operator representing the hessian of F. It has to provide an expression for d2F(x,p)[v1,v2].\nnormN = norm\nkwargs keywords arguments to be passed to the regular Newton-Krylov solver\n\nSimplified call\n\nSimplified call to refine an initial guess for a Fold point. More precisely, the call is as follows\n\nnewtonFold(F, J, br::ContResult, ind_fold::Int64, par, lens::Lens; Jt = nothing, d2F = nothing, options = br.contparams.newtonOptions, kwargs...)\n\nwhere the optional argument Jt is the jacobian transpose and the Hessian is d2F. The parameters / options are as usual except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine. You can pass newton parameters different from the ones stored in br by using the argument options.\n\ntip: Jacobian tranpose\nThe adjoint of the jacobian J is computed internally when Jt = nothing by using tranpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jt = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian will be computed twice!\n\nwarning: Hessian\nThe hessian of F, when d2F is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"newtonHopf","category":"page"},{"location":"codim2Continuation/#BifurcationKit.newtonHopf","page":"Fold / Hopf Continuation (codim 2)","title":"BifurcationKit.newtonHopf","text":"newtonHopf(F, J, hopfpointguess::BorderedArray{vectypeR, T}, par, lens::Lens, eigenvec, eigenvec_ad, options::NewtonPar; Jt = nothing, d2F = nothing, normN = norm) where {vectypeR, T}\n\nThis function turns an initial guess for a Hopf point into a solution to the Hopf problem based on a Minimally Augmented formulation. The arguments are as follows\n\nF   = (x, p) -> F(x, p) where p is a set of parameters.\ndF  = (x, p) -> d_xF(x, p) associated jacobian\nhopfpointguess initial guess (x0, p0) for the Hopf point. It should a BorderedArray as returned by the function HopfPoint.\npar parameters used for the vector field\nlens parameter axis used to locate the Hopf point.\neigenvec guess for the  iω eigenvector\neigenvec_ad guess for the -iω eigenvector\noptions::NewtonPar options for the Newton-Krylov algorithm, see NewtonPar.\n\nOptional arguments:\n\nJt = (x, p) -> transpose(d_xF(x, p)) jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jt should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass Jt = (x, p) -> transpose(dF(x, p))\nd2F = (x, p, v1, v2) ->  d2F(x, p, v1, v2) a bilinear operator representing the hessian of F. It has to provide an expression for d2F(x,p)[v1,v2].\nnormN = norm\nkwargs keywords arguments to be passed to the regular Newton-Krylov solver\n\nSimplified call:\n\nSimplified call to refine an initial guess for a Hopf point. More precisely, the call is as follows\n\nnewtonHopf(F, J, br::ContResult, ind_hopf::Int64, par, lens::Lens; Jt = nothing, d2F = nothing, normN = norm, options = br.contparams.newtonOptions, kwargs...)\n\nwhere the optional argument Jt is the jacobian transpose and the Hessian is d2F. The parameters / options are as usual except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine. You can pass newton parameters different from the ones stored in br by using the argument options.\n\ntip: Jacobian tranpose\nThe adjoint of the jacobian J is computed internally when Jt = nothing by using tranpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jt = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian will be computed twice!\n\nwarning: Hessian\nThe hessian of F, when d2F is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"continuationFold","category":"page"},{"location":"codim2Continuation/#BifurcationKit.continuationFold","page":"Fold / Hopf Continuation (codim 2)","title":"BifurcationKit.continuationFold","text":"continuationFold(F, J, foldpointguess, par, lens1, lens2, eigenvec, options_cont; Jt, d2F, kwargs...)\n\n\nCodim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows\n\nF = (x, p) ->\tF(x, p) where p is a set of parameters\nJ = (x, p) -> d_xF(x, p) associated jacobian\nfoldpointguess initial guess (x0, p10) for the Fold point. It should be a BorderedArray as returned by the function FoldPoint\npar set of parameters\nlens1 parameter axis for parameter 1\nlens2 parameter axis for parameter 2\neigenvec guess for the 0 eigenvector at p1_0\noptions_cont arguments to be passed to the regular continuation\n\nOptional arguments:\n\nJt = (x, p) -> transpose(d_xF(x, p)) associated jacobian transpose\nd2F = p -> ((x, p, v1, v2) -> d2F(x, p, v1, v2)) this is the hessian of F computed at (x, p) and evaluated at (v1, v2).\nkwargs keywords arguments to be passed to the regular continuation\n\nSimplified call\n\nThe call is as follows\n\ncontinuationFold(F, J, br::ContResult, ind_fold::Int64, par, lens1::Lens, lens2::Lens, options_cont::ContinuationPar ; Jt = nothing, d2F = nothing, kwargs...)\n\nwhere the parameters are as above except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of Fold point in br you want to continue.\n\ntip: Jacobian tranpose\nThe adjoint of the jacobian J is computed internally when Jt = nothing by using tranpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jt = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian would be computed twice!\n\nwarning: Hessian\nThe hessian of F, when d2F is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/#","page":"Fold / Hopf Continuation (codim 2)","title":"Fold / Hopf Continuation (codim 2)","text":"continuationHopf","category":"page"},{"location":"codim2Continuation/#BifurcationKit.continuationHopf","page":"Fold / Hopf Continuation (codim 2)","title":"BifurcationKit.continuationHopf","text":"continuationHopf(F, J, hopfpointguess, par, lens1, lens2, eigenvec, eigenvec_ad, options_cont; Jt, d2F, kwargs...)\n\n\ncodim 2 continuation of Hopf points. This function turns an initial guess for a Hopf point into a curve of Hopf points based on a Minimally Augmented formulation. The arguments are as follows\n\nF = (x, p) ->\tF(x, p) where p is a set of parameters\nJ = (x, p) -> d_xF(x, p) associated jacobian\nhopfpointguess initial guess (x0, p10) for the Hopf point. It should be a Vector or a BorderedArray\npar set of parameters\nlens1 parameter axis for parameter 1\nlens2 parameter axis for parameter 2\neigenvec guess for the iω eigenvector at p1_0\neigenvec_ad guess for the -iω eigenvector at p1_0\noptions_cont keywords arguments to be passed to the regular continuation\n\nOptional arguments:\n\nJt = (x, p) -> adjoint(d_xF(x, p)) associated jacobian adjoint\nd2F = p -> ((x, p, v1, v2) -> d2F(x, p, v1, v2)) this is the hessian of F computed at (x, p) and evaluated at (v1, v2).\nkwargs keywords arguments to be passed to the regular continuation\n\nSimplified call:\n\nThe call is as follows\n\ncontinuationHopf(F, J, br::ContResult, ind_hopf::Int64, par, lens1::Lens, lens2::Lens, options_cont::ContinuationPar ;  Jt = nothing, d2F = nothing, kwargs...)\n\nwhere the parameters are as above except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of Hopf point in br you want to refine.\n\nwarning: Hessian\nThe hessian of F, when d2F is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6\n\ntip: Jacobian tranpose\nThe adjoint of the jacobian J is computed internally when Jt = nothing by using tranpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jt = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian would be computed twice!\n\nwarning: Hessian\nThe hessian of F, when d2F is not passed, is computed with Finite differences. This can be slow for many variables, e.g. ~1e6\n\n\n\n\n\n","category":"function"},{"location":"Swift-Hohenberg1d/#Swift-Hohenberg-equation-1d-(Automatic)-1","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"","category":"section"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"Pages = [\"Swift-Hohenberg1d.md\"]\nDepth = 3","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"In this tutorial, we will see how to compute automatically the bifurcation diagram of the 1d Swift-Hohenberg equation","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"-(I+Delta)^2 u+lcdot u +nu u^2-u^3 = 0tagE","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"with Dirichlet boundary conditions. We use a Sparse Matrix to express the operator L_1=(I+Delta)^2. We start by loading the packages:","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"using Revise\nusing SparseArrays, LinearAlgebra, DiffEqOperators, Setfield, Parameters\nusing BifurcationKit\nusing Plots\nconst BK = BifurcationKit","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"We then define a discretization of the problem","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"# define a norm\nnorminf(x) = norm(x, Inf64)\n\n# discretisation\nNx = 200; Lx = 6.;\nX = -Lx .+ 2Lx/Nx*(0:Nx-1) |> collect\nhx = X[2]-X[1]\n\n# boundary condition\nQ = Dirichlet0BC(hx |> typeof)\nDxx = sparse(CenteredDifference(2, 2, hx, Nx) * Q)[1]\nLsh = -(I + Dxx)^2\n\n# functional of the problem\nfunction R_SH(u, par)\n\t@unpack p, b, L1 = par\n\tout = similar(u)\n\tout .= L1 * u .- p .* u .+ b .* u.^3 - u.^5\nend\n\n# Jacobian of the function\nJac_sp = (u, par) -> par.L1 + spdiagm(0 => -par.p .+ 3*par.b .* u.^2 .- 5 .* u.^4)\n\n# second derivative\nd2R(u,p,dx1,dx2) = @. p.b * 6u*dx1*dx2 - 5*4u^3*dx1*dx2\n\n# third derivative\nd3R(u,p,dx1,dx2,dx3) = @. p.b * 6dx3*dx1*dx2 - 5*4*3u^2*dx1*dx2*dx3\n\n# jet associated with the functional\njet = (R_SH, Jac_sp, d2R, d3R)\n\n# parameters associated with the equation\nparSH = (p = 0.7, b = 2., L1 = Lsh)","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"We then choose the parameters for continuation with precise detection of bifurcation points by bisection:","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"optnew = NewtonPar(verbose = true, tol = 1e-12)\nopts = ContinuationPar(dsmin = 0.0001, dsmax = 0.01, ds = -0.01, pMin = -2.1,\n\tnewtonOptions = setproperties(optnew; maxIter = 30, tol = 1e-8), \n\tmaxSteps = 300, plotEveryStep = 40, \n\tdetectBifurcation = 3, nInversion = 4, tolBisectionEigenvalue = 1e-17, dsminBisection = 1e-7)","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"Before we continue, it is useful to define a callback (see continuation) for newton to avoid spurious branch switching. It is not strictly necessary for what follows. ","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"function cb(x,f,J,res,it,itl,optN; kwargs...)\n\t_x = get(kwargs, :z0, nothing)\n\tfromNewton = get(kwargs, :fromNewton, false)\n\tif ~fromNewton\n\t\t# if the residual is too large or if the parameter jump\n\t\t# is too big, abord continuation step\n\t\treturn norm(_x.u - x) < 20.5 && abs(_x.p - kwargs[:p]) < 0.05\n\tend\n\ttrue\nend","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"Next, we specify the arguments to be used during continuation, such as plotting function, tangent predictors, callbacks...","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"args = (verbosity = 3,\n\tplot = true,\n\tlinearAlgo  = MatrixBLS(),\n\tplotSolution = (x, p;kwargs...)->(plot!(X, x; ylabel=\"solution\", label=\"\", kwargs...)),\n\tcallbackN = cb\n\t)","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"Depending on the level of recursion in the bifurcation diagram, we change a bit the options as follows","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"function optrec(x, p, l; opt = opts)\n\tlevel =  l\n\tif level <= 2\n\t\treturn setproperties(opt; maxSteps = 300, detectBifurcation = 3, nev = Nx, detectLoop = false)\n\telse\n\t\treturn setproperties(opt; maxSteps = 250, detectBifurcation = 3, nev = Nx, detectLoop = true)\n\tend\nend","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"tip: Tuning\nThe function optrec modifies the continuation options opts as function of the branching level. It can be used to alter the continuation parameters inside the bifurcation diagram.","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"We are now in position to compute the bifurcation diagram","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"# initial condition\nsol0 = zeros(Nx)\n\ndiagram = @time bifurcationdiagram(jet..., \n\tsol0, (@set parSH.p = 1.), (@lens _.p), \n\t# here we specify a maximum branching level of 4\n\t4, optrec; args...)","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"After ~700s, you can plot the result  ","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"plot(diagram;  plotfold = false,  \n\tmarkersize = 2, putbifptlegend = false, xlims=(-1,1))\ntitle!(\"#branches = $(size(diagram))\")","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"(Image: )","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"Et voilà!","category":"page"},{"location":"Swift-Hohenberg1d/#Exploration-of-the-diagram-1","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Exploration of the diagram","text":"","category":"section"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"The bifurcation diagram diagram is stored as tree:","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"julia> diagram\nBifurcation diagram. Root branch (level 1) has 6 children and is such that:\nBranch number of points: 224\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at p ≈ -0.00729225 ∈ (-0.00728880, -0.00729225), |δp|=3e-06, [converged], δ = ( 1,  0), step =  72, eigenelements in eig[ 73], ind_ev =   1\n- #  2,    bp at p ≈ -0.15169672 ∈ (-0.15158623, -0.15169672), |δp|=1e-04, [converged], δ = ( 1,  0), step =  83, eigenelements in eig[ 84], ind_ev =   2\n- #  3,    bp at p ≈ -0.48386427 ∈ (-0.48385737, -0.48386427), |δp|=7e-06, [converged], δ = ( 1,  0), step = 107, eigenelements in eig[108], ind_ev =   3\n- #  4,    bp at p ≈ -0.53115204 ∈ (-0.53071010, -0.53115204), |δp|=4e-04, [converged], δ = ( 1,  0), step = 111, eigenelements in eig[112], ind_ev =   4\n- #  5,    bp at p ≈ -0.86889220 ∈ (-0.86887839, -0.86889220), |δp|=1e-05, [converged], δ = ( 1,  0), step = 135, eigenelements in eig[136], ind_ev =   5\n- #  6,    bp at p ≈ -2.07693994 ∈ (-2.07671897, -2.07693994), |δp|=2e-04, [converged], δ = ( 1,  0), step = 221, eigenelements in eig[222], ind_ev =   6","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"We can access the different branches with BK.getBranch(diagram, (1,)). Alternatively, you can plot a specific branch:","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"plot(diagram; code = (1,), plotfold = false,  markersize = 2, putbifptlegend = false, xlims=(-1,1))","category":"page"},{"location":"Swift-Hohenberg1d/#","page":"Swift-Hohenberg equation 1d (Automatic)","title":"Swift-Hohenberg equation 1d (Automatic)","text":"(Image: )","category":"page"},{"location":"library/#Library-1","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#Parameters-1","page":"Library","title":"Parameters","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"NewtonPar","category":"page"},{"location":"library/#BifurcationKit.NewtonPar","page":"Library","title":"BifurcationKit.NewtonPar","text":"options = NewtonPar(tol = 1e-4,...)\n\nReturns a variable containing parameters to affect the newton algorithm when solving F(x) = 0.\n\nArguments (with default values):\n\ntol = 1e-10: absolute tolerance for F(x)\nmaxIter = 50: number of Newton iterations\nverbose = false: display Newton iterations?\nlinsolver = DefaultLS(): linear solver, must be <: AbstractLinearSolver\neigsolver = DefaultEig(): eigen solver, must be <: AbstractEigenSolver\n\nArguments only used in newtonPALC\n\nlinesearch = false: use line search algorithm\nalpha = 1.0: alpha (damping) parameter for line search algorithm\nalmin  = 0.001: minimal vslue of the damping alpha\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Setfield.jl to drastically simplify the mutation of different fields. See the tutorials for examples.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"ContinuationPar","category":"page"},{"location":"library/#BifurcationKit.ContinuationPar","page":"Library","title":"BifurcationKit.ContinuationPar","text":"options = ContinuationPar(dsmin = 1e-4,...)\n\nReturns a variable containing parameters to affect the continuation algorithm used to solve F(x,p) = 0.\n\nArguments\n\ndsmin, dsmax are the minimum, maximum arclength allowed value. It controls the density of points in the computed branch of solutions.\nds is the initial arclength.\ntheta is a parameter in the arclength constraint. It is very important to tune it. See the docs of continuation.\npMin, pMax allowed parameter range for p\nmaxSteps maximum number of continuation steps\nnewtonOptions::NewtonPar: options for the Newton algorithm\nsaveToFile = false: save to file. A name is automatically generated.\nsaveSolEveryStep::Int64 = 0 at which continuation steps do we save the current solution`\nplotEveryStep = 3\n\nHandling eigen elements, their computation is triggered by the argument detectBifurcation (see below)\n\nnev = 3 number of eigenvalues to be computed. It is automatically increased to have at least nev unstable eigenvalues. To be set for proper  bifurcation detection. See Detection of bifurcation points for more informations.\nsaveEigEveryStep = 1\trecord eigen vectors every specified steps. Important for memory limited ressource, e.g. GPU.\nsaveEigenvectors\t= true\tImportant for memory limited ressource, e.g. GPU.\n\nHandling bifurcation detection\n\nprecisionStability = 1e-10 lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits\ndetectFold = true detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)\ndetectBifurcation::Int ∈ {0, 1, 2, 3} If set to 0, nothing is done. If set to 0, the eigen-elements are computed. If set to 2, bifurcation are detected along the continuation run, but not located precisely. If set to 3, a bisection algorithm is used to locate the bifurcations (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory of memory limited devices (e.g. on GPU)\ndsminBisection dsmin for the bisection algorithm for locating bifurcation points\nnInversion number of sign inversions in bisection algorithm\nmaxBisectionSteps maximum number of bisection steps\ntolBisectionEigenvalue tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps\n\nHandling ds adaptation (see continuation for more information)\n\na  = 0.5 aggressiveness factor. It is used to adapt ds in order to have a number of newton iterations per continuation step roughly constant. The higher a is, the larger the step size ds is changed at each continuation step.\nthetaMin = 1.0e-3 minimum value of theta\ndoArcLengthScaling trigger further adaptation of theta\n\nMisc\n\nfinDiffEps::T  = 1e-9 ε used in finite differences computations\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Setfield.jl to drastically simplify the mutation of different fields. See tutorials for more examples.\n\n\n\n\n\n","category":"type"},{"location":"library/#Results-1","page":"Library","title":"Results","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"ContResult","category":"page"},{"location":"library/#BifurcationKit.ContResult","page":"Library","title":"BifurcationKit.ContResult","text":"struct ContResult{Ta, Teigvals, Teigvec, Biftype, Ts, Tfunc, Tpar, Tl<:Setfield.Lens} <: BifurcationKit.BranchResult\n\nStructure which holds the results after a call to continuation.\n\nYou can see the propertynames of a result by using propertynames(::ContResult) or by typing br. + TAB where br::ContResult.\n\nFields\n\nbranch::StructArrays.StructArray{Ta,N,C,I} where I where C<:Union{Tuple, NamedTuple} where N where Ta\nholds the low-dimensional information about the branch. More precisely, branch[:, i] contains the following information (param, printSolution(u, param), Newton iterations, ds, theta, i) for each continuation step i.\neig::Array{NamedTuple{(:eigenvals, :eigenvec, :step),Tuple{Teigvals,Teigvec,Int64}},1} where Teigvec where Teigvals\nA vector with eigen-elements at each continuation step.\nfoldpoint::Array{Biftype,1} where Biftype\nA vector holding the set of fold points detected during the computation of the branch. See GenericBifPoint for a description of the fields.\nstability::Array{Bool,1}\nA Vector{Bool} holding the stability of the computed solution for each continuation step. Hence, the stability stability[k] should match eig[k] which corresponds to branch[k] for a given k\nn_imag::Array{Int64,1}\nA Vector{Int64} holding the number of eigenvalues with positive real part and non zero imaginary part for each continuation step (to detect Hopf bifurcation)\nn_unstable::Array{Int64,1}\nA Vector{Int64} holding the number of eigenvalues with positive real part for each continuation step (to detect stationary bifurcation)\nsol::Any\nVector of solutions sampled along the branch. This is set by the argument saveSolEveryNsteps::Int64 (default 0) in ContinuationPar\ncontparams::ContinuationPar\nThe parameters used for the call to continuation which produced this branch.\ntype::Symbol\nType of solutions computed in this branch. Default: :Equilibrium\nfunctional::Any\nStructure associated to the functional, useful for branch switching. For example, when computing periodic orbits, the functional PeriodicOrbitTrapProblem, ShootingProblem... will be saved here. Default: nothing\nparams::Any\nParameters passed to continuation and used in the equation F(x, par) = 0 Default: nothing\nparam_lens::Setfield.Lens\nParameter axis used for computing the branch\nbifpoint::Array{Biftype,1} where Biftype\nA vector holding the set of bifurcation points (other than fold) detected during the computation of the branch. See GenericBifPoint for a description of the fields.\n\nAssociated methods\n\nlength(br) number of the continuation steps\neigenvals(br, ind) returns the eigenvalues for the ind-th continuation step\neigenvec(br, ind, indev) returns the indev-th eigenvector for the ind-th continuation step\n\n\n\n\n\n","category":"type"},{"location":"library/#Problems-1","page":"Library","title":"Problems","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"DeflationOperator","category":"page"},{"location":"library/#BifurcationKit.DeflationOperator","page":"Library","title":"BifurcationKit.DeflationOperator","text":"DeflationOperator. It is used to handle the following situation. Assume you want to solve F(x)=0 with a Newton algorithm but you want to avoid the process to return some already known solutions roots_i. The deflation operator penalizes these roots ; the algorithm works very well despite its simplicity. You can use DeflationOperator to define a function M(u) used to find, with Newton iterations, the zeros of the following function F(u) cdot Π_i(dot(u - roots_i u - roots_i)^-p + shift) = F(u) cdot M(u). The fields of the struct DeflationOperator are as follows:\n\npower p\ndot function, this function has to be bilinear and symmetric for the linear solver to work well\nshift\nroots\n\nThe deflation operator is is M(u) = prod_i=1^n_roots(shift + norm(u-roots_i)^-p) where norm(u) = dot(uu).\n\nGiven defOp::DeflationOperator, one can access its roots as defOp[n] as a shortcut for defOp.roots[n]. Also, one can add (resp.remove) a new root by using push!(defOp, newroot) (resp. pop!(defOp)). Finally length(defOp) is a shortcut for length(defOp.roots)\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"DeflatedProblem","category":"page"},{"location":"library/#BifurcationKit.DeflatedProblem","page":"Library","title":"BifurcationKit.DeflatedProblem","text":"pb = DeflatedProblem(F, J, M::DeflationOperator)\n\nThis creates a deflated problem M(u) cdot F(u) = 0 where M is a DeflationOperator which encodes the penalization term. J is the jacobian of F. Can be used to call newton and continuation.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"PeriodicOrbitTrapProblem","category":"page"},{"location":"library/#BifurcationKit.PeriodicOrbitTrapProblem","page":"Library","title":"BifurcationKit.PeriodicOrbitTrapProblem","text":"pb = PeriodicOrbitTrapProblem(F, J, ϕ, xπ, M::Int)\n\nThis composite type implements Finite Differences based on a Trapezoidal rule to locate periodic orbits. The arguments are as follows\n\nF(x,p) vector field\nJ is the jacobian of F at (x, p). It can assume three forms.\nEither J is a function and J(x,p) returns a ::AbstractMatrix. In this case, the default arguments of contParams::ContinuationPar will make continuation work.\nOr J is a function and J(x, p) returns a function taking one argument dx and returning dr of the same type as dx. In our notation, dr = J * dx. In this case, the default parameters of contParams::ContinuationPar will not work and you have to use a Matrix Free linear solver, for example GMRESIterativeSolvers,\nOr J is a function and J(x, p) returns a variable j which can assume any type. Then, you must implement a linear solver ls as a composite type, subtype of AbstractLinearSolver which is called like ls(j, rhs) and which returns the solution of the jacobian linear system. See for example examples/SH2d-fronts-cuda.jl. This linear solver is passed to NewtonPar(linsolver = ls) which itself passed to ContinuationPar. Similarly, you have to implement an eigensolver eig as a composite type, subtype of AbstractEigenSolver.\nJt = nothing jacobian tranpose of F (optional), useful for continuation of Fold of periodic orbits. it should not be passed in case the jacobian is a (sparse) matrix as it is computed internally, and it would be computed twice in that case.\nd2F = nothing second derivative of F (optional), useful for continuation of Fold of periodic orbits. It has the definition d2F(x,p,dx1,dx2).`\nϕ used to set a section for the phase constraint equation\nxπ used in the section for the phase constraint equation\nM::Int number of time slices\nlinsolver: = DefaultLS() linear solver for each time slice, i.e. to solve J⋅sol = rhs. This is only needed for the computation of the Floquet multipliers.\nisinplace::Bool whether F and J are inplace functions (Experimental). In this case, the functions F and J must have the following definitions (o, x, p) ->  F(o, x, p) and (o, x, p, dx) -> J(o, x, p, dx).\nongpu::Bool whether the computation takes place on the gpu (Experimental)\n\nYou can then call pb(orbitguess, p) to compute the functional on a orbitguess. Note that orbitguess must be of size M * N + 1 where N is the number of unknowns in the state space and orbitguess[M*N+1] is an estimate of the period of the limit cycle.\n\nThe scheme is as follows. We first consider a partition of 01 given by 0s_0cdotss_m=1 and one looks for T = x[end] such that\n\nleft(x_i - x_i-1right) - fracTcdot h_i2 left(F(x_i) + F(x_i-1)right) = 0 i=1cdotsm-1\n\nwith u_0 = u_m-1 and the periodicity condition u_m - u_1 = 0 and\n\nwhere h_1 = s_i-s_i-1. Finally, the phase of the periodic orbit is constrained by using a section\n\nlangle x1 - x_pi phirangle=0\n\nA functional, hereby called G, encodes this problem. The following methods are available\n\npb(orbitguess, p) evaluates the functional G on orbitguess\npb(orbitguess, p, du) evaluates the jacobian dG(orbitguess).du functional at orbitguess on du\npb(Val(:JacFullSparse), orbitguess, p) return the sparse matrix of the jacobian dG(orbitguess) at orbitguess without the constraints. It is called A_γ in the docs.\npb(Val(:JacFullSparseInplace), J, orbitguess, p). Same as pb(Val(:JacFullSparse), orbitguess, p) but overwrites J inplace. Note that the sparsity pattern must be the same independantly of the values of the parameters or of orbitguess. In this case, this is significantly faster than pb(Val(:JacFullSparse), orbitguess, p).\npb(Val(:JacCyclicSparse), orbitguess, p) return the sparse cyclic matrix Jc (see the docs) of the jacobian dG(orbitguess) at orbitguess\npb(Val(:BlockDiagSparse), orbitguess, p) return the diagonal of the sparse matrix of the jacobian dG(orbitguess) at orbitguess. This allows to design Jacobi preconditioner. Use blockdiag.\n\nnote: GPU call\nFor these methods to work on the GPU, for example with CuArrays in mode allowscalar(false), we face the issue that the function extractPeriodFDTrap won't be well defined because it is a scalar operation. One may have to redefine it like extractPeriodFDTrap(x::CuArray) = x[end:end] or something else. Also, note that you must pass the option ongpu = true for the functional to be evaluated efficiently on the gpu.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"ShootingProblem","category":"page"},{"location":"library/#BifurcationKit.ShootingProblem","page":"Library","title":"BifurcationKit.ShootingProblem","text":"pb = ShootingProblem(flow::Flow, ds, section; parallel = false)\n\nThis composite type creates a problem to implement the Standard Simple / Parallel Multiple Standard Shooting method to locate periodic orbits. The arguments are as follows\n\nflow::Flow: implements the flow of the Cauchy problem though the structure Flow.\nds: vector of time differences for each shooting. Its length is written M. If M==1, then the simple shooting is implemented and the multiple one otherwise.\nsection: implements a phase condition. The evaluation section(x) must return a scalar number where x is a guess for the periodic orbit. Note that the period T of the guess x is always included either as the last component of T = x[end] or as T = x.p. The type of x depends on what is passed to the newton solver. See SectionSS for a type of section defined as a hyperplane.\nparallel whether the shooting are computed in parallel (threading). Available through the use of Flows defined by EnsembleProblem.\n\nA functional, hereby called G, encodes the shooting problem. For example, the following methods are available:\n\npb(orbitguess, par) evaluates the functional G on orbitguess\npb(orbitguess, par, du) evaluates the jacobian dG(orbitguess).du functional at orbitguess on du\n\nYou can then call pb(orbitguess, par) to apply the functional to a guess. Note that orbitguess::AbstractVector must be of size M * N + 1 where N is the number of unknowns of the state space and orbitguess[M * N + 1] is an estimate of the period T of the limit cycle. This form of guess is convenient for the use of the linear solvers in IterativeSolvers.jl (for example) which accepts only AbstractVectors. Another accepted guess is of the form BorderedArray(guess, T) where guess[i] is the state of the orbit at the ith time slice. This last form allows for non-vector state space which can be convenient for 2d problems for example, use GMRESKrylovKit for the linear solver in this case.\n\nSimplified constructors\n\nA simpler way to build the functional is to use\n\npb = ShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, centers::AbstractVector; kwargs...)\n\nwhere F(x,p) is the vector field, p is a parameter (to be passed to the vector field and the flow), prob is an ODEProblem (resp. EnsembleProblem) which is used to create a flow using the ODE solver alg (for example Tsit5()). centers is list of M points close to the periodic orbit, they will be used to build a constraint for the phase. parallel = false is an option to use Parallel simulations (Threading) to simulate the multiple trajectories in the case of multiple shooting. This is efficient when the trajectories are relatively long to compute. Finally, the arguments kwargs are passed to the ODE solver defining the flow. Look at DifferentialEquations.jl for more information. Note that, in this case, the derivative of the flow is computed internally using Finite Differences.\n\nAnother way to create a Shooting problem with more options is the following where in particular, one can provide its own scalar constraint section(x)::Number for the phase\n\npb = ShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; parallel = false, kwargs...)\n\nor\n\npb = ShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, ds, section; parallel = false, kwargs...)\n\nThe next way is an elaboration of the previous one\n\npb = ShootingProblem(F, p, prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, M::Int, section; parallel = false, kwargs...)\n\nor\n\npb = ShootingProblem(F, p, prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, ds, section; parallel = false, kwargs...)\n\nwhere we supply now two ODEProblems. The first one prob1, is used to define the flow associated to F while the second one is a problem associated to the derivative of the flow. Hence, prob2 must implement the following vector field tilde F(xyp) = (F(xp)dF(xp)cdot y).\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"PoincareShootingProblem","category":"page"},{"location":"library/#BifurcationKit.PoincareShootingProblem","page":"Library","title":"BifurcationKit.PoincareShootingProblem","text":"pb = PoincareShootingProblem(flow::Flow, M, sections; δ = 1e-8, interp_points = 50, parallel = false)\n\nThis composite type implements the Poincaré Shooting method to locate periodic orbits by relying on Poincaré return maps. The arguments are as follows\n\nflow::Flow: implements the flow of the Cauchy problem though the structure Flow.\nM: the number of Poincaré sections. If M==1, then the simple shooting is implemented and the multiple one otherwise.\nsections: function or callable struct which implements a Poincaré section condition. The evaluation sections(x) must return a scalar number when M==1. Otherwise, one must implement a function section(out, x) which populates out with the M sections. See SectionPS for type of section defined as a hyperplane.\nδ = 1e-8 used to compute the jacobian of the fonctional by finite differences. If set to 0, an analytical expression of the jacobian is used instead.\ninterp_points = 50 number of interpolation point used to define the callback (to compute the hitting of the hyperplan section)\nparallel = false whether the shooting are computed in parallel (threading). Only available through the use of Flows defined by EnsembleProblem.\n\nSimplified constructors\n\nA simpler way is to create a functional is\n\npb = PoincareShootingProblem(F, p, prob::ODEProblem, alg, section; kwargs...)\n\nfor simple shooting or\n\npb = PoincareShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; kwargs...)\n\nfor multiple shooting . Here F(x,p) is the vector field, p is a parameter (to be passed to the vector and the flow), prob is an Union{ODEProblem, EnsembleProblem} which is used to create a flow using the ODE solver alg (for example Tsit5()). Finally, the arguments kwargs are passed to the ODE solver defining the flow. We refere to DifferentialEquations.jl for more information.\n\nAnother convenient call is\n\npb = PoincareShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, normals::AbstractVector, centers::AbstractVector; δ = 1e-8, kwargs...)\n\nwhere normals (resp. centers) is a list of normals (resp. centers) which defines a list of hyperplanes Sigma_i. These hyperplanes are used to define partial Poincaré return maps.\n\nComputing the functionals\n\nA functional, hereby called G encodes this shooting problem. You can then call pb(orbitguess, par) to apply the functional to a guess. Note that orbitguess::AbstractVector must be of size M * N where N is the number of unknowns in the state space and M is the number of Poincaré maps. Another accepted guess is such that guess[i] is the state of the orbit on the ith section. This last form allows for non-vector state space which can be convenient for 2d problems for example.\n\npb(orbitguess, par) evaluates the functional G on orbitguess\npb(orbitguess, par, du) evaluates the jacobian dG(orbitguess).du functional at orbitguess on du\n\ntip: Tip\nYou can use the function getPeriod(pb, sol, par) to get the period of the solution sol for the problem with parameters par.\n\n\n\n\n\n","category":"type"},{"location":"library/#Misc.-1","page":"Library","title":"Misc.","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"PrecPartialSchurKrylovKit","category":"page"},{"location":"library/#BifurcationKit.PrecPartialSchurKrylovKit","page":"Library","title":"BifurcationKit.PrecPartialSchurKrylovKit","text":"PrecPartialSchurKrylovKit(J, x0, nev, which = :LM; krylovdim = max(2nev, 20), verbosity = 0)\n\nBuilds a preconditioner based on deflation of nev eigenvalues chosen according to which. A partial Schur decomposition is computed (Matrix-Free), using the package KrylovKit.jl, from which a projection is built. The options are similar to the ones of EigKrylovKit().\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"PrecPartialSchurArnoldiMethod","category":"page"},{"location":"library/#BifurcationKit.PrecPartialSchurArnoldiMethod","page":"Library","title":"BifurcationKit.PrecPartialSchurArnoldiMethod","text":"PrecPartialSchurArnoldiMethod(J, N, nev, which = LM(); tol = 1e-9, kwargs...)\n\nBuilds a preconditioner based on deflation of nev eigenvalues chosen according to which. A partial Schur decomposition is computed (Matrix-Free), using the package ArnoldiMethod.jl, from which a projection is built. See the package ArnoldiMethod.jl for how to pass the proper options.\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"Flow","category":"page"},{"location":"library/#BifurcationKit.Flow","page":"Library","title":"BifurcationKit.Flow","text":"struct Flow{TF, Tf, Tts, Tff, Td, Tse}\n\nF::Any\nThe vector field (x, p) -> F(x, p) associated to a Cauchy problem,\nflow::Any\nThe flow (or semigroup) associated to the Cauchy problem (x, p, t) -> flow(x, p, t). Only the last time point must be returned.\nflowTimeSol::Any\nFlow which returns the tuple (t, u(t)). Optional, mainly used for plotting on the user side. Please use nothing as default.\nflowFull::Any\nThe flow (or semigroup) associated to the Cauchy problem (x, p, t) -> flow(x, p, t). The whole solution on the time interval [0,t] must be returned. It is not strictly necessary to provide this, mainly used for plotting on the user side. Please use nothing as default.\ndflow::Any\nThe differential dflow of the flow w.r.t. x, (x, p, dx, t) -> dflow(x, p, dx, t). One important thing is that we require dflow(x, dx, t) to return a Named Tuple: (t = t, u = flow(x, p, t), du = dflow(x, p, dx, t)), the last composant being the value of the derivative of the flow.\ndfserial::Any\nSerial version of dflow. Used internally when using parallel multiple shooting. Please use nothing as default.\n\nSimplified constructor(s)\n\nWe provide a simple constructor where you only pass the vector fiels F, the flow ϕ and its differential dϕ:\n\nfl = Flow(F, ϕ, dϕ)\n\nSimplified constructors for DifferentialEquations.jl\n\nThere are some simple constructors for which you only have to pass a prob::ODEProblem or prob::EnsembleProblem (for parallel computation) from DifferentialEquations.jl and an ODE time stepper like Tsit5(). Hence, you can do for example\n\nfl = Flow(F, prob, Tsit5(); kwargs...)\n\nwhere kwargs is passed to DiffEqBase::solve. If your vector field depends on parameters p, you can define a Flow using\n\nfl = Flow(F, p, prob, Tsit5(); kwargs...)\n\nFinally, you can pass two ODEProblem where the second one is used to compute the variational equation:\n\nfl = Flow(F, p, prob1::ODEProblem, alg1, prob2::ODEProblem, alg2; kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"FloquetQaDTrap","category":"page"},{"location":"library/#BifurcationKit.FloquetQaDTrap","page":"Library","title":"BifurcationKit.FloquetQaDTrap","text":"floquet = FloquetQaDTrap(eigsolver::AbstractEigenSolver)\n\nThis composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems based on Finite Differences (Trapeze method), also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations. The arguments are as follows:\n\neigsolver::AbstractEigenSolver solver used to compute the eigenvalues.\n\nIf eigsolver isa DefaultEig, then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.\n\ndanger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver eigsolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of eigsolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"FloquetQaDShooting","category":"page"},{"location":"library/#BifurcationKit.FloquetQaDShooting","page":"Library","title":"BifurcationKit.FloquetQaDShooting","text":"floquet = FloquetQaDShooting(eigsolver::AbstractEigenSolver)\n\nThis composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems based on the Shooting method, also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. It allows, nevertheless, to detect bifurcations. The arguments are as follows:\n\neigsolver::AbstractEigenSolver solver used to compute the eigenvalues.\n\nIf eigsolver == DefaultEig(), then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.\n\ndanger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver eigsolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of eigsolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"guessFromHopf(br, ind_hopf, eigsolver::AbstractEigenSolver, M, amplitude; phase = 0)","category":"page"},{"location":"library/#BifurcationKit.guessFromHopf-Tuple{Any,Any,AbstractEigenSolver,Any,Any}","page":"Library","title":"BifurcationKit.guessFromHopf","text":"guessFromHopf(br, ind_hopf, eigsolver::AbstractEigenSolver, M, amplitude; phase = 0)\n\nThis function returns several useful quantities regarding a Hopf bifurcation point. More precisely, it returns:\n\nthe parameter value at which a Hopf bifurcation occurs\nthe period of the bifurcated periodic orbit\na guess for the bifurcated periodic orbit\nthe equilibrium at the Hopf bifurcation point\nthe eigenvector at the Hopf bifurcation point.\n\nThe arguments are\n\nbr: the continuation branch which lists the Hopf bifurcation points\nind_hopf: index of the bifurcation branch, as in br.bifpoint\neigsolver: the eigen solver used to find the eigenvectors\nM number of time slices in the periodic orbit guess\namplitude: amplitude of the periodic orbit guess\n\n\n\n\n\n","category":"method"},{"location":"library/#","page":"Library","title":"Library","text":"computeNormalForm","category":"page"},{"location":"library/#BifurcationKit.computeNormalForm","page":"Library","title":"BifurcationKit.computeNormalForm","text":"computeNormalForm(F, dF, d2F, d3F, br, id_bif; δ, nev, Jt, verbose, ζs, lens, issymmetric, Teigvec, scaleζ)\n\n\nCompute the normal form of the bifurcation point located at br.bifpoint[ind_bif].\n\nArguments\n\nF, dF, d2F, d3F vector field (x, p) -> F(x, p) and its derivatives w.r.t. x.\nbr result from a call to continuation\nind_bif index of the bifurcation point in br.bifpoint\n\nOptional arguments\n\nδ used to compute ∂pF with finite differences\nnev number of eigenvalues used to compute the spectral projection. This number has to be adjusted when used with iterative methods.\nJt = (x,p) -> ... jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jt should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass Jt = (x, p) -> transpose(dF(x, p)).\nverbose whether to display information\nζs list of vectors spanning the kernel of dF at the bifurcation point. Useful to enforce the basis for the normal form.\nlens::Lens specify which parameter to take the partial derivative ∂pF\nissymmetric whether the Jacobian is Symmetric, avoid computing the left eigenvectors.\nscaleζ function to normalise the kernel basis. Indeed, when used with large vectors and norm, it results in ζs and the normal form coeffocient being super small.\n\nBased on Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295.\n\n\n\n\n\n","category":"function"},{"location":"library/#Newton-1","page":"Library","title":"Newton","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"newton","category":"page"},{"location":"library/#BifurcationKit.newton","page":"Library","title":"BifurcationKit.newton","text":"\tnewton(F, J, x0, p0, options::NewtonPar; normN = norm, callback = (x, f, J, res, iteration, itlinear, optionsN; kwargs...) -> true, kwargs...)\n\nThis is the Newton-Krylov Solver for F(x, p0) = 0 with Jacobian w.r.t. x written J(x, p0) and initial guess x0. The function normN allows to specify a norm for the convergence criteria. It is important to set the linear solver options.linsolver properly depending on your problem. This linear solver is used to solve J(x p_0)u = -F(x p_0) in the Newton step. You can for example use linsolver = DefaultLS() which is the operator backslash: it works well for Sparse / Dense matrices. See Linear solvers for more informations.\n\nArguments:\n\nF is a function with input arguments (x, p) returning a vector r that represents the functional and for type stability, the types of x and r should match. In particular, it is not inplace.\nJ is the jacobian of F at (x, p). It can assume two forms. Either J is a function and J(x, p) returns a ::AbstractMatrix. In this case, the default arguments of NewtonPar will make newton work. Or J is a function and J(x, p) returns a function taking one argument dx and returns dr of the same type of dx. In our notation, dr = J * dx. In this case, the default parameters of NewtonPar will not work and you have to use a Matrix Free linear solver, for example GMRESIterativeSolvers.\nx0 initial guess\np0 set of parameters to be passed to F and J\noptions variable holding the internal parameters used by the newton method\ncallback function passed by the user which is called at the end of each iteration. Can be used to update a preconditionner for example. The arguments passed to the callback are as follows\nx current solution\nf current residual\nJ current jacobian\nres current norm of the residual\niteration current newton iteration\nitlinear number of iterations to solve the linear system\noptionsN a copy of the argument options passed to newton\nkwargs kwargs arguments, contain your initial guess x0\nkwargs arguments passed to the callback. Useful when newton is called from continuation\n\nOutput:\n\nsolution:\nhistory of residuals\nflag of convergence\nnumber of iterations\n\nSimplified calls\n\nWhen J is not passed, the jacobian matrix is then computed with finite differences (beware of large systems of equations!). The call is as follows:\n\nnewton(F, x0, p0, options::NewtonPar; kwargs...)\n\nYou can also pass functions which do not have parameters x -> F(x), x -> J(x) as follows\n\nnewton(F, J, x0, options::NewtonPar;  kwargs...)\n\nor\n\nnewton(F, x0, options::NewtonPar;  kwargs...)\n\nExample\n\njulia> F(x, p) = x.^3 .- 1\njulia> Jac(x, p) = spdiagm(0 => 3 .* x.^2) # sparse jacobian\njulia> x0 = rand(1_000)\njulia> opts = NewtonPar()\njulia> sol, hist, flag, _ = newton(F, Jac, x0, nothing, opts, normN = x->norm(x, Inf))\n\ntip: Other formulation\nIf you don't have parameters, you can still use newton as follows newton((x,p) -> F(x), (x,p)-> J(x), x0, nothing, options)\n\nwarning: Linear solver\nMake sure that the linear solver (Matrix-Free...) corresponds to you jacobian (Matrix-Free vs. Matrix based).\n\n\n\n\n\nfunction newton(F, J, x0::vectype, p0, options:: NewtonPar{T}, defOp::DeflationOperator{T, Tf, vectype}, linsolver = DeflatedLinearSolver(); kwargs...) where {T, Tf, vectype}\n\nThis is the deflated version of the Krylov-Newton Solver for F(x, p0) = 0 with Jacobian J(x, p0). We refer to newton for more information. It penalises the roots saved in defOp.roots. The other arguments are as for newton. See DeflationOperator for more information.\n\nArguments\n\nCompared to newton, the only different arguments are\n\ndefOp deflation operator\nlinsolver linear solver used to invert the Jacobian of the deflated functional. We have a custom solver DeflatedLinearSolver() with requires solving two linear systems J⋅x = rhs. For other linear solvers, a matrix free method is used for the deflated functional.\n\nOutput:\n\nsolution:\nhistory of residuals\nflag of convergence\nnumber of iterations\n\nSimplified call\n\nWhen J is not passed. It then computed with finite differences. The call is as follows:\n\nnewton(F, x0, p0, options, defOp; kwargs...)\n\n\n\n\n\nThis specific Newton-Kyrlov method first tries to converge to a solution sol0 close the guess x0. It then attempts to converge to the guess x1 while avoiding the previous solution sol0. This is very handy for branch switching. The mnethod is based on a deflated Newton-Krylov solver.\n\n\n\n\n\nnewton(F, J, br, ind_bif, par, lens; Jt, d2F, normN, options, kwargs...)\n\n\nThis function turns an initial guess for a Fold/Hopf point into a solution to the Fold/Hopf problem based on a Minimally Augmented formulation. The arguments are as follows\n\nF   = (x, p) -> F(x, p) where p is a set of parameters.\nJ  = (x, p) -> d_xF(x, p) associated jacobian\nbr results returned after a call to continuation\nind_bif bifurcation index in br\npar parameters used for the vector field\nlens parameter axis used to locate the Fold/Hopf point.\noptions::NewtonPar\n\nOptional arguments:\n\nJt = (x, p) -> transpose(d_xF(x, p)) jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jt should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass Jt = (x, p) -> transpose(dF(x, p))\nd2F = (x, p, v1, v2) ->  d2F(x, p, v1, v2) a bilinear operator representing the hessian of F. It has to provide an expression for d2F(x,p)[v1,v2].\nnormN = norm\noptions You can pass newton parameters different from the ones stored in br by using this argument options.\nkwargs keywords arguments to be passed to the regular Newton-Krylov solver\n\n\n\n\n\nnewton(prob, orbitguess, par, options; kwargs...)\n\n\nThis is the Newton-Krylov Solver for computing a periodic orbit using (Standard / Poincaré) Shooting method. Note that the linear solver has to be apropriately set up.\n\nArguments\n\nSimilar as newton except that prob is either a ShootingProblem or a PoincareShootingProblem. These two problems have specific options to be tuned, we refer to their link for more information and to the tutorials.\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\nnewton(prob, orbitguess, par, options, defOp; linearPO, kwargs...)\n\n\nThis is the deflated Newton-Krylov Solver for computing a periodic orbit using a (Standard / Poincaré) Shooting method.\n\nArguments\n\nSimilar as newton except that prob is either a ShootingProblem or a PoincareShootingProblem.\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\nnewton(probPO, orbitguess, par, options; linearPO, kwargs...)\n\n\nThis is the Newton-Krylov Solver for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.\n\nArguments:\n\nprob a problem of type PeriodicOrbitTrapProblem encoding the functional G\norbitguess a guess for the periodic orbit where orbitguess[end] is an estimate of the period of the orbit. It should be a vector of size N * M + 1 where M is the number of time slices, N is the dimension of the phase space. This must be compatible with the numbers N,M in prob.\noptions same as for the regular newton method\nlinearPO = :BorderedLU. Specify the choice of the linear algorithm, which must belong to [:FullLU, :FullSparseInplace, :BorderedLU, :FullMatrixFree, :BorderedMatrixFree, :FullSparseInplace]. This is used to select a way of inverting the jacobian dG of the functional G.\nFor :FullLU, we use the default linear solver based on a sparse matrix representation of dG. This matrix is assembled at each newton iteration.\nFor :FullSparseInplace, this is the same as for :FullLU but the sparse matrix dG is updated inplace. This method allocates much less. In some cases, this is significantly faster than using :FullLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor :Dense, same as above but the matrix dG is dense. It is also updated inplace. This option is useful to study ODE of small dimension.\nFor :BorderedLU, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert dG using a bordered linear solver. This is the default algorithm.\nFor :FullMatrixFree, a matrix free linear solver is used for dG: note that a preconditioner is very likely required here because of the cyclic shape of dG which affects negatively the convergence properties of GMRES.\nFor :BorderedMatrixFree, a matrix free linear solver is used but for Jc only (see docs): it means that options.linsolver is used to invert Jc. These two Matrix-Free options thus expose different part of the jacobian dG in order to use specific preconditioners. For example, an ILU preconditioner on Jc could remove the constraints in dG and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.\n\nOutput:\n\nsolution\nhistory of residuals\nflag of convergence\nnumber of iterations\n\n\n\n\n\nnewton(probPO::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, defOp::DeflationOperator{T, Tf, vectype}, linearPO = :BorderedLU; kwargs...) where {T, Tf, vectype}\n\nThis function is similar to newton(probPO, orbitguess, options, linearPO; kwargs...) except that it uses deflation in order to find periodic orbits different from the ones stored in defOp. We refer to the mentioned method for a full description of the arguments. The current method can be used in the vicinity of a Hopf bifurcation to prevent the Newton-Krylov algorithm from converging to the equilibrium point.\n\n\n\n\n\n","category":"function"},{"location":"library/#Continuation-1","page":"Library","title":"Continuation","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"continuation","category":"page"},{"location":"library/#BifurcationKit.continuation","page":"Library","title":"BifurcationKit.continuation","text":"continuation(F, J, x0, par, lens::Lens, contParams::ContinuationPar; plot = false, normC = norm, dotPALC = (x,y) -> dot(x,y) / length(x), printSolution = norm, plotSolution = (x, p; kwargs...)->nothing, finaliseSolution = (z, tau, step, contResult) -> true, callbackN = (x, f, J, res, iteration, itlinear, options; kwargs...) -> true, linearAlgo = BorderingBLS(), tangentAlgo = SecantPred(), verbosity = 0)\n\nCompute the continuation curve associated to the functional F and its jacobian J.\n\nArguments:\n\nF is a function with input arguments (x, p), where p is the set of parameters passed to F, and returning a vector r that represents the functional. For type stability, the types of x and r should match. In particular, it is not inplace,\nJ is the jacobian of F at (x, p). It can assume three forms.\nEither J is a function and J(x,p) returns a ::AbstractMatrix. In this case, the default arguments of contParams::ContinuationPar will make continuation work.\nOr J is a function and J(x, p) returns a function taking one argument dx and returning dr of the same type as dx. In our notation, dr = J * dx. In this case, the default parameters of contParams::ContinuationPar will not work and you have to use a Matrix Free linear solver, for example GMRESIterativeSolvers,\nOr J is a function and J(x, p) returns a variable j which can assume any type. Then, you must implement a linear solver ls as a composite type, subtype of AbstractLinearSolver which is called like ls(j, rhs) and which returns the solution of the jacobian linear system. See for example examples/SH2d-fronts-cuda.jl. This linear solver is passed to NewtonPar(linsolver = ls) which itself passed to ContinuationPar. Similarly, you have to implement an eigensolver eig as a composite type, subtype of AbstractEigenSolver.\nx0 initial guess,\npar initial set of parameters,\nlens::Lens specifies which parameter axis among par is used for continuation. For example, if par = (α = 1.0, β = 1), we can perform continuation w.r.t. α by using lens = (@lens _.α). If you have an array par = [ 1.0, 2.0] and want to perform continuation w.r.t. the first variable, you can use lens = (@lens _[1]). For more information, we refer to SetField.jl.\ncontParams parameters for continuation. See ContinuationPar for more information about the options\n\nOptional Arguments:\n\nplot = false whether to plot the solution while computing\nprintSolution = (x, p) -> norm(x) function used to plot in the continuation curve. It is also used in the way results are saved. It could be norm or (x, p) -> x[1]. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...). This function can return pretty much everything but you should keep it small. For example, you can do (x, p) -> (x1 = x[1], x2 = x[2], nrm = norm(x)) or simply (x, p) -> (sum(x), 1). This will be stored in contres.branch (see below).\nplotSolution = (x, p; kwargs...) -> nothing function implementing the plot of the solution.\nfinaliseSolution = (z, tau, step, contResult; kwargs...) -> true Function called at the end of each continuation step. Can be used to alter the continuation procedure (stop it by returning false), saving personal data, plotting... The notations are z=(xp), tau is the tangent at z (see below), step is the index of the current continuation step and ContResult is the current branch. Note that you can have a better control over the continuation procedure by using an iterator, see Iterator Interface.\ncallbackN callback for newton iterations. see docs for newton. Can be used to change preconditioners\ntangentAlgo = SecantPred() controls the algorithm used to predict the tangents along the curve of solutions or the corrector. Can be NaturalPred, SecantPred or BorderedPred. See below for more information.\nlinearAlgo = BorderingBLS(). Used to control the way the extended linear system associated to the continuation problem is solved. Can be MatrixBLS, BorderingBLS or MatrixFreeBLS.\nverbosity::Int controls the amount of information printed during the continuation process. Must belong to {0,1,2,3}\nnormC = norm norm used in the different Newton solves\ndotPALC = (x, y) -> dot(x, y) / length(x), dot product used to define the weighted dot product (resp. norm) (x p)^2_theta in the constraint N(x p) (see below). This arguement can be used to remove the factor 1/length(x) for example in problems where the dimension of the state space changes (mesh adaptation, ...)\nfilename name of a file to save the computed branch during continuation. The identifier .jld2 will be appended to this filename\n\nOutputs:\n\ncontres::ContResult composite type which contains the computed branch. See ContResult for more information.\nu::BorderedArray the last solution computed on the branch\n\ntip: Controlling the argument `linearAlgo`\nIn this simplified interface to continuation, the argument linearAlgo is internally overwritten to provide a valid argument to the algorithm. If you do not want this to happen, call directly continuation(F, J, x0, par, lens, contParams, linearAlgo; kwargs...).\n\nSimplified call:\n\nYou can also use the following call for which the jacobian matrix (beware of large systems of equations!) is computed internally using Finite Differences\n\ncontinuation(Fhandle, x0, par, lens, contParams::ContinuationPar; kwargs...)\n\nMethod\n\nBordered system of equations\n\nIn what follows, we abuse of notations, p refers to the scalar value of the parameter we perform continuation with. Hence, it should be p = get(par, lens).\n\nThe pseudo-arclength continuation method solves the equation F(x p) = 0 (of dimension N) together with the pseudo-arclength constraint N(x p) = fracthetalength(x) langle x - x_0 dx_0rangle + (1 - theta)cdot(p - p_0)cdot dp_0 - ds = 0 and thetain01 (see Keller, Herbert B. Lectures on Numerical Methods in Bifurcation Problems. Springer, 1988). In practice, a curve gamma of solutions is sought and is parametrised by s: gamma(s) = (x(s) p(s)) is a curve of solutions to F(x p). This formulation allows to pass turning points (where the implicit theorem fails). In the previous formula, (x_0 p_0) is a solution for a given s_0, tau_0equiv(dx_0 dp_0) is the tangent to the curve gamma at s_0. Hence, to compute the curve of solutions, we need to solve an equation of dimension N+1 which is called a Bordered system.\n\nwarning: Parameter `theta`\nThe parameter theta in the struct ContinuationParis very important. It should be tuned for the continuation to work properly especially in the case of large problems where the langle x - x_0 dx_0rangle component in the constraint might be favoured too much. Also, large thetas favour p as the corresponding term in N involves the term 1-theta.\n\nThe parameter ds is adjusted internally depending on the number of Newton iterations and other factors. See the function stepSizeControl for more information. An important parameter to adjust the magnitude of this adaptation is the parameter a in the struct ContinuationPar.\n\nAlgorithm\n\nThe algorithm works as follows:\n\nStart from a known solution (x_0 p_0) with tangent to the curve of solutions: (dx_0 dp_0)\nPredictor: set (x_1 p_1) = (x_0 p_0) + dscdot (dx_0 dp_0). Note that a different predictor can be used.\nCorrector: solve F(x p)=0 N(x p)=0 with a (Bordered) Newton Solver with initial guess (x_1 p_1).\nif Newton in 3. did not converge, update ds/2 ⟶ ds in N and go to 1.\nNew tangent: Compute a new tangent (see below) (dx_1 dp_1) and update N with it. Set (x_0 p_0 dx_0 dp_0) = (x_1 p_1 dx_1 dp_1) and return to step 2\n\nNatural continuation\n\nWe speak of natural continuation when we do not consider the constraint N(x p)=0. Knowing (x_0 p_0), we use x_0 as a guess for solving F(x p_1)=0 with p_1 close to p_0. Again, this fails at Turning points but it can be faster to compute than the constrained case. This is set by the option tangentAlgo = NaturalPred() in continuation.\n\nTangent computation (step 4)\n\nThere are various ways to compute (dx_1 dp_1). The first one is called secant and is parametrised by the option tangentAlgo = SecantPred(). It is computed by (dx_1 dp_1) = (z_1 p_1) - (z_0 p_0) and normalised by the norm (x p)^2_theta = fracthetalength(x) langle xxrangle + (1 - theta)cdot p^2. Another method is to compute (dx_1 dp_1) by solving solving the bordered linear system beginbmatrix F_x  F_p\t  fracthetalength(x)dx_0  (1-theta)dp_0endbmatrixbeginbmatrixdx_1   dp_1endbmatrix =beginbmatrix0  1endbmatrix ; it is set by the option tangentAlgo = BorderedPred().\n\nBordered linear solver\n\nWhen solving the Bordered system F(x p) = 0 N(x p)=0, one faces the issue of solving the Bordered linear system beginbmatrix J  a\t b^T  cendbmatrixbeginbmatrixX   yendbmatrix =beginbmatrixR  nendbmatrix. This can be solved in many ways via bordering (which requires two Jacobian inverses), by forming the bordered matrix (which works well for sparse matrices) or by using a full Matrix Free formulation. The choice of method is set by the argument linearAlgo. Have a look at the struct linearBorderedSolver for more information.\n\nLinear Algebra\n\nLet us discuss here more about the norm and dot product. First, the option normC gives a norm that is used to evaluate the residual in the following way: max(normC(F(xp)) N(xp))tol. It is thus used as a stopping criterion for a Newton algorithm. The dot product (resp. norm) used in N and in the (iterative) linear solvers is LinearAlgebra.dot (resp. LinearAlgebra.norm). It can be changed by importing these functions and redefining it. Not that by default, the L^2 norm is used. These details are important because of the constraint N which incorporates the factor length. For some custom composite type implementing a Vector space, the dot product could already incorporates the length factor in which case you should either redefine the dot product or change theta.\n\nStep size control\n\nAs explained above, each time the corrector phased failed, the step size ds is halved. This has the disavantage of having lost Newton iterations (which costs time) and impose small steps (which can be slow as well). To prevent this, the step size is controlled internally with the idea of having a constant number of Newton iterations per point. This is in part controlled by the aggressiveness factor a in ContinuationPar. Further tuning is performed by using doArcLengthScaling=true in ContinuationPar. This adjusts internally theta so that the relative contributions of x and p are balanced in the constraint N.\n\n\n\n\n\ncontinuation(Fhandle, Jhandle, x0, par0, x1, p1, lens, contParams; linearAlgo, kwargs...)\n\n\nThis function is the analog of continuation when the two first points on the branch are passed (instead of a single one). Hence x0 is the first point on the branch (with palc s=0) with parameter par0 and x1 is the second point with parameter set(par0, lens, p1).\n\n\n\n\n\ncontinuation(F, dF, d2F, d3F, br, ind_bif, optionsCont; Jt, δ, δp, ampfactor, nev, issymmetric, usedeflation, Teigvec, scaleζ, verbosedeflation, maxIterDeflation, perturb, kwargs...)\n\n\nAutomatic branch switching at branch points based on a computation of the normal form. More information is provided in Branch switching. An example of use is provided in A generalized Bratu–Gelfand problem in two dimensions.\n\nArguments\n\nF, dF, d2F, d3F: function (x, p) -> F(x, p) and its differentials (x, p, dx) -> d1F(x, p, dx), (x, p, dx1, dx2) -> d2F(x, p, dx1, dx2)...\nbr branch result from a call to continuation\nind_bif index of the bifurcation point in br from which you want to branch from\noptionsCont options for the call to continuation\n\nOptional arguments\n\nJt associated jacobian transpose, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jt should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass Jt = (x, p) -> transpose(dF(x, p)).\nδ used internally to compute derivatives w.r.t the parameter p.\nδp used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by optionsCont.ds. This allows to use a step larger than optionsCont.dsmax.\nampfactor = 1 factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nnev number of eigenvalues to be computed to get the right eigenvector\nissymmetric whether the Jacobian is Symmetric, avoid computing the left eigenvectors in the computation of the reduced equation.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nkwargs optional arguments to be passed to continuation, the regular continuation one.\n\ntip: Advanced use\nIn the case of a very large model and use of special hardware (GPU, cluster), we suggest to discouple the computation of the reduced equation, the predictor and the bifurcated branches. Have a look at methods(BifurcationKit.multicontinuation) to see how to call these versions. It has been tested on GPU with very high memory pressure.\n\n\n\n\n\ncontinuation(F, J, par, lens, contParams, defOp; verbosity, maxBranches, seekEveryStep, showplot, tangentAlgo, linearAlgo, dotPALC, printSolution, 382, plotSolution, perturbSolution, 385, callbackN, acceptSolution, normN)\n\n\nThe function computes the set of curves of solutions γ(s) = (x(s),p(s)) to the equation F(x,p)=0 based on the algorithm of deflated continuation as described in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. “The Computation of Disconnected Bifurcation Diagrams.” ArXiv:1603.00809 [Math], March 2, 2016. http://arxiv.org/abs/1603.00809.\n\nDepending on the options in contParams, it can locate the bifurcation points on each branch. Note that you can specify different predictors using tangentAlgo.\n\nArguments:\n\nF is a function with input arguments (x, p), where p is the set of parameters passed to F, and returning a vector r that represents the functional. For type stability, the types of x and r should match. In particular, it is not inplace,\nJ is the jacobian of F at (x, p). It can assume three forms.\nEither J is a function and J(x,p) returns a ::AbstractMatrix. In this case, the default arguments of contParams::ContinuationPar will make continuation work.\nOr J is a function and J(x, p) returns a function taking one argument dx and returning dr of the same type as dx. In our notation, dr = J * dx. In this case, the default parameters of contParams::ContinuationPar will not work and you have to use a Matrix Free linear solver, for example GMRESIterativeSolvers,\nOr J is a function and J(x, p) returns a variable j which can assume any type. Then, you must implement a linear solver ls as a composite type, subtype of AbstractLinearSolver which is called like ls(j, rhs) and which returns the solution of the jacobian linear system. See for example examples/SH2d-fronts-cuda.jl. This linear solver is passed to NewtonPar(linsolver = ls) which itself passed to ContinuationPar. Similarly, you have to implement an eigensolver eig as a composite type, subtype of AbstractEigenSolver.\npar initial set of parameters,\nlens::Lens specifies which parameter axis among par is used for continuation. For example, if par = (α = 1.0, β = 1), we can perform continuation w.r.t. α by using lens = (@lens _.α). If you have an array par = [ 1.0, 2.0] and want to perform continuation w.r.t. the first variable, you can use lens = (@lens _[1]). For more information, we refer to SetField.jl,\ncontParams parameters for continuation. See ContinuationPar for more information about the options,\ndefOp::DeflationOperator a Deflation Operator (see DeflationOperator) which contains the set of solution guesses for the parameter par.\n\nOptional Arguments:\n\nseekEveryStep::Int = 1 we look for additional solution, using deflated newton, every seekEveryStep step,\nmaxBranches::Int = 10 maximum number of branches considered,\nshowplot = false whether to plot the solution while computing,\nprintSolution = (x, p) -> norm(x) function used to plot in the continuation curve. It is also used in the way results are saved. It could be norm or (x, p) -> x[1]. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...),\nplotSolution = (x, p; kwargs...) -> nothing function implementing the plot of the solution,\ncallbackN callback for newton iterations. see docs for newton. Can be used to change preconditioners or affect the newton iterations. In the deflation part of the algorithm, when seeking for new branches, the callback is passed the keyword argument fromDeflatedNewton = true to tell the user can it is not in the continuation part (regular newton) of the algorithm,\ntangentAlgo = NaturalPred() controls the algorithm used to predict the tangents along the curve of solutions or the corrector. Can be NaturalPred, SecantPred or BorderedPred,\nverbosity::Int controls the amount of information printed during the continuation process. Must belong to {0,⋯,5},\nnormN = norm norm used in the different Newton solves,\ndotPALC = (x, y) -> dot(x, y) / length(x), dot product used to define the weighted dot product (resp. norm) (x p)^2_theta in the constraint N(x p) (see below). This arguement can be used to remove the factor 1/length(x) for example in problems where the dimension of the state space changes (mesh adaptation, ...),\nperturbSolution = (x, p, id) -> x .+ (1 .+ 0.001 * rand(size(x)...)), perturbation applied to the solution when trying to fimnd new solutions using Deflated Newton.\n\nOutputs:\n\ncontres::Vector{ContResult} composite type which contains the computed branches. See ContResult for more information,\nthe solutions at the last parameter value,\ncurrent parameter value.\n\n\n\n\n\ncontinuation(prob, orbitguess, par, lens, contParams; linearAlgo, kwargs...)\n\n\nThis is the continuation routine for computing a periodic orbit using a (Standard / Poincaré) Shooting method.\n\nArguments\n\nSimilar as continuation except that prob is either a ShootingProblem or a PoincareShootingProblem.\n\nprintPeriod boolean to print the period of the solution. This is useful for prob::PoincareShootingProblem as this information is not easily available.\n\n\n\n\n\ncontinuation(F, dF, d2F, d3F, br, ind_bif, _contParams, prob; Jt, δ, δp, ampfactor, usedeflation, nev, kwargs...)\n\n\nPerform automatic branch switching from a Hopf bifurcation point labelled ind_bif in the list of the bifurcated points on a previously computed branch br::ContResult. It first computes a Hopf normal form.\n\nArguments\n\nF, dF, d2F, d3F: function (x,p) -> F(x,p) and its differentials (x,p,dx) -> d1F(x,p,dx), (x,p,dx1,dx2) -> d2F(x,p,dx1,dx2)... These are used to compute the Hopf normal form.\nbr branch result from a call to continuation\nind_hopf index of the bifurcation point in br\ncontParams parameters for the call to continuation\nprob problem used to specify the way the periodic orbit is computed. It can be PeriodicOrbitTrapProblem, ShootingProblem or PoincareShootingProblem .\n\nOptional arguments\n\nlinearPO linear algorithm used for the computation of periodic orbits when prob is PeriodicOrbitTrapProblem)\nJt is the jacobian adjoint, used for computation of the eigen-elements of the jacobian adjoint, needed to compute the spectral projector for the Hopf normal form!!!!!! COMME NEWTON FOLD\nδ = 1e-8 used for finite differences\nδp used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by contParams.ds. This allows to use a step larger than contParams.dsmax.\nampfactor = 1 factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\n\nnote: Linear solver\nYou have to be carefull about the options contParams.newtonOptions.linsolver. In the case of Matrix-Free solver, you have to pass the right number of unknowns N * M + 1. Note that the options for the preconditioner are not accessible yet.\n\ntip: Jacobian tranpose\nThe adjoint of the jacobian J is computed internally when Jt = nothing by using tranpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jt = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian would be computed twice!\n\nwarning: Hessian\nThe hessian of F, when d2F is not nothing, is computed with Finite differences.\n\n\n\n\n\ncontinuation(probPO, orbitguess, par, lens, _contParams; linearPO, printSolution, linearAlgo, kwargs...)\n\n\nThis is the continuation routine for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.\n\nArguments\n\nprob::PeriodicOrbitTrapProblem encodes the functional G\norbitguess a guess for the periodic orbit where orbitguess[end] is an estimate of the period of the orbit. It could be a vector of size N * M + 1 where M is the number of time slices, N is the dimension of the phase space. This must be compatible with the numbers N, M in prob.\np0 set of parameters passed to the vector field\ncontParams same as for the regular continuation method\nlinearAlgo same as in continuation\nlinearPO = :BorderedLU. Same as newton when applied to a PeriodicOrbitTrapProblem. More precisely:\nFor :FullLU, we use the default linear solver on a sparse matrix representation of dG. This matrix is assembled at each newton iteration.\nFor :FullSparseInplace, this is the same as :FullLU but the sparse matrix dG is updated inplace. This method thus allocates much less. In some cases, this is significantly faster than using :FullLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor :Dense, same as above but the matrix dG is dense. It is also updated inplace. This option is useful to study ODE of small dimension.\nFor :BorderedLU, we take advantage of the bordered shape of the linear solver and use LU decomposition to invert dG using a bordered linear solver. This is the default algorithm.\nFor :FullMatrixFree, a matrix free linear solver is used for dG: note that a preconditioner is very likely required here because of the cyclic shape of dG which affects negatively the convergence properties of GMRES.\nFor :BorderedMatrixFree, a matrix free linear solver is used but for Jc only (see docs): it means that options.linsolver is used to invert Jc. These two Matrix-Free options thus expose different part of the jacobian dG in order to use specific preconditioners. For example, an ILU preconditioner on Jc could remove the constraints in dG and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.\n\nNote that by default, the method prints the period of the periodic orbit as function of the parameter. This can be changed by providing your printSolution argument.\n\n\n\n\n\n","category":"function"},{"location":"library/#Bifurcation-diagram-1","page":"Library","title":"Bifurcation diagram","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"bifurcationdiagram","category":"page"},{"location":"library/#BifurcationKit.bifurcationdiagram","page":"Library","title":"BifurcationKit.bifurcationdiagram","text":"bifurcationdiagram(F, dF, d2F, d3F, x0, par0, lens, level, options; usedeflation, kwargs...)\n\n\nCompute the bifurcation diagram associated with the problem F(x, p) = 0 recursively.\n\nArguments\n\nF, dF, d2F, d3F functional and its derivatives\nx0 initial guess\npar0 parameter values at x0\nlens lens to select the parameter axis\nlevel maximum branching (or recursion) level for computing the bifurcation diagram\noptions = (x, p, level) -> contparams this function allows to change the continuation options depending on the branching level. The argument x, p denotes the current solution to F(x,p)=0.\nkwargs optional arguments as for continuation but also for the different versions listed in Continuation.\n\nSimplified call:\n\nWe also provide the call\n\nbifurcationdiagram(F, dF, d2F, d3F, br::ContResult, level::Int, options; usedeflation = false, kwargs...)\n\nwhere br is a branch computed after a call to continuation from which we want to compute the bifurcating branches recursively.\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"bifurcationdiagram!","category":"page"},{"location":"library/#BifurcationKit.bifurcationdiagram!","page":"Library","title":"BifurcationKit.bifurcationdiagram!","text":"bifurcationdiagram!(F, dF, d2F, d3F, node, level, options; code, usedeflation, kwargs...)\n\n\nSame as bifurcationdiagram but you pass a previously computed bifurcation diagram node from which you want to further compute the bifurcated branches. It is usually used with node = getBranch(diagram, code) from a previously computed bifurcation diagram.\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"getBranch","category":"page"},{"location":"library/#BifurcationKit.getBranch","page":"Library","title":"BifurcationKit.getBranch","text":"getBranch(tree, code)\n\n\nReturn the part of the tree (bifurcation diagram) by recursively descending the tree using the Int valued tuple code. For example getBranch(tree, (1,2,3,)) returns tree.child[1].child[2].child[3].\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"getBranchesFromBP","category":"page"},{"location":"library/#BifurcationKit.getBranchesFromBP","page":"Library","title":"BifurcationKit.getBranchesFromBP","text":"getBranchesFromBP(tree, indbif)\n\n\nReturn the part of the tree corresponding to the indbith-th bifurcation point on the root branch.\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"GenericBifPoint","category":"page"},{"location":"library/#BifurcationKit.GenericBifPoint","page":"Library","title":"BifurcationKit.GenericBifPoint","text":"struct GenericBifPoint{T, Tp, Tv} <: BifurcationKit.BifurcationPoint\n\nStructure to record a generic bifurcation point which was only detected by a change in the number of stable eigenvalues.\n\ntype::Symbol\nBifurcation type, :hopf, :bp..., Default: :none\nidx::Int64\nIndex in br.eig (see ContResult) for which the bifurcation occurs. Default: 0\nparam::Any\nParameter value at the bifurcation point, this is an estimate. Default: T(0)\nnorm::Any\nNorm of the equilibrium at the bifurcation point Default: T(0)\nprintsol::Any\nprintsol = printSolution(x, param) where printSolution is one of the arguments to continuation Default: T(0)\nx::Any\nEquilibrium at the bifurcation point Default: Vector{T}(undef, 0)\ntau::BorderedArray{Tv,T} where Tv where T\nTangent along the branch at the bifurcation point Default: BorderedArray(x0, T(0))\nind_ev::Int64\nEigenvalue index responsible for the bifurcation (if applicable) Default: 0\nstep::Int64\nContinuation step at which the bifurcation occurs Default: 0\nstatus::Symbol\nstatus ∈ {:converged, :guess} indicates whether the bisection algorithm was successful in detecting the bifurcation point Default: :guess\nδ::Tuple{Int64,Int64}\nδ = (δr, δi) where δr indicates the change in the number of unstable eigenvalues and δi indicates the change in the number of unstable eigenvalues with nonzero imaginary part. abs(δr) is thus an estimate of the dimension of the kernel of the Jacobian at the bifurcation point. Default: (0, 0)\nprecision::Any\nPrecision in the location of the bifurcation point Default: T(-1)\ninterval::Tuple{T,T} where T\nInterval containing the bifurcation point Default: (T(0), T(0))\n\n\n\n\n\n","category":"type"},{"location":"library/#Utils-for-periodic-orbits-1","page":"Library","title":"Utils for periodic orbits","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"getPeriod","category":"page"},{"location":"library/#BifurcationKit.getPeriod","page":"Library","title":"BifurcationKit.getPeriod","text":"getPeriod(sh, x)\ngetPeriod(sh, x, par)\n\n\nCompute the period of the periodic orbit associated to x.\n\n\n\n\n\ngetPeriod(psh, x_bar, par)\n\n\nCompute the period of the periodic orbit associated to x_bar.\n\n\n\n\n\ngetPeriod(prob, x, p)\n\n\nCompute the period of the periodic orbit associated to x.\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"getAmplitude","category":"page"},{"location":"library/#BifurcationKit.getAmplitude","page":"Library","title":"BifurcationKit.getAmplitude","text":"getAmplitude(prob, x, p; ratio)\n\n\nCompute the amplitude of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\ngetAmplitude(prob, x, p; ratio)\n\n\nCompute the amplitude of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = 1 + ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"getMaximum","category":"page"},{"location":"library/#BifurcationKit.getMaximum","page":"Library","title":"BifurcationKit.getMaximum","text":"getMaximum(prob, x, p; ratio)\n\n\nCompute the maximum of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\ngetMaximum(prob, x, p; ratio)\n\n\nCompute the maximum of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = 1 + ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"SectionSS","category":"page"},{"location":"library/#BifurcationKit.SectionSS","page":"Library","title":"BifurcationKit.SectionSS","text":"struct SectionSS{Tn, Tc} <: BifurcationKit.AbstractSection\n\nThis composite type (named for Section Standard Shooting) encodes a type of section implemented by a hyperplane. It can be used in conjunction with ShootingProblem. The hyperplane is defined by a point in centers and a normal.\n\nnormal::Any\nNormal to define hyperplane\ncenter::Any\nRepresentative point on hyperplane\n\n\n\n\n\n","category":"type"},{"location":"library/#","page":"Library","title":"Library","text":"SectionPS","category":"page"},{"location":"library/#BifurcationKit.SectionPS","page":"Library","title":"BifurcationKit.SectionPS","text":"struct SectionPS{Tn, Tc, Tnb, Tcb} <: BifurcationKit.AbstractSection\n\nThis composite type (named for SectionPoincaréShooting) encodes a type of Poincaré sections implemented by hyperplanes. It can be used in conjunction with PoincareShootingProblem. Each hyperplane is defined par a point (one example in centers) and a normal (one example in normals).\n\nM::Int64\nnormals::Any\ncenters::Any\nindices::Array{Int64,1}\nnormals_bar::Any\ncenters_bar::Any\n\nConstructor(s)\n\nSectionPS(normals::Vector{Tv}, centers::Vector{Tv})\n\n\n\n\n\n","category":"type"},{"location":"nonsimplebp/#Non-simple-branch-point-1","page":"Non-simple branch point","title":"Non-simple branch point","text":"","category":"section"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"unknown: References\nThe general method is exposed in Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295","category":"page"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"tip: Example\nAn example of use of the methods presented here is provided in A generalized Bratu–Gelfand problem in two dimensions.    ","category":"page"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"We expose our method to study non-simple branch points. Such branch point (x_0p_0) for the problem F(xp)=0 satisfies d=dim ker dF(x_0p_0)  1 and the eigenvalues have zero imaginary part. At such point, we can apply Lyapunov-Schmidt reduction to transform the initial problem in large dimensions to a d-dimensional polynomial equation, called the reduced equation.","category":"page"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"More precisely, it is possible to write x = u + v where uin ker dF(x_0p_0) and vapprox 0 belongs to a vector space complement of ker dF(x_0p_0). It can be shown that u solves Phi(udelta p)=0 with Phi(udelta p) = (I-Pi)F(u+psi(udelta p)p_0+delta p) where psi is known implicitly and Pi is the spectral projector on ker dF(x_0p_0). Fortunately, one can compute the Taylor expansion of Phi up to order 3. Computing the bifurcation diagram of this d-dimensional multivariate polynomials can be done using brute force methods.","category":"page"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"Once the zeros of Phi have been located, we can use them as initial guess for continuation but for the original F !!","category":"page"},{"location":"nonsimplebp/#Reduced-equation-computation-1","page":"Non-simple branch point","title":"Reduced equation computation","text":"","category":"section"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"The reduced equation (E) can be automatically computed as follows","category":"page"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"computeNormalForm(F, dF, d2F, d3F, br::ContResult, ind_bif::Int ; δ = 1e-8,\n\tnev = 5, Jt = nothing, verbose = false, ζs = nothing, lens = br.param_lens)","category":"page"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"where dF, d2F,d3F are the differentials of F. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to computeNormalForm. It returns a point with all requested information:","category":"page"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"mutable struct NdBranchPoint{Tv, T, Tevl, Tevr, Tnf} <: BranchPoint\n\t\"bifurcation point\"\n\tx0::Tv\n\n\t\"Parameter value at the bifurcation point\"\n\tp::T\n\n\t\"Right eigenvectors\"\n\tζ::Tevr\n\n\t\"Left eigenvectors\"\n\tζstar::Tevl\n\n\t\"Normal form coefficients\"\n\tnf::Tnf\n\n\t\"Type of bifurcation point\"\n\ttype::Symbol\nend","category":"page"},{"location":"nonsimplebp/#Using-the-Reduced-equation-1","page":"Non-simple branch point","title":"Using the Reduced equation","text":"","category":"section"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"Once a branch point has been computed bp = computeNormalForm(...), you can do all sort of things. ","category":"page"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"For example, quoted from the file test/testNF.jl, you can print the 2d reduced equation as follows:","category":"page"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"julia> PALC.nf(bp2d)\n2-element Array{String,1}:\n \" + (3.23 + 0.0im) * x1 * p + (-0.123 + 0.0im) * x1^3 + (-0.234 + 0.0im) * x1 * x2^2\"\n \" + (-0.456 + 0.0im) * x1^2 * x2 + (3.23 + 0.0im) * x2 * p + (-0.123 + 0.0im) * x2^3\"","category":"page"},{"location":"nonsimplebp/#","page":"Non-simple branch point","title":"Non-simple branch point","text":"You can evaluate the reduced equation as bp2d(Val(:reducedForm), rand(2), 0.2). This can be used to find all the zeros of the reduced equation by sampling on a grid. \nFinally, given a d-dimensional vector x and a parameter delta p, you can can have access to an initial guess u (see above) by calling bp2d(rand(2), 0.1)","category":"page"},{"location":"tutorials1b/#Temperature-model-with-ApproxFun-(intermediate)-1","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"","category":"section"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"Pages = [\"tutorials1b.md\"]\nDepth = 3","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We reconsider the first example by relying on spectral collocations using the package ApproxFun.jl which allows very precise function approximation. ","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"This is one example where the state space, the space of solutions to the nonlinear equation, is not a subtype of AbstractArray. See Requested methods for Custom State for more informations.","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We start with some imports:","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"using ApproxFun, LinearAlgebra, Parameters\n\nusing BifurcationKit, Plots\nconst BK = BifurcationKit","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We then need to add some methods not available in ApproxFun because the state space is not a subtype of AbstractArray:","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"# specific methods for ApproxFun\nimport Base: eltype, similar, copyto!, length\nimport LinearAlgebra: mul!, rmul!, axpy!, axpby!, dot, norm\n\nsimilar(x::ApproxFun.Fun, T) = (copy(x))\nsimilar(x::ApproxFun.Fun) = copy(x)\nmul!(w::ApproxFun.Fun, v::ApproxFun.Fun, α) = (w .= α * v)\n\neltype(x::ApproxFun.Fun) = eltype(x.coefficients)\nlength(x::ApproxFun.Fun) = length(x.coefficients)\n\ndot(x::ApproxFun.Fun, y::ApproxFun.Fun) = sum(x * y)\n\naxpy!(a, x::ApproxFun.Fun, y::ApproxFun.Fun) = (y .= a * x + y)\naxpby!(a::Float64, x::ApproxFun.Fun, b::Float64, y::ApproxFun.Fun) = (y .= a * x + b * y)\nrmul!(y::ApproxFun.Fun, b::Float64) = (y.coefficients .*= b; y)\nrmul!(y::ApproxFun.Fun, b::Bool) = b == true ? y : (y.coefficients .*= 0; y)\n\ncopyto!(x::ApproxFun.Fun, y::ApproxFun.Fun) = ( (x.coefficients = copy(y.coefficients);x))","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We can easily write our functional with boundary conditions in a convenient manner using ApproxFun:","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"N(x; a = 0.5, b = 0.01) = 1 + (x + a*x^2)/(1 + b*x^2)\ndN(x; a = 0.5, b = 0.01) = (1-b*x^2+2*a*x)/(1+b*x^2)^2\n\nfunction F_chan(u, p)\n\t@unpack alpha, beta = p\n\treturn [Fun(u(0.), domain(u)) - beta,\n\t\tFun(u(1.), domain(u)) - beta,\n\t\tΔ * u + alpha * N(u, b = beta)]\nend\n\nfunction Jac_chan(u, p)\n\t@unpack alpha, beta = p\n\treturn [Evaluation(u.space, 0.),\n\t\tEvaluation(u.space, 1.),\n\t\tΔ + alpha * dN(u, b = beta)]\nend","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We want to call a Newton solver. We first need an initial guess and the Laplacian operator:","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"sol = Fun(x -> x * (1-x), Interval(0.0, 1.0))\nconst Δ = Derivative(sol.space, 2)\n# set of parameters\npar_af = (alpha = 3., beta = 0.01)","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"Finally, we need to provide some parameters for the Newton iterations. This is done by calling","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"optnewton = NewtonPar(tol = 1e-12, verbose = true)","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We call the Newton solver:","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"out, = @time BK.newton(F_chan, Jac_chan, sol, par_af, optnewton, normN = x -> norm(x, Inf64))","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"and you should see","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     1.5707e+00         0\n        1                2     1.1546e-01         1\n        2                3     8.0149e-04         1\n        3                4     3.9038e-08         1\n        4                5     7.9049e-13         1\n  0.103869 seconds (362.15 k allocations: 14.606 MiB)","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We can also perform numerical continuation with respect to the parameter alpha. Again, we need to provide some parameters for the continuation:","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"optcont = ContinuationPar(dsmin = 0.0001, dsmax = 0.05, ds= 0.005, pMax = 4.1, plotEveryStep = 10, newtonOptions = NewtonPar(tol = 1e-8, maxIter = 20, verbose = true), maxSteps = 200)","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"We provide a callback function to check how the ApproxFun solution vector grows during the continuation:","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"function finalise_solution(z, tau, step, contResult)\n\tprintstyled(color=:red,\"--> AF length = \", (z, tau) .|> length ,\"\\n\")\n\ttrue\nend","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"Then, we can call the continuation routine","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"br, = @time continuation(F_chan, Jac_chan, out, par_af, (@lens _.alpha), optcont,\n\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> plot!(x; label = \"l = $(length(x))\", kwargs...),\n\tverbosity = 2,\n\tnormC = x -> norm(x, Inf64))","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"and you should see","category":"page"},{"location":"tutorials1b/#","page":"Temperature model with ApproxFun (intermediate)","title":"Temperature model with ApproxFun (intermediate)","text":"(Image: )","category":"page"},{"location":"tutorials2/#Snaking-in-the-2d-Swift-Hohenberg-equation-1","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"","category":"section"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"Pages = [\"tutorials2.md\"]\nDepth = 3","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"We study the following PDE","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"-(I+Delta)^2 u+lcdot u +nu u^2-u^3 = 0","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"with Neumann boundary conditions. This full example is in the file example/SH2d-fronts.jl. This example is also treated in the MATLAB package pde2path. We use a Sparse Matrix to express the operator L_1=(I+Delta)^2","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"using DiffEqOperators, Setfield, Parameters\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays\nconst BK = BifurcationKit\n\n# helper function to plot solution\nheatmapsol(x) = heatmap(reshape(x,Nx,Ny)',color=:viridis)\n\nNx = 151\nNy = 100\nlx = 4*2pi\nly = 2*2pi/sqrt(3)\n\n# we use DiffEqOperators to compute the Laplacian operator\nfunction Laplacian2D(Nx, Ny, lx, ly)\n\thx = 2lx/Nx\n\thy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\tQx = Neumann0BC(hx)\n\tQy = Neumann0BC(hy)\n\t\n\tA = kron(sparse(I, Ny, Ny), sparse(D2x * Qx)[1]) + kron(sparse(D2y * Qy)[1], sparse(I, Nx, Nx))\n\treturn A, D2x\nend","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"We also write the functional and its Jacobian which is a Sparse Matrix","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"function F_sh(u, p)\n\t@unpack l, ν, L1 = p\n\treturn -L1 * u .+ (l .* u .+ ν .* u.^2 .- u.^3)\nend\n\nfunction dF_sh(u, p)\n\t@unpack l, ν, L1 = p\n\treturn -L1 .+ spdiagm(0 => l .+ 2 .* ν .* u .- 3 .* u.^2)\nend","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"We first look for hexagonal patterns. This is done with","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"X = -lx .+ 2lx/(Nx) * collect(0:Nx-1)\nY = -ly .+ 2ly/(Ny) * collect(0:Ny-1)\n\n# initial guess for hexagons\nsol0 = [(cos(x) + cos(x/2) * cos(sqrt(3) * y/2) ) for x in X, y in Y]\n\tsol0 .= sol0 .- minimum(vec(sol0))\n\tsol0 ./= maximum(vec(sol0))\n\tsol0 = sol0 .- 0.25\n\tsol0 .*= 1.7\n\theatmap(sol0',color=:viridis)\n\n# define parameters for the PDE\nΔ, _ = Laplacian2D(Nx, Ny, lx, ly)\nL1 = (I + Δ)^2\npar = (l = -0.1, ν = 1.3, L1 = L1)\n\n# newton corrections of the initial guess\noptnewton = NewtonPar(verbose = true, tol = 1e-8, maxIter = 20)\n\tsol_hexa, = @time newton(F_sh, dF_sh, vec(sol0), par, optnewton)\n\tprintln(\"--> norm(sol) = \",norm(sol_hexa,Inf64))\n\theatmapsol(sol_hexa)","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"which produces the results","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     1.7391e+02         0\n        1                2     5.0465e+03         1\n        2                3     1.4878e+03         1\n        3                4     4.3529e+02         1\n        4                5     1.2560e+02         1\n        5                6     3.5512e+01         1\n        6                7     9.5447e+00         1\n        7                8     2.1763e+00         1\n        8                9     3.3503e-01         1\n        9               10     7.7259e-02         1\n       10               11     7.4767e-03         1\n       11               12     7.9505e-05         1\n       12               13     8.8395e-09         1\n  1.480938 seconds (3.55 k allocations: 659.404 MiB)","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"with sol_hexa being","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"(Image: )","category":"page"},{"location":"tutorials2/#Continuation-and-bifurcation-points-1","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Continuation and bifurcation points","text":"","category":"section"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"We can now continue this solution as follows. We want to detect bifurcations along the branches. We thus need an eigensolver. However, if we use an iterative eigensolver, like eig = EigArpack(), it has trouble computing the eigenvalues. One can see that using ","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"# compute the jacobian\nJ0 = dF_sh(sol_hexa, par)\n\n# compute 10 eigenvalues\neig(J0, 10)","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"The reason is that the jacobian operator is not very well conditioned unlike its inverse. We thus opt for the shift-invert method (see Eigen solvers for more information) with shift 0.1:","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"eig = EigArpack(0.1, :LM)","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"If we want to compute the bifurcation points along the branches, we have to tell the solver by setting detectBifurcation = 2. However, this won't be very precise and each bifurcation point will be located at best at the step size precision. We can use bisection to locate this points more precisely using the option detectBifurcation = 3 (see Detection of bifurcation points for more information).","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"We are now ready to compute the branches:","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"optcont = ContinuationPar(dsmin = 0.0001, dsmax = 0.005, ds= -0.001, pMax = 0.00, pMin = -1.0,\n\tnewtonOptions = setproperties(optnewton; tol = 1e-9, maxIter = 15), maxSteps = 125,\n\tdetectBifurcation = 3, nev = 40, detectFold = false, \n\tdsminBisection =1e-7, saveSolEveryStep = 4)\n\toptcont = @set optcont.newtonOptions.eigsolver = EigArpack(0.1, :LM)\n\n\tbr, u1 = @time BK.continuation(F_sh, dF_sh,\n\t\tsol_hexa, par, (@lens _.l), optcont;\t\tplot = true, verbosity = 3,\n\t\ttangentAlgo = BorderedPred(),\n\t\tplotSolution = (x, p; kwargs...) -> (heatmap!(X, Y, reshape(x, Nx, Ny)'; color=:viridis, label=\"\", kwargs...);ylims!(-1,1,subplot=4);xlims!(-.5,.3,subplot=4)),\n\t\tprintSolution = (x, p) -> norm(x),\n\t\tnormC = x -> norm(x, Inf))","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"Note that we can get some information about the branch as follows. The [converged] indicates if the bisection routine was successful, otherwise it shows [guess]. Finally δ = ( 2,  0) says that the bifurcation point has been detected by 2 new eigenvalues with zero real part among which zero have non zero imaginary part. A Hopf bifurcation point would thus have δ = ( 2,  2) or δ = ( -2,  2).","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"julia> br\nBranch number of points: 98\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    bp at p ≈ -0.21554724 ∈ (-0.21554697, -0.21554724), |δp|=3e-07, [converged], δ = ( 1,  0), step =  35, eigenelements in eig[ 36], ind_ev =   1\n- #  2,    bp at p ≈ -0.21551263 ∈ (-0.21552148, -0.21551263), |δp|=9e-06, [converged], δ = ( 1,  0), step =  36, eigenelements in eig[ 37], ind_ev =   2\n- #  3,    bp at p ≈ -0.21499087 ∈ (-0.21506402, -0.21499087), |δp|=7e-05, [converged], δ = ( 1,  0), step =  38, eigenelements in eig[ 39], ind_ev =   3\n- #  4,    bp at p ≈ -0.21289710 ∈ (-0.21297786, -0.21289710), |δp|=8e-05, [converged], δ = ( 1,  0), step =  41, eigenelements in eig[ 42], ind_ev =   4\n- #  5,    nd at p ≈ -0.20993438 ∈ (-0.21016342, -0.20993438), |δp|=2e-04, [converged], δ = ( 2,  0), step =  43, eigenelements in eig[ 44], ind_ev =   6\n- #  6,    nd at p ≈ -0.20628011 ∈ (-0.20685136, -0.20628011), |δp|=6e-04, [converged], δ = ( 2,  0), step =  45, eigenelements in eig[ 46], ind_ev =   8\n- #  7,    bp at p ≈ -0.19981594 ∈ (-0.19990625, -0.19981594), |δp|=9e-05, [converged], δ = ( 1,  0), step =  48, eigenelements in eig[ 49], ind_ev =   9\n- #  8,    bp at p ≈ -0.18868881 ∈ (-0.18890987, -0.18868881), |δp|=2e-04, [converged], δ = ( 1,  0), step =  52, eigenelements in eig[ 53], ind_ev =  10\n- #  9,    bp at p ≈ -0.18103471 ∈ (-0.18104224, -0.18103471), |δp|=8e-06, [converged], δ = ( 1,  0), step =  55, eigenelements in eig[ 56], ind_ev =  11\n- # 10,    bp at p ≈ -0.14472469 ∈ (-0.14531146, -0.14472469), |δp|=6e-04, [converged], δ = (-1,  0), step =  64, eigenelements in eig[ 65], ind_ev =  11\n- # 11,    bp at p ≈ -0.13818751 ∈ (-0.13878837, -0.13818751), |δp|=6e-04, [converged], δ = (-1,  0), step =  66, eigenelements in eig[ 67], ind_ev =  10\n- # 12,    bp at p ≈ -0.11129701 ∈ (-0.11161442, -0.11129701), |δp|=3e-04, [converged], δ = (-1,  0), step =  72, eigenelements in eig[ 73], ind_ev =   9\n- # 13,    nd at p ≈ -0.08963860 ∈ (-0.08980136, -0.08963860), |δp|=2e-04, [converged], δ = (-2,  0), step =  77, eigenelements in eig[ 78], ind_ev =   8\n- # 14,    bp at p ≈ -0.07000271 ∈ (-0.07132120, -0.07000271), |δp|=1e-03, [converged], δ = (-1,  0), step =  81, eigenelements in eig[ 82], ind_ev =   6\n- # 15,    bp at p ≈ -0.06076609 ∈ (-0.06208899, -0.06076609), |δp|=1e-03, [converged], δ = (-1,  0), step =  83, eigenelements in eig[ 84], ind_ev =   5\n- # 16,    bp at p ≈ -0.05300195 ∈ (-0.05316683, -0.05300195), |δp|=2e-04, [converged], δ = (-1,  0), step =  85, eigenelements in eig[ 86], ind_ev =   4\n- # 17,    bp at p ≈ -0.02461821 ∈ (-0.02527709, -0.02461821), |δp|=7e-04, [converged], δ = (-1,  0), step =  91, eigenelements in eig[ 92], ind_ev =   3\n- # 18,    bp at p ≈ -0.00632774 ∈ (-0.00632901, -0.00632774), |δp|=1e-06, [converged], δ = (-1,  0), step =  95, eigenelements in eig[ 96], ind_ev =   2\n\n","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"We get the following plot during computation:","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"tip: Tip\nWe don't need to call newton first in order to use continuation.","category":"page"},{"location":"tutorials2/#Snaking-computed-with-deflation-1","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking computed with deflation","text":"","category":"section"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"We know that there is snaking near the left fold. Let us look for other solutions like fronts. The problem is that if the guess is not precise enough, the newton iterations will converge to the solution with hexagons sol_hexa. We appeal to the technique initiated by P. Farrell and use a deflated problem (see DeflationOperator and DeflatedProblem for more information). More precisely, we apply the newton iterations to the following functional uto fracF_sh(u)Pi_i=1^n_s u-sol_hexai^p + sigma which penalizes sol_hexa.","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"# this define the above penalizing factor with p=2, sigma=1, norm associated to dot\n# and the set of sol_{hexa} is of length ns=1\ndeflationOp = DeflationOperator(2.0,dot,1.0,[sol_hexa])\noptnewton = @set optnewton.maxIter = 250\noutdef, _, flag, _ = @time newton(F_sh, dF_sh,\n\t\t\t\t0.2vec(sol_hexa) .* vec([exp.(-(x+lx)^2/25) for x in X, y in Y]),\n\t\t\t\tpar, optnewton, deflationOp, normN = x -> norm(x,Inf64))\n\t\theatmapsol(outdef) |> display\n\t\tflag && push!(deflationOp, outdef)","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"which gives:","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"Note that push!(deflationOp, outdef) deflates the newly found solution so that by repeating the process we find another one:","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"outdef, _, flag, _ = @time newton(F_sh, dF_sh,\n\t\t\t\t0.2vec(sol_hexa) .* vec([exp.(-(x)^2/25) for x in X, y in Y]),\n\t\t\t\tpar, optnewton, deflationOp, normN = x -> norm(x,Inf64))\n\t\theatmapsol(outdef) |> display\n\t\tflag && push!(deflationOp, outdef)","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"Again, repeating this from random guesses, we find several more solutions, like for example","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"We can now continue the solutions located in deflationOp.roots","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"br, _ = @time continuation(F_sh, dF_sh,\n\tdeflationOp[2], par, (@lens _.l), optcont;\n\tplot = true, \n\tplotSolution = (x, p; kwargs...) -> (heatmap!(X,Y,reshape(x,Nx,Ny)'; color=:viridis, label=\"\", kwargs...)))","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"and using plot(br), we obtain:","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"(Image: )","category":"page"},{"location":"tutorials2/#","page":"Snaking in the 2d Swift-Hohenberg equation","title":"Snaking in the 2d Swift-Hohenberg equation","text":"Note that the plot provides the stability of solutions and bifurcation points. Interested readers should consult the associated file example/SH2d-fronts.jl in the example folder.","category":"page"},{"location":"DeflatedContinuation/#Deflated-Continuation-1","page":"Deflated Continuation","title":"Deflated Continuation","text":"","category":"section"},{"location":"DeflatedContinuation/#","page":"Deflated Continuation","title":"Deflated Continuation","text":"unknown: References\nFarrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. The Computation of Disconnected Bifurcation Diagrams. ArXiv:1603.00809 [Math], March 2, 2016. http://arxiv.org/abs/1603.00809.","category":"page"},{"location":"DeflatedContinuation/#","page":"Deflated Continuation","title":"Deflated Continuation","text":"Deflated continuation allows to compute branches of solutions to the equation F(xp)=0. It is based on the Deflated Newton (see Deflated problems).","category":"page"},{"location":"DeflatedContinuation/#","page":"Deflated Continuation","title":"Deflated Continuation","text":"However, unlike the regular continuation method, deflated continuation allows to compute disconnected bifurcation diagrams, something that is impossible to our Automatic Bifurcation diagram computation method.","category":"page"},{"location":"DeflatedContinuation/#","page":"Deflated Continuation","title":"Deflated Continuation","text":"You can find an example of use in the Deflated Continuation in the Carrier Problem. We reproduce below the result of the computation:","category":"page"},{"location":"DeflatedContinuation/#","page":"Deflated Continuation","title":"Deflated Continuation","text":"(Image: )","category":"page"},{"location":"DeflatedContinuation/#Algorithm-1","page":"Deflated Continuation","title":"Algorithm","text":"","category":"section"},{"location":"DeflatedContinuation/#","page":"Deflated Continuation","title":"Deflated Continuation","text":"Input: Initial parameter value λmin.\nInput: Final parameter value λmax > λmin. Input: Step size ∆λ > 0.\nInput: Nonlinear residual f(u,λ).\nInput: Deflation operator M(u; u∗).\nInput: Initial solutions S(λmin) to f(·,λmin).\nλ ← λmin\nwhile λ < λmax do\n\tF(·) ← f(·,λ+∆λ) ◃ Fix the value of λ to solve for.\n\tS(λ+∆λ) ← ∅\n\tfor u0 ∈ S(λ) do ◃ Continue known branches.\n\tapply Newton’s method to F from initial guess u0.\n\tif solution u∗ found then\n\t\tS(λ + ∆λ) ← S(λ + ∆λ) ∪ {u∗} ◃ Record success\n\t\tF(·) ← M(·;u∗)F(·)\t\t◃ Deflate solution\n\t\t\n\tfor u0 ∈ S(λ) do \t◃ Seek new branches.\n\t\tsuccess ← true \n\t\twhile success do\n\t\t\tapply Newton’s method to F from initial guess u0.\n\t\t\tif solution u∗ found then\n\t\t\t\tS(λ + ∆λ) ← S(λ + ∆λ) ∪ {u∗} ◃ Record success\n\t\t\t\tF(·) ← M(·;u∗)F(·)\t\t◃ Deflate solution\n\t\telse\n\t\t\tsuccess ← false \n\tλ←λ+∆λ\nreturn S","category":"page"},{"location":"DeflatedContinuation/#Basic-example-1","page":"Deflated Continuation","title":"Basic example","text":"","category":"section"},{"location":"DeflatedContinuation/#","page":"Deflated Continuation","title":"Deflated Continuation","text":"We show a quick and simple example of use. Note in particular that the algoritm is able to find the disconnected branch. The starting points are marked with crosses","category":"page"},{"location":"DeflatedContinuation/#","page":"Deflated Continuation","title":"Deflated Continuation","text":"using BifurcationKit, LinearAlgebra, Setfield, SparseArrays, Plots\nconst BK = BifurcationKit\n\nk = 2\nN = 1\nF = (x, p) -> p .* x .+ x.^(k+1)/(k+1) .+ 0.01\nJac_m = (x, p) -> diagm(0 => p .+ x.^k)\n\nopts = BK.ContinuationPar(dsmax = 0.051, dsmin = 1e-3, ds=0.001, maxSteps = 140, pMin = -3., saveSolEveryStep = 0, newtonOptions = NewtonPar(tol = 1e-8, verbose = false), saveEigenvectors = false)\n\nbrdc, = continuation(F,Jac_m, 0.5, (@lens _),\n\tContinuationPar(opts, ds = -0.001, maxSteps = 800, newtonOptions = NewtonPar(verbose = true, maxIter = 6), plotEveryStep = 40),\n\tDeflationOperator(2.0, dot, .001, [[0.]]); showplot=true, verbosity = 1,\n\tperturbSolution = (x,p,id) -> (x  .+ 0.1 .* rand(length(x))),\n\tcallbackN = (x, f, J, res, iteration, itlinear, options; kwargs...) -> res <1e3)","category":"page"},{"location":"DeflatedContinuation/#","page":"Deflated Continuation","title":"Deflated Continuation","text":"(Image: )","category":"page"},{"location":"Predictors/#Predictors-Correctors-1","page":"Predictors / correctors","title":"Predictors - Correctors","text":"","category":"section"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"As explained in the docs of continuation, the continuation method works with the following pattern (see [Allgower1990]):","category":"page"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"compute tangent\ncall predictor (based on tangent, mostly)\ncall corrector","category":"page"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"[Allgower1990]: Allgower and Georg, Numerical Continuation Methods, 1990","category":"page"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"There are several couples predictor-tangent/corrector which can be used in BifurcationKit.jl as we now explain. The tangent computation is formally included in the predictor whereas it is a distinct function in the code.","category":"page"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"info: Corrector\nNote that setting the tangent predictor (for example) tangentAlgo = SecantPred() also sets the corresponding corrector: it selects the couple predictor-corrector. You don't have (in fact cannot) set them independently.","category":"page"},{"location":"Predictors/#)-Natural,-zeroth-order-predictor-1","page":"Predictors / correctors","title":"1) Natural, zeroth order predictor","text":"","category":"section"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"This is the dumbest predictor based on the formula (x_1p_1) = (x_0 p_0 + ds) with Newton corrector ; it fails at Turning points. This is set by the option tangentAlgo = NaturalPred() in continuation. For matrix based jacobian, it is not faster than the pseudo-arclength predictor because the factorisation of the jacobian is catched. For Matrix-free methods, this predictor can be faster than the following ones until it hits a Turning point.","category":"page"},{"location":"Predictors/#)-First-order-predictor-1","page":"Predictors / correctors","title":"2) First order predictor","text":"","category":"section"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor is based on a computation of the tangent tau = (dxdp) to the curve of solutions, it is given by (x_1p_1) = (x_0p_0) + dscdot tau. This predictor passes Turning points when used with PALC Newton corrector. BifurcationKit.jl provides two ways to compute the tangent (dx_1 dp_1). ","category":"page"},{"location":"Predictors/#Secant-predictor-1","page":"Predictors / correctors","title":"Secant predictor","text":"","category":"section"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor is called secant and is parametrized by the option tangentAlgo = SecantPred().  It is computed by (dx_1 dp_1) = (z_1 p_1) - (z_0 p_0) and normalized by the norm (x p)^2_theta = fracthetalength(x) langle xxrangle + (1 - theta)cdot p^2. ","category":"page"},{"location":"Predictors/#Bordered-predictor-1","page":"Predictors / correctors","title":"Bordered predictor","text":"","category":"section"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor departs from the previous one in the way the tangent is estimated. It computes (dx_1 dp_1) by solving solving the bordered linear system beginbmatrix F_x  F_p\t fracthetalength(x)dx_0  (1-theta)dp_0endbmatrixbeginbmatrixdx_1   dp_1endbmatrix =beginbmatrix0  1endbmatrix.","category":"page"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"it is set by the option tangentAlgo = BorderedPred().","category":"page"},{"location":"Predictors/#)-Polynomial-predictor-1","page":"Predictors / correctors","title":"3) Polynomial predictor","text":"","category":"section"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"The polynomial predictor is based on a fit (least square regression) of an nth-order polynomial P on the last k solution vectors, where n  k. The arclength s is used for the polynomial which then fits the solution (x_ip_is_i) as P(s_i)approx (x_ip_i). To keep s in suitable range (see [Waugh]), we rescale it as sto fracs-bar ssigma where sigma is the standard deviation of the s_i.","category":"page"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor is parametrized by tangentAlgo = PolynomialPred(n, k, v0, algo = SecantPred() ) where algo is the predictor used for the first k solutions before the polynomial predictor is operational and v0 is an example of guess.","category":"page"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"[Waugh]: Waugh, Illingworth, and Juniper, “Matrix-Free Continuation of Limit Cycles for Bifurcation Analysis of Large Thermoacoustic Systems.”","category":"page"},{"location":"Predictors/#)-Multiple-predictor-(aka-pmcont-in-pde2path)-1","page":"Predictors / correctors","title":"4) Multiple predictor (aka pmcont in pde2path)","text":"","category":"section"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"The predictor is designed [Uecker2014] to avoid spurious branch switching and pass singular points especially in PDE where branch point density can be quite high. It is based on the use of many predictors with increasing \"jumps\" (x_ip_i) = (x_0p_0) + icdot dscdot tau ileq nb and use a corrector (PALC Newton) with the following twist. The criterion is that in each Newton step, the residual has to decrease by a factor 0alpha1:","category":"page"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":" F(u_np_n)leq alpha  F(u_n-1p_n-1) ","category":"page"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"otherwise the corrector fails. The solution that is returned is the one for the highest i. We refer to [Uecker2014] for an exposition of the step size adaption strategy.","category":"page"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor is parametrized by tangentAlgo = MultiplePred(α, nb, τ, algo = SecantPred() ) where τ is an initial tangent vector (used to set the types) and algo is a predictor.","category":"page"},{"location":"Predictors/#","page":"Predictors / correctors","title":"Predictors / correctors","text":"[Uecker2014]: 1.Uecker, H. pde2path - A Matlab Package for Continuation and Bifurcation in 2D Elliptic Systems. NMTMA 7, 58–106 (2014).","category":"page"},{"location":"borderedlinearsolver/#Bordered-linear-solvers-1","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"","category":"section"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The bordered linear solvers must be subtypes of AbstractBorderedLinearSolver <: AbstractLinearSolver. ","category":"page"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The methods provided here solve bordered linear equations. More precisely, one is interested in the solution u to Jcdot u = v where","category":"page"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"tag E J=left(beginarrayll\nA  b \nc  d\nendarrayright) text  and  v=left(beginarrayl\nv_1 \nv_2\nendarrayright)","category":"page"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"Such linear solver bdlsolve will be called like sol, success, itnumber = bdlsolve(A, b, c, d, v1, v2) throughout the package.","category":"page"},{"location":"borderedlinearsolver/#Full-matrix-1","page":"Bordered linear solvers","title":"Full matrix","text":"","category":"section"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"This easiest way to solve (E) is by forming the matrix J. In case it is sparse, it should be relatively efficient. You can create such bordered linear solver using bls = MatrixBLS(ls) where ls::AbstractLinearSolver is a linear solver (which defaults to \\) used to solve invert J.","category":"page"},{"location":"borderedlinearsolver/#Bordering-method-1","page":"Bordered linear solvers","title":"Bordering method","text":"","category":"section"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The general solution to (E) when A is non singular is x_1=A^-1v_1 x_2=A^-1b, u_2 = frac1d - (cx_2)(v_2 - (cx_1)) and u_1=x_1-u_2x_2. This is the default method used in the package. It is very efficient for large scale problems because it is entirely Matrix-Free and one can use preconditioners. You can create such bordered linear solver using bls = BorderingBLS(ls) where ls::AbstractLinearSolver is a linear solver which defaults to \\. The intermediate solutions x_1=A^-1v_1 x_2=A^-1b are formed using ls.","category":"page"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"Using such method with ls being a GMRES method is the main way to solve (E) in this package.\nIn the case where ls = DefaultLS(), the factorisation of A is cached so the second linear solve is very fast ","category":"page"},{"location":"borderedlinearsolver/#Full-Matrix-Free-1","page":"Bordered linear solvers","title":"Full Matrix-Free","text":"","category":"section"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"In cases where A is singular but J is not, the bordering method may fail. It can thus be advantageous to form the Matrix-Free version of J and call a generic linear solver to find the solution to (E). You can create such bordered linear solver using bls = MatrixFreeBLS(ls) where ls::AbstractLinearSolver is a (Matrix Free) linear solver which is used to invert J.","category":"page"},{"location":"borderedlinearsolver/#","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"For now, this linear solver only works with AbstractArray","category":"page"},{"location":"tutorials2b/#The-Swift-Hohenberg-equation-(non-local)-on-the-GPU-(Advanced)-1","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"","category":"section"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"Pages = [\"tutorials2b.md\"]\nDepth = 3","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"Here we give an example where the continuation can be done entirely on the GPU, e.g. on a single V100 NIVDIA.","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"We choose the 2d Swift-Hohenberg as an example and consider a larger grid. See Snaking in the 2d Swift-Hohenberg equation for more details. Solving the sparse linear problem in v","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"-(I+Delta)^2 v+(l +2nu u-3u^2)v = rhs","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"with a direct solver becomes prohibitive. Looking for an iterative method, the conditioning of the jacobian is not good enough to have fast convergence, mainly because of the Laplacian operator. However, the above problem is equivalent to:","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"-v + L cdot (d cdot v) = Lcdot rhs","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"where","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"L = ((I+Delta)^2 + I)^-1","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"is very well conditioned and","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"d = l+1+2nu v-3v^2","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"Hence, to solve the previous equation, only a few GMRES iterations are required.","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"In effect, the preconditioned PDE is an example of nonlocal problem.","category":"page"},{"location":"tutorials2b/#Computing-the-inverse-of-the-differential-operator-1","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"Computing the inverse of the differential operator","text":"","category":"section"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"The issue now is to compute L but this is easy using Fourier transforms.","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"Hence, that's why we slightly modify the previous Example by considering periodic boundary conditions. Let us now show how to compute L. Although the code looks quite technical, it is based on two facts. First, the Fourier transform symbol associated to L is","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"l_1 = 1+(1-k_x^2-k_y^2)^2","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"which is pre-computed in the composite type SHLinearOp. Then, the effect of L on u is as simple as real.(ifft( l1 .* fft(u) )) and the inverse L\\u is real.(ifft( fft(u) ./ l1 )). However, in order to save memory on the GPU, we use inplace FFTs to reduce temporaries which explains the following code.","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"using Revise\nusing AbstractFFTs, FFTW, KrylovKit, Setfield, Parameters\nusing BifurcationKit, LinearAlgebra, Plots\nconst BK = BifurcationKit\n\n# the following struct encodes the operator L1\n# Making the linear operator a subtype of BK.AbstractLinearSolver is handy as it will be used\n# in the Newton iterations.\nstruct SHLinearOp{Treal, Tcomp, Tl1, Tplan, Tiplan} <: BK.AbstractLinearSolver\n\ttmp_real::Treal         # temporary\n\ttmp_complex::Tcomp      # temporary\n\tl1::Tl1\n\tfftplan::Tplan\n\tifftplan::Tiplan\nend\n\n# this is a constructor for the above struct\nfunction SHLinearOp(Nx, lx, Ny, ly; AF = Array{TY})\n\t# AF is a type, it could be CuArray{TY} to run the following on GPU\n\tk1 = vcat(collect(0:Nx/2), collect(Nx/2+1:Nx-1) .- Nx)\n\tk2 = vcat(collect(0:Ny/2), collect(Ny/2+1:Ny-1) .- Ny)\n\td2 = [(1-(pi/lx * kx)^2 - (pi/ly * ky)^2)^2 + 1. for kx in k1, ky in k2]\n\ttmpc = Complex.(AF(zeros(Nx, Ny)))\n\treturn SHLinearOp(AF(zeros(Nx, Ny)), tmpc, AF(d2), plan_fft!(tmpc), plan_ifft!(tmpc))\nend\n\nimport Base: *, \\\n\n# action of L\nfunction *(c::SHLinearOp, u)\n\tc.tmp_complex .= Complex.(u)\n\tc.fftplan * c.tmp_complex\n\tc.tmp_complex .= c.l1 .* c.tmp_complex\n\tc.ifftplan * c.tmp_complex\n\tc.tmp_real .= real.(c.tmp_complex)\n\treturn copy(c.tmp_real)\nend\n\n# inverse of L\nfunction \\(c::SHLinearOp, u)\n\tc.tmp_complex .= Complex.(u)\n\tc.fftplan * c.tmp_complex\n\tc.tmp_complex .=  c.tmp_complex ./ c.l1\n\tc.ifftplan * c.tmp_complex\n\tc.tmp_real .= real.(c.tmp_complex)\n\treturn copy(c.tmp_real)\nend","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"Before applying a Newton solver, we need to tell how to solve the linear equation arising in the Newton Algorithm.","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"# inverse of the jacobian of the PDE\nfunction (sh::SHLinearOp)(J, rhs; shift = 0., tol =  1e-9)\n\tu, l, ν = J\n\tudiag = l .+ 1 .+ 2ν .* u .- 3 .* u.^2 .- shift\n\tres, info = KrylovKit.linsolve( du -> -du .+ sh \\ (udiag .* du), sh \\ rhs, tol = tol, maxiter = 6)\n\treturn res, true, info.numops\nend","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"Now that we have our operator L, we can encode our functional:","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"function F_shfft(u, p)\n\t@unpack l, ν, L = p\n\treturn -(L * u) .+ ((l+1) .* u .+ ν .* u.^2 .- u.^3)\nend","category":"page"},{"location":"tutorials2b/#Linear-Algebra-on-the-GPU-1","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"Linear Algebra on the GPU","text":"","category":"section"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"We plan to use KrylovKit on the GPU. We define the following types so it is easier to switch to Float32 for example:","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"using CUDA\n\n# this disable slow operations but errors if you use one of them\nCUDA.allowscalar(false)\n\n# type used for the arrays, can be Float32 is GPU requires it\nTY = Float64\n\n# put the AF = Array{TY} instead to make the code on the CPU\nAF = CuArray{TY}","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"We can now define our operator L and an initial guess sol0.","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"using LinearAlgebra, Plots\n\n# to simplify plotting of the solution\nplotsol(x; k...) = heatmap(reshape(Array(x), Nx, Ny)'; color=:viridis, k...)\nplotsol!(x; k...) = heatmap!(reshape(Array(x), Nx, Ny)'; color=:viridis, k...)\nnorminf(x) = maximum(abs.(x))\n\n# norm compatible with CUDA\nnorminf(x) = maximum(abs.(x))\n\nNx = 2^10\nNy = 2^10\nlx = 8pi * 2\nly = 2*2pi/sqrt(3) * 2\n\nX = -lx .+ 2lx/(Nx) * collect(0:Nx-1)\nY = -ly .+ 2ly/(Ny) * collect(0:Ny-1)\n\nsol0 = [(cos(x) .+ cos(x/2) * cos(sqrt(3) * y/2) ) for x in X, y in Y]\n\t\tsol0 .= sol0 .- minimum(vec(sol0))\n\t\tsol0 ./= maximum(vec(sol0))\n\t\tsol0 = sol0 .- 0.25\n\t\tsol0 .*= 1.7\n\nL = SHLinearOp(Nx, lx, Ny, ly, AF = AF)\nJ_shfft(u, p) = (u, p.l, p.ν)\n# parameters of the PDE\npar = (l = -0.15, ν = 1.3, L = L)","category":"page"},{"location":"tutorials2b/#Newton-iterations-and-deflation-1","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"Newton iterations and deflation","text":"","category":"section"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"We are now ready to perform Newton iterations:","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"opt_new = NewtonPar(verbose = true, tol = 1e-6, maxIter = 100, linsolver = L)\n\tsol_hexa, hist, flag = @time newton(\n\t\tF_shfft, J_shfft,\n\t\tAF(sol0), par,\n\t\topt_new, normN = norminf)\n\t\t\t\t\n\tprintln(\"--> norm(sol) = \", maximum(abs.(sol_hexa)))\n\tplotsol(sol_hexa)","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"You should see this:","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"Newton Iterations\n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     2.7383e-01         0\n        1                2     1.2891e+02        13\n        2                3     3.8139e+01        33\n        3                4     1.0740e+01        23\n        4                5     2.8787e+00        17\n        5                6     7.7522e-01        14\n        6                7     1.9542e-01        12\n        7                8     3.0292e-02        11\n        8                9     1.1594e-03        10\n        9               10     1.8788e-06        10\n       10               11     5.9168e-08         8\n  0.365674 seconds (65.03 k allocations: 1.498 MiB)\n--> norm(sol) = 1.26017611779702","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"Note that this is about the 10x faster than Example 2 but for a problem almost 100x larger! (On a V100 GPU)","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"The solution is:","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"(Image: )","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"We can also use the deflation technique (see DeflationOperator and DeflatedProblem for more information) on the GPU as follows","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"deflationOp = DeflationOperator(2.0, dot, 1.0, [sol_hexa])\n\nopt_new = @set opt_new.maxIter = 250\noutdef, _, flag, _ = @time newton(\n\t\tF_shfft, J_shfft,\n\t\t0.4 .* sol_hexa .* AF([exp(-1(x+0lx)^2/25) for x in X, y in Y]),\n\t\tpar, opt_new, deflationOp, normN = x-> maximum(abs.(x)))\n\tprintln(\"--> norm(sol) = \", norm(outdef))\n\tplotsol(outdef) |> display\n\tflag && push!(deflationOp, outdef)","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"and get:","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"(Image: )","category":"page"},{"location":"tutorials2b/#Computation-of-the-branches-1","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"Computation of the branches","text":"","category":"section"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"Finally, we can perform continuation of the branches on the GPU:","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"opts_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.007, ds= -0.005, \n\tpMax = 0.2, pMin = -1.0, theta = 0.5, plotEveryStep = 5, \n\tnewtonOptions = setproperties(opt_new; tol = 1e-6, maxIter = 15), maxSteps = 100)\n\n\tbr, = @time continuation(F_shfft, J_shfft,\n\t\tdeflationOp[1], par, (@lens _.l), opts_cont;\n\t\tplot = true,\n\t\tplotSolution = (x, p; kwargs...)->plotsol!(x; color=:viridis, kwargs...), normC = x->maximum(abs.(x)))","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"We did not detail how to compute the eigenvalues on the GPU and detect the bifurcations. It is based on a simple Shift-Invert strategy, please look at examples/SH2d-fronts-cuda.jl.","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"(Image: )","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"We have the following information about the branch of hexagons","category":"page"},{"location":"tutorials2b/#","page":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","title":"The Swift-Hohenberg equation (non-local) on the GPU (Advanced)","text":"julia> br\nBranch number of points: 67\nBranch of Equilibrium\nBifurcation points:\n (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)\n- #  1,    nd at p ≈ -0.21522461 ∈ (-0.21528614, -0.21522461), |δp|=6e-05, [converged], δ = ( 3,  0), step =  24, eigenelements in eig[ 25], ind_ev =   3\n- #  2,    nd at p ≈ -0.21469007 ∈ (-0.21479652, -0.21469007), |δp|=1e-04, [converged], δ = ( 2,  0), step =  25, eigenelements in eig[ 26], ind_ev =   5\n- #  3,    nd at p ≈ -0.21216919 ∈ (-0.21264341, -0.21216919), |δp|=5e-04, [converged], δ = ( 2,  0), step =  27, eigenelements in eig[ 28], ind_ev =   7\n- #  4,    nd at p ≈ -0.21052576 ∈ (-0.21110899, -0.21052576), |δp|=6e-04, [converged], δ = ( 2,  0), step =  28, eigenelements in eig[ 29], ind_ev =   9\n- #  5,    nd at p ≈ -0.20630678 ∈ (-0.21052576, -0.20630678), |δp|=4e-03, [converged], δ = ( 8,  0), step =  29, eigenelements in eig[ 30], ind_ev =  17\n- #  6,    nd at p ≈ -0.19896508 ∈ (-0.19897308, -0.19896508), |δp|=8e-06, [converged], δ = ( 6,  0), step =  30, eigenelements in eig[ 31], ind_ev =  23\n- #  7,    nd at p ≈ -0.18621673 ∈ (-0.18748234, -0.18621673), |δp|=1e-03, [converged], δ = ( 2,  0), step =  33, eigenelements in eig[ 34], ind_ev =  25\n- #  8,    nd at p ≈ -0.17258147 ∈ (-0.18096574, -0.17258147), |δp|=8e-03, [converged], δ = ( 4,  0), step =  35, eigenelements in eig[ 36], ind_ev =  29\n- #  9,    nd at p ≈ -0.14951737 ∈ (-0.15113148, -0.14951737), |δp|=2e-03, [converged], δ = (-4,  0), step =  39, eigenelements in eig[ 40], ind_ev =  29\n- # 10,    nd at p ≈ -0.14047758 ∈ (-0.14130979, -0.14047758), |δp|=8e-04, [converged], δ = (-2,  0), step =  41, eigenelements in eig[ 42], ind_ev =  25\n- # 11,    nd at p ≈ -0.11304882 ∈ (-0.11315916, -0.11304882), |δp|=1e-04, [converged], δ = (-4,  0), step =  45, eigenelements in eig[ 46], ind_ev =  23\n- # 12,    nd at p ≈ -0.09074623 ∈ (-0.09085968, -0.09074623), |δp|=1e-04, [converged], δ = (-6,  0), step =  49, eigenelements in eig[ 50], ind_ev =  19\n- # 13,    nd at p ≈ -0.07062574 ∈ (-0.07246519, -0.07062574), |δp|=2e-03, [converged], δ = (-4,  0), step =  52, eigenelements in eig[ 53], ind_ev =  13\n- # 14,    nd at p ≈ -0.06235903 ∈ (-0.06238787, -0.06235903), |δp|=3e-05, [converged], δ = (-2,  0), step =  54, eigenelements in eig[ 55], ind_ev =   9\n- # 15,    nd at p ≈ -0.05358077 ∈ (-0.05404312, -0.05358077), |δp|=5e-04, [converged], δ = (-2,  0), step =  56, eigenelements in eig[ 57], ind_ev =   7\n- # 16,    nd at p ≈ -0.02494422 ∈ (-0.02586444, -0.02494422), |δp|=9e-04, [converged], δ = (-2,  0), step =  60, eigenelements in eig[ 61], ind_ev =   5\n- # 17,    nd at p ≈ -0.00484022 ∈ (-0.00665356, -0.00484022), |δp|=2e-03, [converged], δ = (-2,  0), step =  63, eigenelements in eig[ 64], ind_ev =   3\n- # 18,    nd at p ≈ +0.00057801 ∈ (-0.00122418, +0.00057801), |δp|=2e-03, [converged], δ = ( 5,  0), step =  64, eigenelements in eig[ 65], ind_ev =   6\n- # 19,    nd at p ≈ +0.00320921 ∈ (+0.00141327, +0.00320921), |δp|=2e-03, [converged], δ = (10,  0), step =  65, eigenelements in eig[ 66], ind_ev =  16\nFold points:\n- #  1, fold at p ≈ -0.21528694 ∈ (-0.21528694, -0.21528694), |δp|=-1e+00, [    guess], δ = ( 0,  0), step =  24, eigenelements in eig[ 24], ind_ev =   0","category":"page"},{"location":"faq/#FAQ-1","page":"Frequently Asked Questions","title":"FAQ","text":"","category":"section"},{"location":"faq/#How-can-I-save-a-solution-every-n-steps,-or-at-specific-parameter-values?-1","page":"Frequently Asked Questions","title":"How can I save a solution every n steps, or at specific parameter values?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can use the callback finaliseSolution in the function call continuation. For example, you can use something like this to save all steps","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"function mySave(u, tau, step, contResult, personaldata)\n\tpush!(personaldata, u)\nend","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"and pass it like continuation(F, J, u, p0, finaliseSolution = (z, tau, step, contResult) -> mySave(z, tau, step, contResult, myData))","category":"page"},{"location":"faq/#The-Fold-/-Hopf-Continuation-does-not-work,-why?-1","page":"Frequently Asked Questions","title":"The Fold / Hopf Continuation does not work, why?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This requires some precise computations. Have you tried passing the expression of the Jacobian instead of relying on finite differences.","category":"page"},{"location":"faq/#What-is-the-parameter-theta-about-in-ContinuationPar?-1","page":"Frequently Asked Questions","title":"What is the parameter theta about in ContinuationPar?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"See the description of continuation on the page Library.","category":"page"},{"location":"faq/#How-can-I-change-the-preconditioner-during-computations?-1","page":"Frequently Asked Questions","title":"How can I change the preconditioner during computations?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The easiest way to achieve this is by using the callbacks provided by newton and continuation. See the documentation about these two methods. See also the example Complex Ginzburg-Landau 2d","category":"page"},{"location":"faq/#How-can-I-implement-my-own-bifurcation-detection-method?-1","page":"Frequently Asked Questions","title":"How can I implement my own bifurcation detection method?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can use the callback finaliseSolution but the best way is probably to use the Iterator Interface to inject your code anywhere in the continuation procedure. ","category":"page"},{"location":"faq/#How-do-I-dissociate-the-computation-of-eigenvalues-from-the-jacobian-that-I-passed?-1","page":"Frequently Asked Questions","title":"How do I dissociate the computation of eigenvalues from the jacobian that I passed?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Sometimes, for example when implementing boundary conditions, you pass a jacobian J but the eigenvalues, and the bifurcation points are not simply related to J. One way to bypass this issue is to define a new eigensolver <: AbstractEigenSolver and pass it to the NewtonPar field eigsolver. This is done for example in example/SH2d-fronts-cuda.jl.","category":"page"},{"location":"faq/#How-can-I-print-the-eigenvalues-during-continuation?-1","page":"Frequently Asked Questions","title":"How can I print the eigenvalues during continuation?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can print the eigenvalues using the following callback:","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"finaliseSolution = (z, tau, step, contResult) -> \n\t\t(Base.display(contResult.eig[end].eigenvals) ;true)","category":"page"},{"location":"faq/#How-can-I-reject-a-Newton-Step?-1","page":"Frequently Asked Questions","title":"How can I reject a Newton Step?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"You can reject a newton step by passing to continuation the argument callbackN ","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"function mycallback(x, f, J, res, iteration, itlinear, options; kwargs...)\n\t# stop Newton algo if residual too large\n\tif res > 1e2\n\t\t@warn \"Reject Newton step!!\"\n\t\treturn false\n\tend\n\treturn true\nend","category":"page"},{"location":"faq/#How-do-I-stop-continuation?-1","page":"Frequently Asked Questions","title":"How do I stop continuation?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Using the argument finaliseSolution in continuation. Simply make this function finaliseSolution return false.","category":"page"},{"location":"constrainedproblem/#Constrained-problems-1","page":"Constrained problem","title":"Constrained problems","text":"","category":"section"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"compat: Experimental\nThis feature is still experimental. It has not been tested thoroughly, especially the case of multiple constraints and matrix-free functionals.","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"This section is dedicated to the study of an equation (in x) F(x,p)=0 where one wishes to add a constraint g(x,p)=0. Hence, one is interested in solving in the couple (xp):","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"left\nbeginarrayl\nF(xp)=0 \ng(xp)=0\nendarrayright","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"There are several situations where this proves useful:","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"the pseudo-arclength continuation method is such a constrained problem, see continuation for more details.\nwhen the equation F(x) has a continuous symmetry described by a Lie group G and action gcdot x for gin G. One can reduce the symmetry of the problem by considering the constrained problem:","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"left\nbeginarrayl\nF(x) + pcdot Tcdot x=0 \nlangle Tcdot x_refx-x_refrangle=0\nendarrayright","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"where T is a generator of the Lie algebra associated to G and x_ref is a reference solution. This is known as the freezing method.","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"unknown: Reference\nSee Beyn and Thümmler, Phase Conditions, Symmetries and PDE Continuation. for more information on the freezing method.","category":"page"},{"location":"constrainedproblem/#Encoding-of-the-functional-1","page":"Constrained problem","title":"Encoding of the functional","text":"","category":"section"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"A composite type which implements this functional:","category":"page"},{"location":"constrainedproblem/#","page":"Constrained problem","title":"Constrained problem","text":"BorderedProblem","category":"page"},{"location":"constrainedproblem/#BifurcationKit.BorderedProblem","page":"Constrained problem","title":"BifurcationKit.BorderedProblem","text":"pb = BorderedProblem(;F, dxF, dpF, g, ∇g, dpg)\n\nThis composite type encodes a bordered problem, one by which we add a scalar constraint g(x, p) = 0 to an equation F(x, p) = 0. This composite type thus allows to define the functional G((x, p)) = [F(x, p) g(x, p)] and solve G = 0.\n\nYou can then evaluate the functional using or pb(z) where z = BorderedArray(x, p) or z = vcat(x, p), i.e. the last component of the vector is the Lagrange Multiplier.\n\nArguments\n\nThe arguments correspond to the functions F, g and their derivatives.\n\nSimplified constructor\n\nYou can create such functional as pb = BorderedProblem(F, g).\n\nwarning: Multidimensional constraint (Really Experimental)\nIt is in fact possible, using this composite type, to define a bordered problem with constraint of dimension npar > 1. One has to pass the dimension to pb = BorderedProblem(F, g, npar) and possibly the derivatives as well. The second argument of F,g is npar dimensional (for now an AbstractVector). Finally, the only possible linear (bordered) solver in this case is ::MatrixBLS.\n\n\n\n\n\n","category":"type"},{"location":"branchswitching/#Branch-switching-1","page":"Branch switching","title":"Branch switching","text":"","category":"section"},{"location":"branchswitching/#Branch-switching-from-simple-branch-point-to-equilibria-1","page":"Branch switching","title":"Branch switching from simple branch point to equilibria","text":"","category":"section"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"You can perform automatic branch switching by calling continuation with the following options:","category":"page"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"continuation(F, dF, d2F, d3F, br::ContResult, ind_bif::Int, optionsCont::ContinuationPar;\n\tJt = nothing, δ = 1e-8, nev = 5, verbose = false, kwargs...)","category":"page"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"where br is a branch computed after a call to continuation with detection of bifurcation points enabled. This call computes the branch bifurcating from the ind_bifth bifurcation point in br. An example of use is provided in A generalized Bratu–Gelfand problem in two dimensions.","category":"page"},{"location":"branchswitching/#Branch-switching-from-non-simple-branch-point-to-equilibria-1","page":"Branch switching","title":"Branch switching from non simple branch point to equilibria","text":"","category":"section"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"We provide an experimental automatic branch switching method in this case. The method is to first compute the reduced equation (see Non-simple branch point) and use it to compute the nearby solutions. These solutions are seeded as initial guess for continuation. Hence, you can perform automatic branch switching by calling continuation with the following options:","category":"page"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"continuation(F, dF, d2F, d3F, br::ContResult, ind_bif::Int, optionsCont::ContinuationPar;\n\tJt = nothing, δ = 1e-8, nev = 5, verbose = false, kwargs...)","category":"page"},{"location":"branchswitching/#Branch-switching-from-Hopf-point-to-periodic-orbits-1","page":"Branch switching","title":"Branch switching from Hopf point to periodic orbits","text":"","category":"section"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"In order to compute the bifurcated branch of periodic solutions at a Hopf bifurcation point, you need to choose a method. Indeed, we provide two methods to compute periodic orbits:","category":"page"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"Periodic orbits based on finite differences\nPeriodic orbits based on the shooting method","category":"page"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"Once you have decided which method you want, you can call the following method.","category":"page"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"continuation(F, dF, d2F, d3F, br::ContResult, ind_bif::Int, _contParams::ContinuationPar, prob::AbstractPeriodicOrbitProblem ;\n\tJt = nothing, δ = 1e-8, δp = nothing, ampfactor = 1, kwargs...)","category":"page"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"We refer to continuation for more information about the arguments. Here, we just say a few words about how we can specify prob::AbstractPeriodicOrbitProblem. For Periodic orbits based on finite differences, you can pass prob = PeriodicOrbitTrapProblem(M = 51) where M is the number of times slices in the periodic orbit. For Periodic orbits based on the shooting method, you need more parameters. For example, you can pass prob = ShootingProblem(2, par, prob, Euler()) or prob = PoincareShootingProblem(2, par, prob, Euler()) where prob::ODEProblem is an ODE problem to specify the Cauchy problem and par is the set of parameters passed to the vector field and which must be the same as br.params.","category":"page"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"Several examples are provided like Brusselator 1d (automatic) or Complex Ginzburg-Landau 2d.","category":"page"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"tip: Precise options\nAlthough very convenient, the automatic branch switching does not allow the very fine tuning of parameters. It must be used as a first attempt before recurring to manual branch switching","category":"page"},{"location":"branchswitching/#Branch-switching-from-Branch-point-of-curve-of-periodic-orbits-1","page":"Branch switching","title":"Branch switching from Branch point of curve of periodic orbits","text":"","category":"section"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"We only provide (for now) this method for the case of PeriodicOrbitTrapProblem. The call is as follows. Please note that a deflation is included in this method to simplify branch switching. ","category":"page"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"An example of use is provided in Brusselator 1d (automatic).","category":"page"},{"location":"branchswitching/#","page":"Branch switching","title":"Branch switching","text":"continuationPOTrapBPFromPO","category":"page"},{"location":"branchswitching/#BifurcationKit.continuationPOTrapBPFromPO","page":"Branch switching","title":"BifurcationKit.continuationPOTrapBPFromPO","text":"continuationPOTrapBPFromPO(br, ind_bif, _contParams; Jt, δ, δp, ampfactor, usedeflation, linearPO, printSolution, linearAlgo, kwargs...)\n\n\nBranch switching at a Branch point of periodic orbits specified by a PeriodicOrbitTrapProblem. This is still experimental. A deflated Newton-Krylov solver is used to improve the branch switching capabilities.\n\nArguments\n\nbr branch of periodic orbits computed with a PeriodicOrbitTrapProblem\nind_bif index of the branch point\n_contParams parameters to be used by a regular continuation\n\nOptional arguments\n\nJt = (x, p) -> transpose(d_xF(x, p)) jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jt should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass Jt = (x, p) -> transpose(dF(x, p))\nδ used internally to compute derivatives w.r.t the parameter p.\nδp = 0.1 used to specify a particular guess for the parameter in the branch which is otherwise determined by contParams.ds. This allows to use a step larger than contParams.dsmax.\nampfactor = 1 factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nlinearPO = :BorderedLU linear solver used for the Newton-Krylov solver when applied to PeriodicOrbitTrapProblem.\nprintSolution = (u,p) -> u[end], print method used in the bifurcation diagram, by default this prints the period of the periodic orbit.\nlinearAlgo = BorderingBLS(), same as for continuation\nkwargs keywords arguments used for a call to the regular continuation\n\n\n\n\n\n","category":"function"},{"location":"simplehopf/#Simple-Hopf-point-1","page":"Simple Hopf point","title":"Simple Hopf point","text":"","category":"section"},{"location":"simplehopf/#","page":"Simple Hopf point","title":"Simple Hopf point","text":"At a Hopf branch point (x_0p_0) for the problem F(xp)=0, we have Sigma dF(x_0p_0) = pm iomega  omega  0. At such point, we can compute the normal form to transform the initial Cauchy problem","category":"page"},{"location":"simplehopf/#","page":"Simple Hopf point","title":"Simple Hopf point","text":"dot x = F(xp)","category":"page"},{"location":"simplehopf/#","page":"Simple Hopf point","title":"Simple Hopf point","text":"in large dimensions to a complex polynomial vector field (delta pequiv p-p_0): ","category":"page"},{"location":"simplehopf/#","page":"Simple Hopf point","title":"Simple Hopf point","text":"dot z = zleft(a cdotdelta p + iomega + bz^2right)quadtext(E)","category":"page"},{"location":"simplehopf/#","page":"Simple Hopf point","title":"Simple Hopf point","text":"whose solutions give access to the solutions of the Cauchy problem in a neighborhood of (xp).","category":"page"},{"location":"simplehopf/#","page":"Simple Hopf point","title":"Simple Hopf point","text":"More precisely, if J equiv dF(x_0p_0), then we have Jzeta = iomegazeta and Jbarzeta = -iomegabarzeta for some complex eigenvector zeta. It can be shown that x(t) approx x_0 + 2Re(z(t)zeta) when p=p_0+delta p.","category":"page"},{"location":"simplehopf/#Normal-form-computation-1","page":"Simple Hopf point","title":"Normal form computation","text":"","category":"section"},{"location":"simplehopf/#","page":"Simple Hopf point","title":"Simple Hopf point","text":"The normal form (E) is automatically computed as follows","category":"page"},{"location":"simplehopf/#","page":"Simple Hopf point","title":"Simple Hopf point","text":"computeNormalForm(F, dF, d2F, d3F, br::ContResult, ind_bif::Int ; δ = 1e-8,\n\tnev = 5, Jt = nothing, verbose = false, ζs = nothing, lens = br.param_lens)","category":"page"},{"location":"simplehopf/#","page":"Simple Hopf point","title":"Simple Hopf point","text":"where dF, d2F,d3F are the differentials of F. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to [computeNormalForm`](@ref). The above call returns a point with information needed to compute the bifurcated branch.","category":"page"},{"location":"simplehopf/#","page":"Simple Hopf point","title":"Simple Hopf point","text":"mutable struct HopfBifPoint{Tv, T, Tω, Tevr, Tevl, Tnf} <: BifurcationPoint\n\t\"Hopf point\"\n\tx0::Tv\n\n\t\"Parameter value at the Hopf point\"\n\tp::T\n\n\t\"Frequency of the Hopf point\"\n\tω::Tω\n\n\t\"Right eigenvector\"\n\tζ::Tevr\n\n\t\"Left eigenvector\"\n\tζstar::Tevl\n\n\t\"Normal form coefficient (a = 0., b = 1 + 1im)\"\n\tnf::Tnf\n\n\t\"Type of Hopf bifurcation\"\n\ttype::Symbol\nend","category":"page"},{"location":"simplehopf/#","page":"Simple Hopf point","title":"Simple Hopf point","text":"info: Note\nYou should not need to call computeNormalForm except if you need the full information about the branch point. ","category":"page"},{"location":"deflatedproblem/#Deflated-problems-1","page":"Deflated problem","title":"Deflated problems","text":"","category":"section"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"unknown: References\nP. E. Farrell, A. Birkisson, and S. W. Funke. Deflation techniques for finding distinct solutions of nonlinear partial differential equations. SIAM J. Sci. Comput., 2015.,","category":"page"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"Assume you want to solve F(x)=0 with a Newton algorithm but you want to avoid the algorithm to return some already known solutions x_i i=1cdots n. ","category":"page"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"The idea proposed in the paper quoted above is to penalize these solutions by looking for the zeros of the function G(x)=F(x)M(x) where","category":"page"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"M(x) = prod_i=1^nleft(x - x_i^-p + alpharight)","category":"page"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"and alpha0. Obviously F and G have the same zeros away from the x_is but the factor M penalizes the residual of the Newton iterations of G, effectively producing zeros of F different from x_i.","category":"page"},{"location":"deflatedproblem/#Encoding-of-the-functional-1","page":"Deflated problem","title":"Encoding of the functional","text":"","category":"section"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"A composite type DeflationOperator implements this functional. Given a deflation operator M = DeflationOperator(p, dot, α, xis), you can build a deflated functional pb = DeflatedProblem(F, J, M) which you can use to access the values of G by doing pb(x). A Matrix-Free / Sparse linear solver is implemented which works on the GPU.","category":"page"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"the dot argument in DeflationOperator lets you specify a dot product from which the norm is derived in the expression of M.","category":"page"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"See examples Snaking computed with deflation and Newton iterations and deflation.","category":"page"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"Note that you can add new solution x0 to M by doing push!(M, x0). Also M[i] returns xi.","category":"page"},{"location":"deflatedproblem/#Computation-with-newton-1","page":"Deflated problem","title":"Computation with newton","text":"","category":"section"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"Most newton functions can be used with a deflated problem, see for example Snaking computed with deflation. The idea is to pass the deflation operator M. For example, we have the following overloaded method, which works on GPUs: ","category":"page"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"newton(F, J, x0, p0, options::NewtonPar, defOp::DeflationOperator, linsolver = DeflatedLinearSolver(); kwargs...)","category":"page"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"If you pass a linear solver other than the default one ::DeflatedLinearSolver, a Matrix-Free is used in place of the dedicated solver DeflatedLinearSolver which is akin to a Bordering method.","category":"page"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"We refer to newton for more information about the arguments.","category":"page"},{"location":"deflatedproblem/#","page":"Deflated problem","title":"Deflated problem","text":"tip: Tip\nYou can use this method for periodic orbits as well by passing the deflation operator M to the newton method","category":"page"},{"location":"Borderedarrays/#Bordered-Arrays-1","page":"Bordered arrays","title":"Bordered Arrays","text":"","category":"section"},{"location":"Borderedarrays/#","page":"Bordered arrays","title":"Bordered arrays","text":"warning: Advanced usage\nYou can skip this in a first read","category":"page"},{"location":"Borderedarrays/#","page":"Bordered arrays","title":"Bordered arrays","text":"Here are some informations on a composite type which is used all over the package to hold a couple (array, array) or (array, scalar) while implementing the methods described in Requested methods for Custom State. ","category":"page"},{"location":"Borderedarrays/#","page":"Bordered arrays","title":"Bordered arrays","text":"BorderedArray","category":"page"},{"location":"Borderedarrays/#BifurcationKit.BorderedArray","page":"Bordered arrays","title":"BifurcationKit.BorderedArray","text":"x = BorderedArray(vec1, vec2)\n\nThis defines an array (although not <: AbstractArray) to hold two arrays or an array and a scalar. This is useful when one wants to add constraints (phase, ...) to a functional for example. It is used throughout the package for the Pseudo Arc Length Continuation, for the continuation of Fold / Hopf points, for periodic orbits... It is also used to define periodic orbits as (orbit, period). As such, it is a convenient alternative to cat, vcat and friends. We chose not make it a subtype of AbstractArray as we wish to apply the current package to general \"arrays\", see Requested methods for Custom State. Finally, it proves useful for the GPU where the operation x[end] can be slow.\n\n\n\n\n\n","category":"type"},{"location":"iterator/#Iterator-Interface-1","page":"Iterator Interface","title":"Iterator Interface","text":"","category":"section"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"The iterator interface gives the possibility of stepping through the numerical steps of the continuation procedure. It thus allows to inject custom monitoring function (saving, plotting, bifurcation detection, ...) at will and during the continuation run. In short, it allows to completely re-write the continuation algorithm as one sees fit and this, in a straightforward manner.","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"The general method continuation is built upon this iterator interface and we refer to the source code for a complete example of use.","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"The iterator provided below does not compute eigenvalues nor perform bifurcations detection. ","category":"page"},{"location":"iterator/#Initialization-1","page":"Iterator Interface","title":"Initialization","text":"","category":"section"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"More information about iterators can be found on the page of julialang.","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"The interface is set by defining an iterator, pretty much in the same way one calls continuation:","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"iter = PALCIterable(F, J, x0, p0, lens::Lens, opts; kwargs...)","category":"page"},{"location":"iterator/#Stepping-1","page":"Iterator Interface","title":"Stepping","text":"","category":"section"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"Once an iterator iter has been defined, one can step through the numerical continuation using a for loop:","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"for state in iter\n\tprintln(\"Continuation step = \", state.step)\nend","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"The state::ContState has the following description. It is a mutable object which holds the current state of the continuation procedure from which one can step to the next state.","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"The for loop stops when done(iter, state) returns false. The condition which is implemented is basically that the number of iterations should be smaller than maxIter, that the parameters should be in (pMin, pMax)...","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"ContState","category":"page"},{"location":"iterator/#BifurcationKit.ContState","page":"Iterator Interface","title":"BifurcationKit.ContState","text":"state = ContState(ds = 1e-4,...)\n\nReturns a variable containing the state of the continuation procedure. The fields are meant to change during the continuation procedure.\n\nArguments\n\nz_pred current solution on the branch\ntau tangent predictor\nz_old previous solution\nisconverged Boolean for newton correction\nitnewton Number of newton iteration (in corrector)\nstep current continuation step\nds step size\ntheta theta parameter for constraint equation in PALC\nstopcontinuation Boolean to stop continuation\n\nUseful functions\n\ncopy(state) returns a copy of state\nsolution(state) returns the current solution (x, p)\ngetx(state) returns the x component of the current solution\ngetp(state) returns the p component of the current solution\n\n\n\n\n\n","category":"type"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"tip: continuation\nYou can also call continuation(iter) to have access to the regular continuation method used throughout the tutorials.","category":"page"},{"location":"iterator/#Basic-example-1","page":"Iterator Interface","title":"Basic example","text":"","category":"section"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"We show a quick and simple example of use. Note that it is not very optimized because of the use of global variables.","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"using BifurcationKit, SparseArrays, LinearAlgebra, Plots, Setfield\nconst BK = BifurcationKit\n\nk = 2\n\n# functional we want to study\nF = (x, p) -> (@. p + x - x^(k+1)/(k+1))\n\n# Jacobian for the fonctional\nJac_m = (x, p) -> diagm(0 => 1  .- x.^k)\n\n\n# parameters for the continuation\nopts = ContinuationPar(dsmax = 0.1, dsmin = 1e-3, ds = -0.001, maxSteps = 130, pMin = -3., pMax = 3., saveSolEveryStep = 0, newtonOptions = NewtonPar(tol = 1e-8, verbose = true))\n\n# we define an iterator to hold the continuation routine\niter = BK.ContIterable(F, Jac_m, [0.8], 1., (@lens _), opts; verbosity = 2)\n\nresp = Float64[]\nresx = Float64[]\n\n# this is the PALC algorithm\nfor state in iter\n\t# we save the current solution on the branch\n\tpush!(resx, getx(state)[1])\n\tpush!(resp, getp(state))\nend\n\n# plot the result\nplot(resp, resx; label = \"\", xlabel = \"p\")","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"and you should see:","category":"page"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"(Image: )","category":"page"},{"location":"iterator/#Additional-information-1","page":"Iterator Interface","title":"Additional information","text":"","category":"section"},{"location":"iterator/#","page":"Iterator Interface","title":"Iterator Interface","text":"If you want to customize the iterator to your needs, perhaps the best source of inspiration is the code of the function continuation!(it::ContIterable, state::ContState, contRes::ContResult) where the iterator is used at its fullest. You will see how the eigen-elements and the stability are computed, how bifurcations are detected and how results are saved.","category":"page"},{"location":"detectionBifurcation/#Detection-of-bifurcation-points-1","page":"Bifurcation detection","title":"Detection of bifurcation points","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"The bifurcations are detected during a call to br, _ = continuation(F, J, u0, p0, lens, contParams::ContinuationPar;kwargs...) by turning on the following flags:","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"contParams.detectBifurcation = 2","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"The bifurcation points are located by looking at the spectrum e.g. by monitoring the unstable eigenvalues. The eigenvalue λ is declared unstable if real(λ) > contParams.precisionStability. The located bifurcation points are then returned in br.bifpoint. ","category":"page"},{"location":"detectionBifurcation/#Precise-detection-of-bifurcation-points-using-Bisection-1","page":"Bifurcation detection","title":"Precise detection of bifurcation points using Bisection","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"Note that the bifurcation points detected when detectBifurcation = 2 are only approximate bifurcation points. Indeed, we only signal that, in between two continuation steps which can be large, a (several) bifurcation has been detected. Hence, we only have a rough idea of where the bifurcation is located, unless your dsmax is very small... This can be improved as follows.","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"If you choose detectBifurcation = 3, a bisection algorithm is used to locate the bifurcation points more precisely. It means that we recursively track down the change in stability. Some options in ContinuationPar control this behavior:","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"nInversion: number of sign inversions in the bisection algorithm\nmaxBisectionSteps maximum number of bisection steps\ntolBisectionEigenvalue tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"If this is still not enough, you can use a Newton solver to locate them very precisely. See Fold / Hopf Continuation.","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"tip: Bisection mode\nDuring the bisection, the eigensolvers are called like eil(J, nev; bisection = true) in order to be able to adapt the solver precision.","category":"page"},{"location":"detectionBifurcation/#Large-scale-computations-1","page":"Bifurcation detection","title":"Large scale computations","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"The user must specify the number of eigenvalues to be computed (like nev = 10) in the parameters ::ContinuationPar passed to continuation. Note that nev is automatically incremented whenever a bifurcation point is detected [1]. Also, there is an option in ::ContinuationPar to save (or not) the eigenvectors. This can be useful in memory limited environments (like on GPUs).","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"[1] In this case, the Krylov dimension is not increased because the eigensolver could be a direct solver. You might want to increase this dimension using the callbacks in continuation. ","category":"page"},{"location":"detectionBifurcation/#List-of-detected-bifurcation-points-1","page":"Bifurcation detection","title":"List of detected bifurcation points","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"Bifurcation index used\nFold fold\nHopf hopf\nBranch point (single eigenvalue stability change) bp\nNeimark-Sacker ns\nPeriod doubling pd\nNot documented nd","category":"page"},{"location":"detectionBifurcation/#Eigensolver-1","page":"Bifurcation detection","title":"Eigensolver","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"The user must provide an eigensolver by setting NewtonOptions.eigsolver where NewtonOptions is located in the parameter ::ContinuationPar passed to continuation. See NewtonPar and ContinuationPar for more information on the composite type of the options passed to newton and continuation.","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"The eigensolver is highly problem dependent and this is why the user should implement / parametrize its own eigensolver through the abstract type AbstractEigenSolver or select one among List of implemented eigen solvers.","category":"page"},{"location":"detectionBifurcation/#Generic-bifurcation-1","page":"Bifurcation detection","title":"Generic bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"By this we mean a change in the dimension of the Jacobian kernel. The detection of Branch point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"The detection is triggered by setting detectBifurcation > 0 in the parameter ::ContinuationPar passed to continuation. ","category":"page"},{"location":"detectionBifurcation/#Fold-bifurcation-1","page":"Bifurcation detection","title":"Fold bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"The detection of Fold point is done by monitoring  the monotonicity of the parameter.","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"The detection is triggered by setting detectFold = true in the parameter ::ContinuationPar passed to continuation. When a Fold is detected on a branch br, a point is added to br.foldpoint allowing for later refinement using the function newtonFold.","category":"page"},{"location":"detectionBifurcation/#Hopf-bifurcation-1","page":"Bifurcation detection","title":"Hopf bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"The detection of Branch point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"The detection is triggered by setting detectBifurcation > 0 in the parameter ::ContinuationPar passed to continuation. When a Hopf point is detected, a point is added to br.bifpoint allowing for later refinement using the function newtonHopf.","category":"page"},{"location":"detectionBifurcation/#Bifurcations-of-periodic-orbits-1","page":"Bifurcation detection","title":"Bifurcations of periodic orbits","text":"","category":"section"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"The detection is triggered by setting detectBifurcation > 0 in the parameter ::ContinuationPar passed to continuation. The detection of bifurcation points is done by analysis of the spectrum of the Monodromy matrix composed of the Floquet multipliers. The following bifurcations are currently detected:","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"Fold of periodic orbit\nNeimark-Sacker \nPeriod doubling","category":"page"},{"location":"detectionBifurcation/#","page":"Bifurcation detection","title":"Bifurcation detection","text":"danger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of the eigensolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.   ","category":"page"},{"location":"linearsolver/#Linear-solvers-1","page":"Linear / Eigen Solvers","title":"Linear solvers","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"If you provide your own linear solver, it must be a subtype of AbstractLinearSolver otherwise BifurcationKit.jl will not recognize it. See example just below. ","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"The linear solvers provide a way of inverting the Jacobian J or solving J * x = rhs. Such linear solver linsolve will be called like sol, success, itnumber = linsolve(J, rhs) throughout the package.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Here is an example of the simplest of them (see src/LinearSolver.jl for the true implementation) to give you an idea, the backslash operator:","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"struct DefaultLS <: AbstractLinearSolver end\n\nfunction (l::DefaultLS)(J, rhs)\n\treturn J \\ rhs, true, 1\nend","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Note that for newton to work, the linear solver must return 3 arguments. The first one is the result, the second one is whether the computation was successful and the third is the number of iterations required to perform the computation.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"You can then call it as follows (and it will be called like this in newton)","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"ls = DefaultLS()\nls(rand(2,2), rand(2))","category":"page"},{"location":"linearsolver/#List-of-implemented-linear-solvers-1","page":"Linear / Eigen Solvers","title":"List of implemented linear solvers","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Default \\ solver based on LU or Cholesky depending on the type of the Jacobian. This works for sparse matrices as well. You can create one via linsolver = DefaultLS().\nGMRES from IterativeSolvers.jl. You can create one via linsolver = GMRESIterativeSolvers() and pass appropriate options.\nGMRES from KrylovKit.jl. You can create one via linsolver = GMRESKrylovKit() and pass appropriate options.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"note: Other solvers\nIt is very straightforward to implement the Conjugate Gradients from IterativeSolvers.jl by copying the interface done for gmres. Same goes for minres,... Not needing them, I did not implement this.","category":"page"},{"location":"linearsolver/#Preconditioner-1","page":"Linear / Eigen Solvers","title":"Preconditioner","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Preconditioners should be considered when using Matrix Free methods such as GMRES. GMRESIterativeSolvers provides a very simple interface for using them. For GMRESKrylovKit, we implemented a left preconditioner. Note that, for GMRESKrylovKit, you are not restricted to use Vectors anymore. Finally, here are some packages to use preconditioner","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"IncompleteLU.jl an ILU like preconditioner\nAlgebraicMultigrid.jl Algebraic Multigrid (AMG) preconditioners. This works especially well for symmetric positive definite matrices.\nPreconditioners.jl A convenient interface to conveniently called most of the above preconditioners using a single syntax.\nWe provide a preconditioner based on deflation of eigenvalues (also called preconditioner based on Leading Invariant Subspaces) using a partial Schur decomposition. There are two ways to define one i.e. PrecPartialSchurKrylovKit and PrecPartialSchurArnoldiMethod. ","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"tip: Using Preconditioners\nApart from setting a preconditioner for a linear solver, it can be advantageous to change the preconditioner during computations, e.g. during a call to continuation or newton. This can be achieved by taking advantage of the callbacks to these methods. See the example Complex Ginzburg-Landau 2d.","category":"page"},{"location":"linearsolver/#Eigen-solvers-1","page":"Linear / Eigen Solvers","title":"Eigen solvers","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"The eigen solvers must be subtypes of AbstractEigenSolver. ","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"They provide a way of computing the eigen elements of the Jacobian J. Such eigen solver eigsolve will be called like ev, evecs, itnumber = eigsolve(J, nev; kwargs...) throughout the package, nev being the number of requested eigen elements of largest real part and kwargs being used to send information about the algorithm (perform bisection,...).","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Here is an example of the simplest of them (see src/EigSolver.jl for the true implementation) to give you an idea:","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"struct DefaultEig <: AbstractEigenSolver end\n\nfunction (l::DefaultEig)(J, nev; kwargs...)\n\t# I put Array so we can call it on small sparse matrices\n\tF = eigen(Array(J))\n\tI = sortperm(F.values, by = x-> real(x), rev = true)\n\tnev2 = min(nev, length(I))\n\treturn F.values[I[1:nev2]], F.vectors[:, I[1:nev2]], true, 1\nend","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"warning: Eigenvalues\nThe eigenvalues must be ordered by increasing real part for the detection of bifurcations to work properly.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"warning: Eigenvectors\nYou have to implement the method geteigenvector(eigsolver, eigenvectors, i::Int) for newtonHopf to work properly.","category":"page"},{"location":"linearsolver/#Methods-for-computing-eigenvalues-1","page":"Linear / Eigen Solvers","title":"Methods for computing eigenvalues","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Like for the linear solvers, computing the spectrum of operators A associated to PDE is a highly non trivial task because of the clustering of eigenvalues. Most methods are based on the so-called power method but this only yields the eigenvalues with largest modulus. In case of the Laplacian operator, this can be disastrous and it is better to apply the power method to (sigma I-A)^-1 instead. ","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"This method, called Shift-invert, is readily available for the solver EigArpack, see below. It is mostly used to compute interior eigenvalues. For the solver EigKrylovKit, one must implement its own shift invert operator, using for example GMRESKrylovKit.","category":"page"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"In some cases, it may be advantageous to consider the Cayley transform (sigma I-A)^-1(tau I+A) to focus on a specific part of the spectrum. As it is mathematically equivalent to the Shift-invert method, we did not implement it.","category":"page"},{"location":"linearsolver/#List-of-implemented-eigen-solvers-1","page":"Linear / Eigen Solvers","title":"List of implemented eigen solvers","text":"","category":"section"},{"location":"linearsolver/#","page":"Linear / Eigen Solvers","title":"Linear / Eigen Solvers","text":"Default Julia eigensolver for matrices. You can create it via eig = DefaultEig(). Note that you can also specify how the eigenvalues are ordered (by decreasing real part by default). You can then compute 3 eigenelements of J like eig(J, 3).\nEigensolver from Arpack.jl. You can create one via eigsolver = EigArpack() and pass appropriate options (see Arpack.jl). For example, you can compute eigenvalues using Shift-Invert method with shift σ by using EigArpack(σ, :LR). Note that you can specify how the eigenvalues are ordered (by decreasing real part by default). Finally, this method can be used for (sparse) matrix or Matrix-Free formulation. For a matrix J, you can compute 3 eigen-elements using eig(J, 3). In the case of a Matrix-Free jacobian dx -> J(dx), you need to tell the eigensolver the dimension of the state space by giving an example of vector: eig = EigArpack(v0 = zeros(10)). You can then compute 3 eigen-elements using eig(dx -> J(dx), 3). \nEigensolver from KrylovKit.jl. You create one via eigsolver = EigKrylovKit() and pass appropriate options (see KrylovKit.jl). This method can be used for (sparse) matrix or Matrix-Free formulation. In the case of a matrix J, you can create a solver like this eig = EigKrylovKit(). Then, you compute 3 eigen-elements using eig(J, 3). In the case of a Matrix-Free jacobian dx -> J(dx), you need to tell the eigensolver the dimension of the state space by giving an example of vector: eig = EigKrylovKit(x₀ = zeros(10)). You can then compute 3 eigen-elements using eig(dx -> J(dx), 3).\nEigensolver from ArnoldiMethod.jl. You can create one via eigsolver = EigArnoldiMethod() and pass appropriate options (see ArnoldiMethod.jl). For example, you can compute eigenvalues using the Shift-Invert method with shift σ by using EigArpack(σ, LR()). Note that you can also specify how the eigenvalues are ordered (by decreasing real part by default). In the case of a matrix J, you can create a solver like eig = EigArpack(). Then, you compute 3 eigen-elements using eig(J, 3). In the case of a Matrix-Free jacobian dx -> J(dx), you need to tell the eigensolver the dimension of the state space by giving an example of vector: eig = EigArpack(x₀ = zeros(10)). You can then compute 3 eigen-elements using eig(dx -> J(dx), 3). ","category":"page"},{"location":"tutorials3/#Brusselator-1d-(automatic)-1","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"","category":"section"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"Pages = [\"tutorials3.md\"]\nDepth = 3","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"unknown: References\nThis example is taken from Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust, 1997.","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We look at the Brusselator in 1d. The equations are as follows","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"beginaligned frac  partial X   partial t   = frac  D _  1    l ^  2   frac  partial ^  2  X   partial z ^  2   + X ^  2  Y - ( β + 1 ) X + α  frac  partial Y   partial t   = frac  D _  2    l ^  2   frac  partial ^  2  Y   partial z ^  2   + β X - X ^  2  Y endaligned","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"with Dirichlet boundary conditions","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"beginarray  l   X ( t  z = 0 ) = X ( t  z = 1 ) = α    Y ( t  z = 0 ) = Y ( t  z = 1 ) = β  α  endarray","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"These equations have been introduced to reproduce an oscillating chemical reaction. There is an obvious equilibrium (α β  α). Here, we consider bifurcations with respect to the parameter l.","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We start by writing the PDE","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"using Revise\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Setfield, Parameters\nconst BK = BifurcationKit\n\nf1(u, v) = u * u * v\nnorminf = x -> norm(x, Inf)\n\nfunction Fbru(x, p)\n\t@unpack α, β, D1, D2, l = p\n\tf = similar(x)\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\tc1 = D1 / l^2 / h2\n\tc2 = D2 / l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\t# Dirichlet boundary conditions\n\tf[1]   = c1 * (α      - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])\n\tf[end] = c2 * (v[n-1] - 2v[n] + β / α)\t\t\t + β * u[n] - f1(u[n], v[n])\n\n\tf[n]   = c1 * (u[n-1] - 2u[n] +  α  )  + α - (β + 1) * u[n] + f1(u[n], v[n])\n\tf[n+1] = c2 * (β / α  - 2v[1] + v[2])\t\t\t + β * u[1] - f1(u[1], v[1])\n\n\tfor i=2:n-1\n\t\t  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])\n\t\tf[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])\t\t\t  + β * u[i] - f1(u[i], v[i])\n\tend\n\treturn f\nend","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"For computing periodic orbits, we will need a Sparse representation of the Jacobian:","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"function Jbru_sp(x, p)\n\t@unpack α, β, D1, D2, l = p\n\t# compute the Jacobian using a sparse representation\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\n\tc1 = D1 / p.l^2 / h2\n\tc2 = D2 / p.l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\tdiag   = zeros(eltype(x), 2n)\n\tdiagp1 = zeros(eltype(x), 2n-1)\n\tdiagm1 = zeros(eltype(x), 2n-1)\n\n\tdiagpn = zeros(eltype(x), n)\n\tdiagmn = zeros(eltype(x), n)\n\n\t@. diagmn = β - 2 * u * v\n\t@. diagm1[1:n-1] = c1\n\t@. diagm1[n+1:end] = c2\n\n\t@. diag[1:n]    = -2c1 - (β + 1) + 2 * u * v\n\t@. diag[n+1:2n] = -2c2 - u * u\n\n\t@. diagp1[1:n-1] = c1\n\t@. diagp1[n+1:end] = c2\n\n\t@. diagpn = u * u\n\treturn spdiagm(0 => diag, 1 => diagp1, -1 => diagm1, n => diagpn, -n => diagmn)\nend","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"tip: Tip\nWe could have used DiffEqOperators.jl like for the Swift-Hohenberg tutorial.","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We shall now compute the equilibria and their stability.","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"n = 300\n\n# parameters of the Brusselator model and guess for the stationary solution\npar_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)\nsol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"For the eigensolver, we use a Shift-Invert algorithm (see Eigen solvers)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"eigls = EigArpack(1.1, :LM)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We continue the trivial equilibrium to find the Hopf points","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"opt_newton = NewtonPar(eigsolver = eigls, verbose = false)\nopts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.01, ds = 0.001, \n\tpMax = 1.9, detectBifurcation = 3, nev = 21, plotEveryStep = 50, \n\tnewtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 1060,\n\t# specific options for precise localization of Hopf points\n\tnInversion = 6)\n\n\tbr, = @time continuation(Fbru, Jbru_sp, sol0, par_bru, (@lens _.l),\n\t\topts_br_eq, verbosity = 0,\n\t\tplot = true,\n\t\tprintSolution = (x,p) -> x[div(n,2)], normC = norminf)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We obtain the following bifurcation diagram with 3 Hopf bifurcation points","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/#Normal-form-computation-1","page":"Brusselator 1d (automatic)","title":"Normal form computation","text":"","category":"section"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We can compute the normal form of the Hopf points as follows","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"using ForwardDiff\nfunction D(f, x, p, dx)\n\treturn ForwardDiff.derivative(t->f(x .+ t .* dx, p), 0.)\nend\nd1Fbru(x,p,dx1) = D((z, p0) -> Fbru(z, p0), x, p, dx1)\nd2Fbru(x,p,dx1,dx2) = D((z, p0) -> d1Fbru(z, p0, dx1), x, p, dx2)\nd3Fbru(x,p,dx1,dx2,dx3) = D((z, p0) -> d2Fbru(z, p0, dx1, dx2), x, p, dx3)\n\n# we group the differentials together\njet  = (Fbru, Jbru_sp, d2Fbru, d3Fbru)\n\nhopfpt = BK.computeNormalForm(jet..., br, 1)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"and you should get","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"julia> hopfpt.nf\n(a = 0.8793481836104302 + 0.5685578928001935im, b = -0.000937645904575657 + 0.0009393897255040567im)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"You also have access to the criticality:","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"julia> hopfpt.type\n:Supercritical","category":"page"},{"location":"tutorials3/#Continuation-of-Hopf-points-1","page":"Brusselator 1d (automatic)","title":"Continuation of Hopf points","text":"","category":"section"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We use the bifurcation points guesses located in br.bifpoint to turn them into precise bifurcation points. For the second one, we have","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"# index of the Hopf point in br.bifpoint\nind_hopf = 2\nhopfpoint, _, flag = @time newton(Fbru, Jbru_sp,\n\tbr, ind_hopf, par_bru, (@lens _.l); normN = norminf)\nflag && printstyled(color=:red, \"--> We found a Hopf Point at l = \", hopfpoint.p[1], \", ω = \", hopfpoint.p[2], \", from l = \", br.bifpoint[ind_hopf].param, \"\\n\")","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"which produces","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"--> We found a Hopf Point at l = 1.0239851696548035, ω = 2.1395092895339842, from l = 1.0353910524340078","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We now perform a Hopf continuation with respect to the parameters l, β","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"tip: Tip\nYou don't need to call newtonHopf first in order to use continuationHopf.","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"br_hopf, = @time continuation(Fbru, Jbru_sp,\n\tbr, ind_hopf, par_bru, (@lens _.l), (@lens _.β),\n\tContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 6.5, pMin = 0.0, newtonOptions = opt_newton), verbosity = 2, normC = norminf)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"which gives using plot(br_hopf, xlabel=\"beta\", ylabel = \"l\")","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/#Computation-of-the-branch-of-periodic-orbits-(Finite-differences)-1","page":"Brusselator 1d (automatic)","title":"Computation of the branch of periodic orbits (Finite differences)","text":"","category":"section"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We now compute the bifurcated branches of periodic solutions from the Hopf points using Periodic orbits based on finite differences. One has just to pass a PeriodicOrbitTrapProblem.","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We start by providing a linear solver and some options for the continuation to work","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"# automatic branch switching from Hopf point\nopt_po = NewtonPar(tol = 1e-10, verbose = true, maxIter = 15)\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.04, ds = 0.03, pMax = 2.2, maxSteps = 200, newtonOptions = opt_po, saveSolEveryStep = 2,\n\tplotEveryStep = 1, nev = 11, precisionStability = 1e-6,\n\tdetectBifurcation = 3, dsminBisection = 1e-6, maxBisectionSteps = 15, tolBisectionEigenvalue = 0.)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"# number of time slices for the periodic orbit\nM = 51\nprobFD = PeriodicOrbitTrapProblem(M = M)\nbr_po, = continuation(\n\t# arguments for branch switching from the first \n\t# Hopf bifurcation point\n\tjet..., br, 1,\n\t# arguments for continuation\n\topts_po_cont, probFD;\n\t# OPTIONAL parameters\n\t# we want to jump on the new branch at phopf + δp\n\t# ampfactor is a factor to increase the amplitude of the guess\n\tδp = 0.01, ampfactor = 1,\n\t# specific method for solving linear system\n\t# of Periodic orbits with trapeze method\n\tlinearPO = :FullLU,\n\t# regular options for continuation\n\tverbosity = 3,\tplot = true, \n\tplotSolution = (x, p; kwargs...) -> heatmap!(getTrajectory(probFD, x, par_bru).u'; ylabel=\"time\", color=:viridis, kwargs...), normC = norminf)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"Using the above call, it is very easy to find the first branches:","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We note that there are several branch points (blue points) on the above diagram. This means that there are additional branches in the neighborhood of these points. We now turn to automatic branch switching on these branches. This functionality, as we shall see, is only provided for PeriodicOrbitTrapProblem.","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"Let's say we want to branch from the first branch point of the first curve pink branch. The syntax is very similar to the previous one:","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"br_po2, = BK.continuationPOTrapBPFromPO(\n\t# arguments for branch switching\n\tbr_po, 1,\n\t# arguments for continuation\n\topts_po_cont; linearPO = :FullLU,\n\tampfactor = 1., δp = 0.01,\t\n\tverbosity = 3,\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> (heatmap!(getTrajectory(probFD, x, par_bru).u'; ylabel=\"time\", color=:viridis, kwargs...)),\n\tnormC = norminf)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"It is now straightforward to get the full following diagram","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/#Computation-of-the-branch-of-periodic-orbits-(Standard-Shooting)-1","page":"Brusselator 1d (automatic)","title":"Computation of the branch of periodic orbits (Standard Shooting)","text":"","category":"section"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"Note that what follows is not really optimized on the DifferentialEquations.jl side. Indeed, we do not use automatic differentiation, we do not pass the sparsity pattern, ...","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We now turn to a different method based on the flow of the Brusselator. To compute this flow (time stepper), we need to be able to solve the differential equation (actually a PDE) associated to the vector field Fbru. We will show how to do this with an implicit method Rodas4P from DifferentialEquations.jl. Note that the user can pass its own time stepper but for convenience, we use the ones in DifferentialEquations.jl. More information regarding the shooting method is contained in Periodic orbits based on the shooting method. To define the flow, it is better to have an inplace version of the vector field:","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"function Fbru!(f, x, p)\n\t@unpack α, β, D1, D2, l = p\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\tc1 = D1 / l^2 / h2\n\tc2 = D2 / l^2 / h2\n\t\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\t\n\t# Dirichlet boundary conditions\n\tf[1]   = c1 * (α\t  - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])\n\tf[end] = c2 * (v[n-1] - 2v[n] + β / α)\t\t\t + β * u[n] - f1(u[n], v[n])\n\t\n\tf[n]   = c1 * (u[n-1] - 2u[n] +  α   ) + α - (β + 1) * u[n] + f1(u[n], v[n])\n\tf[n+1] = c2 * (β / α  - 2v[1] + v[2])\t\t\t + β * u[1] - f1(u[1], v[1])\n\t\n\tfor i=2:n-1\n\t\t  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])\n\t\tf[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])\t\t\t  + β * u[i] - f1(u[i], v[i])\n\tend\n\treturn f\nend\n\nfunction Fbru(x, p)\n\tf = similar(x)\n\tFbru!(f, x, p)\nend","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We then recompute the locus of the Hopf bifurcation points using the same method as above.","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"n = 100\n\n# different parameters to define the Brusselator model and guess for the stationary solution\npar_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)\nsol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))\n\neigls = EigArpack(1.1, :LM)\nopts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.00615, ds = 0.0061, pMax = 1.9, \n\tdetectBifurcation = 3, nev = 21, plotEveryStep = 50, \n\tnewtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 200)\n\nbr, = @time continuation(Fbru, Jbru_sp,\n\tsol0, par_bru, (@lens _.l), opts_br_eq, verbosity = 0,\n\tplot = false,\n\tprintSolution = (x, p)->x[div(n,2)], normC = norminf)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We need to build a problem which encodes the Shooting functional. This done as follows where we first create the time stepper:","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"using DifferentialEquations, DiffEqOperators\n\nFOde(f, x, p, t) = Fbru!(f, x, p)\n\nu0 = sol0 .+ 0.01 .* rand(2n)\n\n# this is the ODE time stepper when used with `solve`\nprobsundials = ODEProblem(FOde, u0, (0., 1000.), par_bru;\n\tatol = 1e-10, rtol = 1e-8)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We also compute with automatic differentiation, the differentials of the vector field. This is is needed for branch switching as it is based on the computation of the Hopf normal form:","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"using ForwardDiff\nfunction D(f, x, p, dx)\n\treturn ForwardDiff.derivative(t->f(x .+ t .* dx, p), 0.)\nend\nd1Fbru(x,p,dx1) = D((z, p0) -> Fbru(z, p0), x, p, dx1)\n\td2Fbru(x,p,dx1,dx2) = D((z, p0) -> d1Fbru(z, p0, dx1), x, p, dx2)\n\td3Fbru(x,p,dx1,dx2,dx3) = D((z, p0) -> d2Fbru(z, p0, dx1, dx2), x, p, dx3)\n\njet  = (Fbru, Jbru_sp, d2Fbru, d3Fbru)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We are now ready to call the automatic branch switching. Note how similar it is to the previous section based on finite differences. This case is more deeply studied in the tutorial Brusselator 1d (advanced user).","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"# linear solvers\nls = GMRESIterativeSolvers(tol = 1e-7, maxiter = 100, verbose = false)\neig = EigKrylovKit(tol= 1e-12, x₀ = rand(2n), verbose = 0, dim = 40)\n# newton parameters\noptn_po = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 25, linsolver = ls, eigsolver = eig)\n# continuation parameters\nopts_po_cont = ContinuationPar(dsmax = 0.03, ds= 0.01, pMax = 2.5, maxSteps = 10, newtonOptions = (@set optn_po.tol = 1e-7), nev = 25, precisionStability = 1e-8, detectBifurcation = 0, plotEveryStep = 2)\n\nMt = 4 # number of shooting sections\nbr_po, = continuation(\n\tjet..., br, 1,\n\t# arguments for continuation\n\topts_po_cont,\n\t# this is where we tell that we want Standart Shooting\n\tShootingProblem(Mt, par_bru, probsundials, Rodas4P());\n\tampfactor = 1.2, δp = 0.01,\n\tverbosity = 3,\tplot = true,\n\tprintSolution = (x, p) -> x[end],\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicShooting!(x[1:end-1], Mt; kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"and you should see ","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"(Image: )","category":"page"},{"location":"tutorials3/#Computation-of-the-branch-of-periodic-orbits-(Poincaré-Shooting)-1","page":"Brusselator 1d (automatic)","title":"Computation of the branch of periodic orbits (Poincaré Shooting)","text":"","category":"section"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We now turn to another Shooting method, namely the Poincaré one. We can provide this method thanks to the unique functionalities of DifferentialEquations.jl. More information is provided at PoincareShootingProblem and Periodic orbits based on the shooting method but basically, it is a shooting method between Poincaré sections Sigma_i (along the orbit) defined by hyperplanes. As a consequence, the dimension of the unknowns is M_shcdot(N-1) where N is the dimension of the phase space. Indeed, each time slice lives in an hyperplane Sigma_i. Additionally, the period T is not an unknown of the method but rather a by-product. However, the method requires the time stepper to find when the flow hits an hyperplane Sigma_i, something called event detection.","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"We show how to use this method, the code is very similar to the case of the Standard Shooting:","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"# number of sections\nMt = 2\n# linear solvers\nls = GMRESIterativeSolvers(tol = 1e-7, maxiter = 100, verbose = false)\neig = EigKrylovKit(tol= 1e-12, x₀ = rand(2n-1), verbose = 0, dim = 40)\n# newton parameters\noptn_po = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 25, linsolver = ls, eigsolver = eig)\n# continuation parameters\nopts_po_cont = ContinuationPar(dsmax = 0.03, ds= 0.0051, pMax = 2.5, maxSteps = 100, newtonOptions = (@set optn_po.tol = 1e-7), nev = 25, precisionStability = 1e-8, detectBifurcation = 3, plotEveryStep = 2)\n\nbr_po, u = continuation(\n\tjet...,\tbr, 1,\n\t# arguments for continuation\n\topts_po_cont, PoincareShootingProblem(Mt, par_bru, probsundials, Rodas4P());\n\tampfactor = 1.4, δp = 0.01,\n\tverbosity = 3,\tplot = true, printPeriod = true,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicShooting!(x[1:end-1], Mt; kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"and you should see:","category":"page"},{"location":"tutorials3/#","page":"Brusselator 1d (automatic)","title":"Brusselator 1d (automatic)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/#Automatic-diagram-of-2d-Bratu–Gelfand-problem-(Intermediate)-1","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"","category":"section"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Pages = [\"mittelmannAuto.md\"]\nDepth = 3","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"unknown: References\nThe following example is exposed in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. The Computation of Disconnected Bifurcation Diagrams. ArXiv:1603.00809 [Math], March 2, 2016.","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We consider the problem of Mittelmann:","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Delta u +NL(lambdau) = 0","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"with Neumann boundary condition on Omega = (01)^2 and where NL(lambdau)equiv-10(u-lambda e^u). This is a good example to show how automatic bifurcation diagram computation works.","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We start with some imports:","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"using Revise\nusing DiffEqOperators, ForwardDiff\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield\nconst BK = BifurcationKit\n\n# define the sup norm\nnorminf = x -> norm(x, Inf)\n\n# some plotting functions to simplify our life\nplotsol!(x, nx = Nx, ny = Ny; kwargs...) = heatmap!(reshape(x, nx, ny); color = :viridis, kwargs...)\nplotsol(x, nx = Nx, ny = Ny; kwargs...) = (plot();plotsol!(x, nx, ny; kwargs...))","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"and with the discretization of the problem","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"function Laplacian2D(Nx, Ny, lx, ly, bc = :Neumann)\n\thx = 2lx/Nx\n\thy = 2ly/Ny\n\tD2x = CenteredDifference(2, 2, hx, Nx)\n\tD2y = CenteredDifference(2, 2, hy, Ny)\n\n\tQx = Neumann0BC(hx)\n\tQy = Neumann0BC(hy)\n\n\tD2xsp = sparse(D2x * Qx)[1]\n\tD2ysp = sparse(D2y * Qy)[1]\n\tA = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))\n\treturn A\nend\n\nϕ(u, λ)  = -10(u-λ*exp(u))\ndϕ(u, λ) = -10(1-λ*exp(u))\n\nfunction NL!(dest, u, p)\n\t@unpack λ = p\n\tdest .= ϕ.(u, λ)\n\treturn dest\nend\n\nNL(u, p) = NL!(similar(u), u, p)\n\nfunction Fmit!(f, u, p)\n\tmul!(f, p.Δ, u)\n\tf .= f .+ NL(u, p)\n\treturn f\nend\n\nFmit(u, p) = Fmit!(similar(u), u, p)","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"It will also prove useful to have the jacobian of our functional and the other derivatives: ","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"function JFmit(x,p)\n\tJ = p.Δ\n\tdg = dϕ.(x, p.λ)\n\treturn J + spdiagm(0 => dg)\nend\n\nD(f, x, p, dx) = ForwardDiff.derivative(t->f(x .+ t .* dx, p), 0.)\nd1Fmit(x,p,dx1) = D((z, p0) -> Fmit(z, p0), x, p, dx1)\nd2Fmit(x,p,dx1,dx2) = D((z, p0) -> d1Fmit(z, p0, dx1), x, p, dx2)\nd3Fmit(x,p,dx1,dx2,dx3) = D((z, p0) -> d2Fmit(z, p0, dx1, dx2), x, p, dx3)\njet = (Fmit, JFmit, d2Fmit, d3Fmit)","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We need to pass the parameters associated to this problem:","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Nx = 30\nNy = 30\nlx = 0.5\nly = 0.5\n\nΔ = Laplacian2D(Nx, Ny, lx, ly)\n\n# parameters associated with the PDE\npar_mit = (λ = .01, Δ = Δ)\n\n# initial condition\nsol0 = 0*ones(Nx, Ny) |> vec","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"To compute the eigenvalues, we opt for the solver in KrylovKit.jl","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"# eigensolver\neigls = EigKrylovKit(dim = 70)\n\n# options for Newton solver\nopt_newton = NewtonPar(tol = 1e-8, verbose = true, eigsolver = eigls, maxIter = 20)\n\n# options for continuation, we want to locate very precisely the \n# bifurcation points, so we tune the bisection accordingly\nopts_br = ContinuationPar(dsmin = 0.0001, dsmax = 0.04, ds = 0.005, pMax = 3.5, pMin = 0.01, detectBifurcation = 3, nev = 50, plotEveryStep = 10, newtonOptions = (@set opt_newton.verbose = false), maxSteps = 251, precisionStability = 1e-6, nInversion = 6, dsminBisection = 1e-7, maxBisectionSteps = 25, tolBisectionEigenvalue = 1e-19)","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Note that we put the option detectBifurcation = 3 to detect bifurcations precisely with a bisection method. Indeed, we need to locate these branch points precisely to be able to call automatic branch switching.","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"In order to have an output like Auto07p, we provide the finaliser (see arguments of continuation)","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"function finSol(z, tau, step, br)\n\tif ~isnothing(br.bifpoint)\n\t\tif br.bifpoint[end].step == step\n\t\t\tBK._show(stdout, br.bifpoint[end], step)\n\t\tend\n\tend\n\treturn true\nend","category":"page"},{"location":"mittelmannAuto/#Automatic-bifurcation-diagram-1","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic bifurcation diagram","text":"","category":"section"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"In order to avoid spurious branch switching, we use a callback (see continuation) to reject specific continuation steps where the jump in parameters is too large or when the residual is too large:","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"function cb(x,f,J,res,it,itl,optN; kwargs...)\n\t_x = get(kwargs, :z0, nothing)\n\tfromNewton = get(kwargs, :fromNewton, false)\n\tif ~fromNewton\n\t\treturn (norm(_x.u - x) < 20.5 && abs(_x.p - kwargs[:p]) < 0.05)\n\tend\n\ttrue\nend","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Finally, before calling the automatic bifurcationdiagram, we need to provide a function to adjust the continuation parameters as function of the branching level (Note that this function can be constant).","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"function optionsCont(x,p,l; opt0 = opts_br)\n\tif l == 1\n\t\treturn opt0\n\telseif l==2\n\t\treturn setproperties(opt0 ;detectBifurcation = 3,ds = 0.001, a = 0.75)\n\telse\n\t\treturn setproperties(opt0 ;detectBifurcation = 3,ds = 0.00051, dsmax = 0.01)\n\tend\nend","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We are then ready to compute the bifurcation diagram. If we choose a level 5 of recursion like ","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"# weight for normbratu\nconst w = ones(Nx*Ny)\nnormbratu = x -> norm(x .* w) / sqrt(length(x))\n\n\ndiagram = bifurcationdiagram(jet...,\n\tsol0, par_mit, (@lens _.λ), \n\t# important argument: this is the maximal \n\t# recursion level \n\t5, \n\toptionsCont;\n\tverbosity = 0, plot = true,\n\tprintSolution = (x, p) -> normbratu(x),\n\tcallbackN = cb,\n\tusedeflation = true,\n\tfinaliseSolution = finSol,\n\tplotSolution = (x, p; kwargs...) -> plotsol!(x ; kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"this gives using plot(diagram; plotfold = false, putbifptlegend=false, markersize=2);title!(\"\"):","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We can zoom in on the left part to get ","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Actually, this plot is misleading because of the symmetries. If we chose a weighted norm which breaks those symmetries","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"w = (lx .+ LinRange(-lx,lx,Nx)) * (LinRange(-ly,ly,Ny))' |> vec\nw .-= minimum(w)\nnormbratu = x -> norm(x .* w) / sqrt(length(x))","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"and use it to print the solution (we redid the computation), we get:","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We can make more sense of these spaghetti by only plotting the first two levels of recursion","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"plot(diagram; level = (1, 2), plotfold = false, putbifptlegend=false, markersize=2)\ntitle!(\"#branches = $(size(getBranch(diagram, code)))\")","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/#Interactive-exploration-1","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Interactive exploration","text":"","category":"section"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"We can see that the non-simple 2d branch points (magenta points) have produced non trivial branches. For example, we can look at the second bifurcation point (the first is the fold) which is composed of 8 branches","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"plot(getBranchesFromBP(diagram, 2); plotfold = false, legend = false)","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/#Interactive-computation-1","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Interactive computation","text":"","category":"section"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"Let's say you have been cautious and did not launch a deep bifurcation diagram computation by using a small recursion level 2:","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"diagram = bifurcationdiagram(jet...,\n\tsol0, par_mit, (@lens _.λ), \n\t# here the recusion level is\n\t2,\n\toptionsCont;\n\tverbosity = 0, plot = true,\n\tprintSolution = (x, p) -> normbratu(x),\n\tcallbackN = cb,\n\ttangentAlgo = BorderedPred(),\n\tusedeflation = true,\n\tfinaliseSolution = finSol,\n\tplotSolution = (x, p; kwargs...) -> plotsol!(x ; kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"You would end up with this diagram ","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"How can we complete this diagram without recomputing it from scratch? It is easy! For example, let us complete the magenta branches as follow","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"bifurcationdiagram!(jet...,\n\t# this improves the first branch on the violet curve. Note that\n\t# for symmetry reasons, the first bifurcation point\n\t# has 8 branches\n\tgetBranch(diagram, (1,)), (current = 3, maxlevel = 6), optionsCont;\n\tverbosity = 0, plot = true,\n\tprintSolution = (x, p) -> normbratu(x),\n\tcallbackN = cb,\n\tfinaliseSolution = finSol,\n\tusedeflation = true,\n\tplotSolution = (x, p; kwargs...) -> plotsol!(x ; kwargs...),\n\tnormC = norminf)","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"This gives the following diagram. Using this call, you can pinpoint the particular location where to refine the diagram.","category":"page"},{"location":"mittelmannAuto/#","page":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","title":"Automatic diagram of 2d Bratu–Gelfand problem (Intermediate)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#Brusselator-1d-(advanced-user)-1","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"","category":"section"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Pages = [\"tutorials3b.md\"]\nDepth = 3","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"unknown: References\nThis example is taken from Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust, 1997.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"info: Goal\nThe goal of this tutorial is to show similar computations as in the previous tutorial but without using the automatic branch switching tools. This is for the experienced used who wants to dive more in the internals of the package.    ","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We look at the Brusselator in 1d. The equations are as follows","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"beginaligned frac  partial X   partial t   = frac  D _  1    l ^  2   frac  partial ^  2  X   partial z ^  2   + X ^  2  Y - ( β + 1 ) X + α  frac  partial Y   partial t   = frac  D _  2    l ^  2   frac  partial ^  2  Y   partial z ^  2   + β X - X ^  2  Y endaligned","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"with Dirichlet boundary conditions","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"beginarray  l   X ( t  z = 0 ) = X ( t  z = 1 ) = α    Y ( t  z = 0 ) = Y ( t  z = 1 ) = β  α  endarray","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"These equations have been introduced to reproduce an oscillating chemical reaction. There is an obvious equilibrium (α β  α). Here, we consider bifurcations with respect to the parameter l.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We start by writing the PDE","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"using Revise\nusing BifurcationKit, LinearAlgebra, Plots, SparseArrays, Setfield, Parameters\nconst BK = BifurcationKit\n\nf1(u, v) = u * u * v\nnorminf = x -> norm(x, Inf)\n\nfunction Fbru(x, p)\n\t@unpack α, β, D1, D2, l = p\n\tf = similar(x)\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\tc1 = D1 / l^2 / h2\n\tc2 = D2 / l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\t# Dirichlet boundary conditions\n\tf[1]   = c1 * (α      - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])\n\tf[end] = c2 * (v[n-1] - 2v[n] + β / α)\t\t\t + β * u[n] - f1(u[n], v[n])\n\n\tf[n]   = c1 * (u[n-1] - 2u[n] +  α  )  + α - (β + 1) * u[n] + f1(u[n], v[n])\n\tf[n+1] = c2 * (β / α  - 2v[1] + v[2])\t\t\t + β * u[1] - f1(u[1], v[1])\n\n\tfor i=2:n-1\n\t\t  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])\n\t\tf[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])\t\t\t  + β * u[i] - f1(u[i], v[i])\n\tend\n\treturn f\nend","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"For computing periodic orbits, we will need a Sparse representation of the Jacobian:","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"function Jbru_sp(x, p)\n\t@unpack α, β, D1, D2, l = p\n\t# compute the Jacobian using a sparse representation\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\n\tc1 = D1 / p.l^2 / h2\n\tc2 = D2 / p.l^2 / h2\n\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\n\tdiag   = zeros(eltype(x), 2n)\n\tdiagp1 = zeros(eltype(x), 2n-1)\n\tdiagm1 = zeros(eltype(x), 2n-1)\n\n\tdiagpn = zeros(eltype(x), n)\n\tdiagmn = zeros(eltype(x), n)\n\n\t@. diagmn = β - 2 * u * v\n\t@. diagm1[1:n-1] = c1\n\t@. diagm1[n+1:end] = c2\n\n\t@. diag[1:n]    = -2c1 - (β + 1) + 2 * u * v\n\t@. diag[n+1:2n] = -2c2 - u * u\n\n\t@. diagp1[1:n-1] = c1\n\t@. diagp1[n+1:end] = c2\n\n\t@. diagpn = u * u\n\treturn spdiagm(0 => diag, 1 => diagp1, -1 => diagm1, n => diagpn, -n => diagmn)\nend","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"tip: Tip\nWe could have used DiffEqOperators.jl like for the Swift-Hohenberg tutorial.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We shall now compute the equilibria and their stability.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"n = 500\n\n# parameters of the Brusselator model and guess for the stationary solution\npar_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)\nsol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"For the eigensolver, we use a Shift-Invert algorithm (see Eigen solvers)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"eigls = EigArpack(1.1, :LM)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We continue the trivial equilibrium to find the Hopf points","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"opt_newton = NewtonPar(eigsolver = eigls, verbose = false)\nopts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.01, ds = 0.001, \n\tpMax = 1.9, detectBifurcation = 3, nev = 21, plotEveryStep = 50, \n\tnewtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 1060)\n\n\tbr, = @time continuation(Fbru, Jbru_sp, sol0, par_bru, (@lens _.l),\n\t\topts_br_eq, verbosity = 0,\n\t\tplot = true,\n\t\tprintSolution = (x,p) -> x[div(n,2)], normC = norminf)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We obtain the following bifurcation diagram with 3 Hopf bifurcation points","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#Normal-form-computation-1","page":"Brusselator 1d (advanced user)","title":"Normal form computation","text":"","category":"section"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We can compute the normal form of the Hopf points as follows","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"using ForwardDiff\nfunction D(f, x, p, dx)\n\treturn ForwardDiff.derivative(t->f(x .+ t .* dx, p), 0.)\nend\nd1Fbru(x,p,dx1) = D((z, p0) -> Fbru(z, p0), x, p, dx1)\nd2Fbru(x,p,dx1,dx2) = D((z, p0) -> d1Fbru(z, p0, dx1), x, p, dx2)\nd3Fbru(x,p,dx1,dx2,dx3) = D((z, p0) -> d2Fbru(z, p0, dx1, dx2), x, p, dx3)\n\n# we group the differentials together\njet  = (Fbru, Jbru_sp, d2Fbru, d3Fbru)\n\nhopfpt = BK.computeNormalForm(jet..., br, 1)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"and you should get","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"julia> hopfpt.nf\n(a = 0.8793481836104302 + 0.5685578928001935im, b = -0.000937645904575657 + 0.0009393897255040567im)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"You also have access to the criticality:","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"julia> hopfpt.type\n:Supercritical","category":"page"},{"location":"tutorials3b/#Continuation-of-Hopf-points-1","page":"Brusselator 1d (advanced user)","title":"Continuation of Hopf points","text":"","category":"section"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We use the bifurcation points guesses located in br.bifpoint to turn them into precise bifurcation points. For the second one, we have","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"# index of the Hopf point in br.bifpoint\nind_hopf = 2\nhopfpoint, _, flag = @time newton(Fbru, Jbru_sp,\n\tbr, ind_hopf, par_bru, (@lens _.l); normN = norminf)\nflag && printstyled(color=:red, \"--> We found a Hopf Point at l = \", hopfpoint.p[1], \", ω = \", hopfpoint.p[2], \", from l = \", br.bifpoint[ind_hopf].param, \"\\n\")","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"which produces","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"--> We found a Hopf Point at l = 1.0239851696548035, ω = 2.1395092895339842, from l = 1.0353910524340078","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We now perform a Hopf continuation with respect to the parameters l, β","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"tip: Tip\nYou don't need to call newtonHopf first in order to use continuationHopf.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"br_hopf, = @time continuation(Fbru, Jbru_sp,\n\tbr, ind_hopf, par_bru, (@lens _.l), (@lens _.β),\n\tContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 6.5, pMin = 0.0, newtonOptions = opt_newton), verbosity = 2, normC = norminf)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"which gives using plot(br_hopf, xlabel=\"beta\", ylabel = \"l\")","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#Continuation-of-periodic-orbits-(Finite-differences)-1","page":"Brusselator 1d (advanced user)","title":"Continuation of periodic orbits (Finite differences)","text":"","category":"section"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Here, we perform continuation of periodic orbits branching from the Hopf bifurcation points.We need an educated guess for the periodic orbit which is given by guessFromHopf:","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"# number of time slices\nM = 51\n\nl_hopf, Th, orbitguess2, hopfpt, vec_hopf = guessFromHopf(br, ind_hopf,\n\topts_br_eq.newtonOptions.eigsolver,\n\tM, 2.7; phase = 0.25)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We wish to make two remarks at this point. The first is that an initial guess is composed of a space time solution and of the guess for the period Th of the solution. Note that the argument 2.7 is a guess for the amplitude of the orbit.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"# orbit initial guess from guessFromHopf, is not a vector, so we reshape it\norbitguess_f2 = reduce(vcat, orbitguess2)\norbitguess_f = vcat(vec(orbitguess_f2), Th) |> vec","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"The second remark concerns the phase 0.25 written above. To account for the additional unknown (i.e. the period), periodic orbit localisation using Finite Differences requires an additional constraint (see Periodic orbits based on finite differences for more details). In the present case, this constraint is","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":" u(0) - u_hopf phi = 0","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"where u_{hopf} is the equilibrium at the Hopf bifurcation and phi is real.(vec_hopf) where vec_hopf is the eigenvector. This is akin to a Poincaré section.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"The phase of the periodic orbit is set so that the above constraint is satisfied. We shall now use Newton iterations to find a periodic orbit.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Given our initial guess, we create a (family of) problem which encodes the functional associated to finding periodic orbits based on finite differences (see Periodic orbits based on finite differences for more information):","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"poTrap = PeriodicOrbitTrapProblem(\n\tFbru,    \t\t\t\t# pass the vector field\n\tJbru_sp, \t\t\t\t# pass the jacobian of the vector field\n\treal.(vec_hopf),\t\t# used to set ϕ, see the phase constraint\n\thopfpt.u,           # used to set uhopf, see the phase constraint\n\tM)\t\t\t          # number of time slices","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"To evaluate the functional at x, you call it like a function: poTrap(x, par) for the parameter par. ","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"note: Using the functional for deflation, Fold of limit cycles...\nThe functional poTrap gives you access to the underlying methods to call a regular newton. For example the functional is x -> poTrap(x, par) at parameter par. The (sparse) Jacobian at (x,p) is computed like this poTrap(Val(:JacFullSparse), x, p) while the Matrix Free version is dx -> poTrap((x, p, dx). This also allows you to call the newton deflated method (see Deflated problems) or to locate Fold point of limit cycles see PeriodicOrbitTrapProblem. You can also use preconditioners. In the case of more computationally intense problems (like the 2d Brusselator), this might be mandatory as using LU decomposition for the linear solve will use too much memory. See also the example Complex Ginzburg-Landau 2d","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"For convenience, we provide a simplified newton / continuation methods for periodic orbits. One has just to pass a PeriodicOrbitTrapProblem.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"opt_po = NewtonPar(tol = 1e-10, verbose = true, maxIter = 20)\n\toutpo_f, _, flag = @time newton(poTrap, orbitguess_f, (@set par_bru.l = l_hopf + 0.01), opt_po, normN = norminf,\n\t\tcallback = (x, f, J, res, itlin, iteration, options; kwargs...) -> (println(\"--> amplitude = \", BK.amplitude(x, n, M; ratio = 2));true))\nflag && printstyled(color=:red, \"--> T = \", outpo_f[end], \", amplitude = \", BK.amplitude(outpo_f, n, M; ratio = 2),\"\\n\")\n# plot of the periodic orbit\nBK.plotPeriodicPOTrap(outpo_f, n, M; ratio = 2)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"and obtain","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     1.5220e-03         0\n--> amplitude = 0.2218979834134469\n        1                2     2.2683e-03         2\n--> amplitude = 0.45718675563905475\n        2                3     2.5228e-04         2\n--> amplitude = 0.3894818781702887\n        3                4     4.1762e-05         2\n--> amplitude = 0.35703530908569103\n        4                5     1.1093e-06         2\n--> amplitude = 0.35161438379634213\n        5                6     8.4754e-10         2\n--> amplitude = 0.35146265668933174\n        6                7     8.0280e-14         2\n--> amplitude = 0.3514625387168946\n\n  8.223328 seconds (886.68 k allocations: 8.825 GiB, 19.14% gc time)\n--> T = 3.0094049008917816, amplitude = 0.35305974130245743","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"and","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Finally, we can perform continuation of this periodic orbit using the specialized call continuationPOTrap","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"opt_po = @set opt_po.eigsolver = EigArpack(; tol = 1e-5, v0 = rand(2n))\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.03, ds= 0.01, \n\tpMax = 3.0, maxSteps = 30, \n\tnewtonOptions = opt_po, nev = 5, precisionStability = 1e-8, detectBifurcation = 0)\nbr_po, = @time continuation(poTrap,\n\toutpo_f, (@set par_bru.l = l_hopf + 0.01), (@lens _.l),\n\topts_po_cont;\n\tverbosity = 2,\tplot = true,\n\tplotSolution = (x, p;kwargs...) -> heatmap!(reshape(x[1:end-1], 2*n, M)'; ylabel=\"time\", color=:viridis, kwargs...), \n\tnormC = norminf)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"to obtain the period of the orbit as function of l","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#Deflation-for-periodic-orbit-problems-1","page":"Brusselator 1d (advanced user)","title":"Deflation for periodic orbit problems","text":"","category":"section"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Looking for periodic orbits branching of bifurcation points, it is very useful to use newton algorithm with deflation. We thus define a deflation operator (see previous example)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"deflationOp = DeflationOperator(2.0, (x,y) -> dot(x[1:end-1], y[1:end-1]),1.0, [zero(orbitguess_f)])","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"which allows to find periodic orbits different from orbitguess_f. Note that the dot product removes the last component, i.e. the period of the cycle is not considered during this particular deflation. We can now use ","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"outpo_f, hist, flag = @time newton(poTrap,\n\t\t\torbitguess_f, (@set par_bru.l = l_hopf + 0.01), opt_po, deflationOp; linearPO = :BorderedLU, normN = norminf)","category":"page"},{"location":"tutorials3b/#Floquet-coefficients-1","page":"Brusselator 1d (advanced user)","title":"Floquet coefficients","text":"","category":"section"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"A basic method for computing Floquet cofficients based on the eigenvalues of the monodromy operator is available (see FloquetQaDTrap). It is precise enough to locate bifurcations. Their computation is triggered like in the case of a regular call to continuation:","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"opt_po = @set opt_po.eigsolver = DefaultEig()\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.04, ds= -0.01, pMax = 3.0, maxSteps = 200, saveSolEveryStep = 1, newtonOptions = opt_po, nev = 5, precisionStability = 1e-6, detectBifurcation = 3)\nbr_po, = @time continuation(poTrap,\n\toutpo_f, (@set par_bru.l = l_hopf + 0.01), (@lens _.l),\n\topts_po_cont; verbosity = 3, plot = true,\n\tplotSolution = (x, p;kwargs...) -> heatmap!(reshape(x[1:end-1], 2*n, M)'; ylabel=\"time\", color=:viridis, kwargs...), normC = norminf)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"A more complete diagram can be obtained combining the methods (essentially deflation and Floquet) described above. It shows the period of the periodic orbits as function of l. See example/brusselator.jl for more information.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"danger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of the eigensolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set when the computation of Floquet multipliers is requested.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"tip: Performances\nThis example is clearly not optimized because we wanted to keep it simple. We can use a Matrix-Free version of the functional and preconditioners to speed this up. Floquet multipliers could also be computed in a Matrix-Free manner. See examples/brusselator.jl for more efficient methods. See also Complex Ginzburg-Landau 2d for a more advanced example where we introduce those methods.","category":"page"},{"location":"tutorials3b/#Continuation-of-periodic-orbits-(Standard-Shooting)-1","page":"Brusselator 1d (advanced user)","title":"Continuation of periodic orbits (Standard Shooting)","text":"","category":"section"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Note that what follows is not really optimized on the DifferentialEquations.jl side. Indeed, we do not use automatic differentiation, we do not pass the sparsity pattern,...","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We now turn to a different method based on the flow of the Brusselator. To compute this flow (time stepper), we need to be able to solve the differential equation (actually a PDE) associated to the vector field Fbru. We will show how to do this with an implicit method Rodas4P from DifferentialEquations.jl. Note that the user can pass its own time stepper but for convenience, we use the ones in DifferentialEquations.jl. More information regarding the shooting method is contained in Periodic orbits based on the shooting method. To define the flow, it is better to have an inplace version of the vector field:","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"function Fbru!(f, x, p)\n\t@unpack α, β, D1, D2, l = p\n\tn = div(length(x), 2)\n\th = 1.0 / n; h2 = h*h\n\tc1 = D1 / l^2 / h2\n\tc2 = D2 / l^2 / h2\n\t\n\tu = @view x[1:n]\n\tv = @view x[n+1:2n]\n\t\n\t# Dirichlet boundary conditions\n\tf[1]   = c1 * (α\t  - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])\n\tf[end] = c2 * (v[n-1] - 2v[n] + β / α)\t\t\t + β * u[n] - f1(u[n], v[n])\n\t\n\tf[n]   = c1 * (u[n-1] - 2u[n] +  α   ) + α - (β + 1) * u[n] + f1(u[n], v[n])\n\tf[n+1] = c2 * (β / α  - 2v[1] + v[2])\t\t\t + β * u[1] - f1(u[1], v[1])\n\t\n\tfor i=2:n-1\n\t\t  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])\n\t\tf[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])\t\t\t  + β * u[i] - f1(u[i], v[i])\n\tend\n\treturn f\nend\n\nfunction Fbru(x, p)\n\tf = similar(x)\n\tFbru!(f, x, p)\nend","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We then recompute the locus of the Hopf bifurcation points using the same method as above.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"n = 100\n\n# different parameters to define the Brusselator model and guess for the stationary solution\npar_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)\nsol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))\n\neigls = EigArpack(1.1, :LM)\nopts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.00615, ds = 0.0061, pMax = 1.9, \n\tdetectBifurcation = 3, nev = 21, plotEveryStep = 50, \n\tnewtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 1060)\n\nbr, = @time continuation(Fbru, Jbru_sp,\n\tsol0, par_bru, (@lens _.l), opts_br_eq, verbosity = 0,\n\tplot = false,\n\tprintSolution = (x, p)->x[div(n,2)], normC = norminf)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We need to create a guess for the periodic orbit. We proceed as previously:","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"# number of time slices\nM = 10\n\n# index of the Hopf point in the branch br\nind_hopf = 1\n\nl_hopf, Th, orbitguess2, hopfpt, vec_hopf = guessFromHopf(br, ind_hopf, \n\topts_br_eq.newtonOptions.eigsolver, M, 22*0.05)\n\norbitguess_f2 = reduce(hcat, orbitguess2)\norbitguess_f = vcat(vec(orbitguess_f2), Th) |> vec","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Let us now initiate the Standard Shooting method. To this aim, we need to provide a guess of the periodic orbit at times TM_sh where T is the period of the cycle and M_sh is the number of slices along the periodic orbits. If M_sh = 1, this the Standard Simple Shooting and the Standard Multiple one otherwise. See ShootingProblem for more information.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"dM = 3\norbitsection = reduce(vcat, orbitguess2[1:dM:M])\n# M_sh = size(orbitsection, 2)\n\n# the last component is an estimate of the period of the cycle.\ninitpo = vcat(vec(orbitsection), 3.0)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Finally, we need to build a problem which encodes the Shooting functional. This done as follows where we first create the time stepper:","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"using DifferentialEquations, DiffEqOperators\n\nFOde(f, x, p, t) = Fbru!(f, x, p)\n\nu0 = sol0 .+ 0.01 .* rand(2n)\n\n# parameter close to the Hopf bifurcation point\npar_hopf = (@set par_bru.l = l_hopf + 0.01)\n\n# this is the ODE time stepper when used with `solve`\nprobsundials = ODEProblem(FOde, u0, (0., 1000.), par_hopf)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We create the problem:","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"# this encodes the functional for the Shooting problem\nprobSh = ShootingProblem(\n\t# pass the vector field and parameter (to be passed to the vector field)\n\tFbru, par_bru, \n\t\n\t# we pass the ODEProblem encoding the flow and the time stepper\n\tprobsundials, Rodas4P(),\n\t\n\t# this is for the phase condition, you can pass your own section as well\n\t[orbitguess_f2[:,ii] for ii=1:dM:M]; \n\t\n\t# these are options passed to the ODE time stepper\n\tatol = 1e-10, rtol = 1e-8)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We are now ready to call newton ","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"ls = GMRESIterativeSolvers(tol = 1e-7, N = length(initpo), maxiter = 100, verbose = false)\noptn_po = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 20, linsolver = ls)\noutpo, = @time newton(probSh,\n\tinitpo, par_hopf, optn_po;\n\tnormN = norminf)\nplot(initpo[1:end-1], label = \"Init guess\")\nplot!(outpo[1:end-1], label = \"sol\")","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"which gives (note that we did not have a really nice guess...)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":" Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     1.2983e-01         0\n        1                2     3.2046e-01        49\n        2                3     5.4818e-02        49\n        3                4     1.6409e-02        49\n        4                5     8.1653e-03        49\n        5                6     3.9391e-04        49\n        6                7     2.2715e-07        49\n        7                8     8.7713e-11        53\n 26.499964 seconds (33.54 M allocations: 4.027 GiB, 3.38% gc time)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"and","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Note that using Simple Shooting, the convergence is much faster. Indeed, running the code above with dM = 10 gives:","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Newton Iterations \n   Iterations      Func-count      f(x)      Linear-Iterations\n\n        0                1     3.1251e-03         0\n        1                2     4.7046e-03         6\n        2                3     1.4468e-03         7\n        3                4     2.7600e-03         8\n        4                5     2.2756e-03         8\n        5                6     7.0376e-03         8\n        6                7     5.0430e-03         8\n        7                8     1.7595e-02         8\n        8                9     2.2254e-03         7\n        9               10     2.6376e-04         7\n       10               11     1.0260e-05         7\n       11               12     1.0955e-06         8\n       12               13     6.9387e-08         7\n       13               14     4.7182e-09         7\n       14               15     2.7187e-11         7\n  3.398485 seconds (2.78 M allocations: 342.794 MiB, 1.40% gc time)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"info: Convergence and speedup\nThe convergence is much worse for the multiple shooting than for the simple one. This is reflected above in the number of linear iterations made during the newton solve. The reason for this is because of the cyclic structure of the jacobian which impedes GMRES from converging fast. This can only be resolved with an improved GMRES which we'll provide in the future.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Finally, we can perform continuation of this periodic orbit using a specialized version of continuation:","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"# note the eigensolver computes the eigenvalues of the monodromy matrix. Hence\n# the dimension of the state space for the eigensolver is 2n\nopts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 1.5, \n\tmaxSteps = 500, newtonOptions = (@set optn_po.tol = 1e-7), nev = 25,\n\tprecisionStability = 1e-8, detectBifurcation = 0)\n\nbr_po, = @time continuation(probSh,\toutpo, par_hopf, (@lens _.l),\n\topts_po_cont; verbosity = 2,\n\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> BK.plotPeriodicShooting!(x[1:end-1], length(1:dM:M); kwargs...),\n\tprintSolution = (u, p) -> u[end], normC = norminf)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We can observe that simple shooting is faster but the Floquet multipliers are less accurate than for multiple shooting. Also, when the solution is very unstable, simple shooting can have spurious branch switching. Finally, note the 0=log 1 eigenvalue of the monodromy matrix in the graph below.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#Continuation-of-periodic-orbits-(Poincaré-Shooting)-1","page":"Brusselator 1d (advanced user)","title":"Continuation of periodic orbits (Poincaré Shooting)","text":"","category":"section"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We now turn to another Shooting method, namely the Poincaré one. We can provide this method thanks to the unique functionalities of DifferentialEquations.jl. More information is provided at PoincareShootingProblem and Periodic orbits based on the shooting method but basically, it is a shooting method between Poincaré sections Sigma_i (along the orbit) defined by hyperplanes. As a consequence, the dimension of the unknowns is M_shcdot(N-1) where N is the dimension of the phase space. Indeed, each time slice lives in an hyperplane Sigma_i. Additionally, the period T is not an unknown of the method but rather a by-product. However, the method requires the time stepper to find when the flow hits an hyperplane Sigma_i, something called event detection.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We show how to use this method, the code is very similar to the case of the Standard Shooting. We first define the functional for Poincaré Shooting Problem","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"# sub-sampling factor of a initial guess for the periodic orbit\ndM = 5\n\n# vectors to define the hyperplanes Sigma_i\nnormals = [Fbru(orbitguess_f2[:,ii], par_hopf)/(norm(Fbru(orbitguess_f2[:,ii], par_hopf))) for ii = 1:dM:M]\ncenters = [orbitguess_f2[:,ii] for ii = 1:dM:M]\n\n# functional to hold the Poincare Shooting Problem\nprobHPsh = PoincareShootingProblem(\n\t# vector field and parameter\n\tFbru, par_hopf, \n\t\n\t# ODEProblem, ODE solver used to compute the flow\n\tprobsundials, Rodas4P(), \n\t\n\t# parameters for the Poincaré sections\n\tnormals, centers; \n\t\n\t# Parameters passed to the ODE solver\n\tatol = 1e-10, rtol = 1e-8)","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"Let us now compute an initial guess for the periodic orbit, it must live in the hyperplanes Sigma_i. Fortunately, we provide projections on these hyperplanes.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"hyper = probHPsh.section\n\n# variable to hold the initial guess\ninitpo_bar = zeros(size(orbitguess_f2,1)-1, length(normals))\n\n# projection of the initial guess on the hyperplanes. We assume that the centers[ii]\n# form the periodic orbit initial guess.\nfor ii=1:length(normals)\n\tinitpo_bar[:, ii] .= BK.R(hyper, centers[ii], ii)\nend","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We can now call continuation to get the first branch.","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"# eigen / linear solver\neig = EigKrylovKit(tol= 1e-12, x₀ = rand(2n-1), verbose = 0, dim = 40)\nls = GMRESIterativeSolvers(tol = 1e-11, N = length(vec(initpo_bar)), maxiter = 500, verbose = false)\n\n# newton options\t\noptn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 140, linsolver = ls)\n\n# continuation options\nopts_po_cont_floquet = ContinuationPar(dsmin = 0.0001, dsmax = 0.05, ds= 0.001, \n\tpMax = 2.5, maxSteps = 500, nev = 10, \n\tprecisionStability = 1e-5, detectBifurcation = 3, plotEveryStep = 3)\nopts_po_cont_floquet = @set opts_po_cont_floquet.newtonOptions = \n\tNewtonPar(linsolver = ls, eigsolver = eig, tol = 1e-9, verbose = true)\n\n# continuation run\nbr_po, = @time BK.continuation(probHPsh,\n\tvec(initpo_bar), par_hopf, (@lens _.l),\n\topts_po_cont_floquet; verbosity = 3,\n\tplot = true,\n\tplotSolution = (x, p; kwargs...) -> BK.plot!(x; label=\"\", kwargs...),\n\tnormC = norminf)\t\t","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"(Image: )","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"We also obtain the following information:","category":"page"},{"location":"tutorials3b/#","page":"Brusselator 1d (advanced user)","title":"Brusselator 1d (advanced user)","text":"julia> br_po\nBranch number of points: 41\nBifurcation points:\n- #  1,    bp at p ≈ 1.20987963 ∈ (1.20128196, 1.20987963), |δp|=9e-03, [converged], δ = ( 1,  0), step =  21, eigenelements in eig[ 22], ind_ev =   1\n- #  2,    ns at p ≈ 1.78687615 ∈ (1.77831727, 1.78687615), |δp|=9e-03, [converged], δ = ( 2,  2), step =  30, eigenelements in eig[ 31], ind_ev =   3\n- #  3,    pd at p ≈ 1.85103701 ∈ (1.84676466, 1.85103701), |δp|=4e-03, [converged], δ = ( 1,  1), step =  31, eigenelements in eig[ 32], ind_ev =   4\n- #  4,    ns at p ≈ 1.87667870 ∈ (1.86813520, 1.87667870), |δp|=9e-03, [converged], δ = ( 2,  2), step =  32, eigenelements in eig[ 33], ind_ev =   6\n","category":"page"},{"location":"plotting/#Plotting-1","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/#Plotting-branches-1","page":"Plotting","title":"Plotting branches","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"Plotting is provided by calling Plots.jl. It means that to plot a branch br, you just need to call ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plot(br)","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"where br is a branch computed after a call to br, = continuation(...). You can use the keywords provided by Plots.jl and the different backends. You can thus call ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"scatter(br)\nplot!(br, label = \"continuous line\")","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"The available arguments specific to our plotting methods are ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plotfold = true: plot the fold points with black dots\nputbifptlegend = true: display the legend corresponding to the bifurcation points\nplotstability = true: display the stability of the branch\nplotbifpoints = true: plot the bifurcation points on the branch\nbranchlabel = \"fold branch\": assign label to a branch which is printed in the legend\nvars = nothing: see below","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"If you have severals branches br1, br2, you can plot them in the same figure by doing ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plot(br1, br2)","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"in place of ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plot(br1)\nplot!(br2)","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"warn: Plot of bifurcation points\nThe bifurcation points for which the bisection was successful are indicated with circles and with squares otherwise.","category":"page"},{"location":"plotting/#Choosing-Variables-1","page":"Plotting","title":"Choosing Variables","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"You can select which variables to plot using the keyword argument vars:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plot(br, vars = (:param, :x))","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"The available symbols are :param, :sol, :itnewton, :ds, :theta, :step and:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"x if printSolution (see continuation) returns a Number.\nx1, x2,... if printSolution returns a Tuple.\nthe keys of the NamedTuple returned by printSolution.","category":"page"},{"location":"plotting/#Plotting-directly-using-the-field-names-1","page":"Plotting","title":"Plotting directly using the field names","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"You can define your own plotting functions using the internal fields of br which is of type ContResult. For example, the previous plot can be done as follows:","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plot(br.branch.param, br.branch.x)","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"You can also plot the spectrum at a specific continuation step::Int by calling ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"# get the eigenvalues\neigvals = br.eig[step].eigenvals\n\n# plot them in the complex plane\nscatter(real.(eigvals), imag.(eigvals))","category":"page"},{"location":"plotting/#Plotting-bifurcation-diagrams-1","page":"Plotting","title":"Plotting bifurcation diagrams","text":"","category":"section"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"To do this, you just need to call ","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"plot(diagram)","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"where diagram is a branch computed after a call to diagram, = bifurcationdiagram(...). You can use the keywords provided by Plots.jl and the different backends. You can thus call scatter(diagram). In addition to the options for plotting branches (see above), there are specific arguments available for bifurcation diagrams","category":"page"},{"location":"plotting/#","page":"Plotting","title":"Plotting","text":"code specify the part of the bifurcation diagram to plot. For example code = (1,1,) plots the part after the first branch of the first branch of the root branch.\nlevel = (-Inf, Inf) restrict the branching level for plotting.","category":"page"},{"location":"#BifurcationKit.jl-1","page":"Home","title":"BifurcationKit.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This Julia package aims at performing automatic bifurcation analysis of large dimensional equations F(u,λ)=0 where λ∈ℝ.  ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"It incorporates continuation algorithms (PALC, deflated continuation, ...) which provide a predictor (u_1p_1) from a known solution (u_0p_0). A Newton-Krylov method is then used to correct this predictor and a Matrix-Free eigensolver is used to compute stability and bifurcation points.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"By leveraging on the above method, the package can also seek for periodic orbits of Cauchy problems by casting them into an equation F(up)=0 of high dimension. It is by now, one of the only softwares which provides shooting methods AND methods based on finite differences to compute periodic orbits.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The current package focuses on large scale nonlinear problems and multiple hardwares. Hence, the goal is to use Matrix Free methods on GPU (see PDE example and Periodic orbit example) or on a cluster to solve non linear PDE, nonlocal problems, compute sub-manifolds...","category":"page"},{"location":"#","page":"Home","title":"Home","text":"One design choice is that we try not to require u to be a subtype of an AbstractArray as this would forbid the use of spectral methods like the one from ApproxFun.jl. For now, our implementation does not allow this for Hopf continuation and computation of periodic orbits. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, we leave it to the user to take advantage of automatic differentiation as this field is moving too fast for now, albeit there are several well established packages like ForwardDiff.jl and Zygote.jl to name just a few.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package requires Julia >= v1.3.0 because of the use of methods added to abstract types (see #31916).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To install it, please run","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add BifurcationKit","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To install the bleeding edge version, please run","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add BifurcationKit#master","category":"page"},{"location":"#Citing-this-work-1","page":"Home","title":"Citing this work","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you use this package for your work, please cite it!! Open source development strongly depends on this. It is referenced on HAL-Inria as follows:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@misc{veltz:hal-02902346,\n  TITLE = {{BifurcationKit.jl}},\n  AUTHOR = {Veltz, Romain},\n  URL = {https://hal.archives-ouvertes.fr/hal-02902346},\n  INSTITUTION = {{Inria Sophia-Antipolis}},\n  YEAR = {2020},\n  MONTH = Jul,\n  KEYWORDS = {pseudo-arclength-continuation ; periodic-orbits ; floquet ; gpu ; bifurcation-diagram ; deflation ; newton-krylov},\n  PDF = {https://hal.archives-ouvertes.fr/hal-02902346/file/354c9fb0d148262405609eed2cb7927818706f1f.tar.gz},\n  HAL_ID = {hal-02902346},\n  HAL_VERSION = {v1},\n}","category":"page"},{"location":"#Other-softwares-1","page":"Home","title":"Other softwares","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"There are many good softwares already available.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For regular continuation (e.g. in small dimension), most of them are listed on DSWeb. One can mention the venerable AUTO, or also, XPPAUT, MATCONT and COCO. \nFor large scale problems, there is the versatile and feature full pde2path but also Trilinos, CL_MATCONTL and the python libraries pyNCT and pacopy.\nFor deflated continuation, there is defcont.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In Julia, we have for now a wrapper to PyDSTools, and also Bifurcations.jl.","category":"page"},{"location":"#A-word-on-performance-1","page":"Home","title":"A word on performance","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The examples which follow have not all been written with the goal of performance but rather simplicity (except maybe Complex Ginzburg-Landau 2d). One could surely turn them into more efficient codes. The intricacies of PDEs make the writing of efficient code highly problem dependent and one should take advantage of every particularity of the problem under study.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For example, in the first tutorial on Temperature model (simplest example for equilibria), one could use BandedMatrices.jl for the jacobian and an inplace modification when the jacobian is called ; using a composite type would be favored. Porting them to GPU would be another option.","category":"page"},{"location":"#Main-features-1","page":"Home","title":"Main features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Newton-Krylov solver with generic linear / eigen preconditioned solver. Idem for the arc-length continuation.\nNewton-Krylov solver with nonlinear deflation and preconditioner. It can be used for branch switching for example.\nDeflated continuation\nBifurcation points are located using a bisection algorithm\nBranch, Fold, Hopf bifurcation point detection of stationary solutions.\nAutomatic branch switching at branch points (whatever the dimension of the kernel)\nAutomatic branch switching at simple Hopf points to periodic orbits\nAutomatic bifurcation diagram computation\nFold / Hopf continuation based on Minimally Augmented formulation, with Matrix Free / Sparse Jacobian.\nPeriodic orbit computation and continuation using Shooting or Finite Differences.\nBranch, Fold, Neimark-Sacker, Period Doubling bifurcation point detection of periodic orbits.\nComputation and Continuation of Fold of periodic orbits","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Custom state means, we can use something else than AbstractArray, for example your own struct.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that you can combine most of the solvers, like use Deflation for Periodic orbit computation or Fold of periodic orbits family.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Features Matrix Free Custom state Tutorial GPU\n(Deflated) Krylov-Newton Yes Yes All :heavycheckmark:\nContinuation (Natural, Secant, Tangent) Yes Yes All :heavycheckmark:\nDeflated Continuation Yes Yes :arrowheadingup: :heavycheckmark:\nBranching / Fold / Hopf point detection Yes Yes All / All / :arrowheadingup: :heavycheckmark:\nFold Point continuation Yes Yes :arrowheadingup:, :arrowheadingup: \nHopf continuation Yes AbstractArray :arrowheadingup: \nBranch switching at Branch / Hopf points Yes AbstractArray :arrowheadingup: \n<span style=\"color:red\">Automatic bifurcation diagram computation</span> Yes AbstractArray :arrowheadingup: \nPeriodic Orbit (FD) Newton / continuation Yes AbstractVector :arrowheadingup:, :arrowheadingup: :heavycheckmark:\nPeriodic Orbit with Parallel Poincaré / Standard Shooting Newton / continuation Yes AbstractArray :arrowheadingup: \nFold, Neimark-Sacker, Period doubling detection Yes AbstractVector :arrowheadingup: \nContinuation of Fold of periodic orbits Yes AbstractVector :arrowheadingup: ","category":"page"},{"location":"#Requested-methods-for-Custom-State-1","page":"Home","title":"Requested methods for Custom State","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Needless to say, if you use regular arrays, you don't need to worry about what follows.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We make the same requirements than KrylovKit.jl. Hence, we refer to its docs for more information. We additionally require the following methods to be available:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Base.length(x): it is used in the constraint equation of the pseudo arclength continuation method (see continuation for more details). If length is not available for your \"vector\", define it length(x) = 1 and adjust tuning the parameter theta in ContinuationPar.\nBase.copyto!(dest, in) this is required to reduce the allocations by avoiding too many copies","category":"page"},{"location":"tutorialCarrier/#Deflated-Continuation-in-the-Carrier-Problem-1","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"","category":"section"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"unknown: References\nChapman, S. J., and P. E. Farrell. Analysis of Carrier’s Problem. ArXiv:1609.08842 [Math], September 28, 2016. http://arxiv.org/abs/1609.08842.","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"In this example, we study the following singular perturbation problem:","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"epsilon^2 y^prime prime+2left(1-x^2right) y+y^2=1 quad y(-1)=y(1)=0tagE","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"It is a remarkably difficult problem which present many disconnected branches which are not amenable to the continuation method. We thus use the recently develiopped deflated continuatoipn method which builds upon the Deflated Newton (see Deflated problems) technics to find solutions which are different from a set of already known solutions.","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"We start with some import","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"using Revise\nusing LinearAlgebra, Parameters, Setfield, SparseArrays, BandedMatrices\n\nusing BifurcationKit, Plots\nconst BK = BifurcationKit","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"and a discretization of the problem","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"function F_carr(x, p)\n\t@unpack ϵ, X, dx = p\n\tf = similar(x)\n\tn = length(x)\n\tf[1] = x[1]\n\tf[n] = x[n]\n\tfor i=2:n-1\n\t\tf[i] = ϵ^2 * (x[i-1] - 2 * x[i] + x[i+1]) / dx^2 +\n\t\t\t2 * (1 - X[i]^2) * x[i] + x[i]^2-1\n\tend\n\treturn f\nend\n\nfunction Jac_carr(x, p)\n\t@unpack ϵ, X, dx = p\n\tn = length(x)\n\tJ = BandedMatrix{Float64}(undef, (n,n), (1,1))\n\tJ[band(-1)] .= ϵ^2/dx^2    \t\t\t\t\t\t\t\t\t# set the diagonal band\n\tJ[band(1)]  .= ϵ^2/dx^2\t\t\t\t\t\t\t\t\t\t# set the super-diagonal band\n\tJ[band(0)]  .= (-2ϵ^2 /dx^2) .+ 2 * (1 .- X.^2) .+ 2 .* x   # set the second super-diagonal band\n\tJ[1, 1] = 1.0\n\tJ[n, n] = 1.0\n\tJ[1, 2] = 0.0\n\tJ[n, n-1] = 0.0\n\tJ\nend","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"We can now use Krylov-Newton to find solutions:","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"N = 200\nX = LinRange(-1,1,N)\ndx = X[2] - X[1]\npar_car = (ϵ = 0.7, X = X, dx = dx)\nsol = -(1 .- par_car.X.^2)\n\n\noptnew = NewtonPar(tol = 1e-8, verbose = true)\n\tout, = @time newton(F_carr, Jac_carr, sol, \n\t\t(@set par_car.ϵ = 0.6), optnew, normN = x -> norm(x, Inf64))\n\tplot(out, label=\"Solution\")","category":"page"},{"location":"tutorialCarrier/#First-try-with-automatic-bifurcation-diagram-1","page":"Deflated Continuation in the Carrier Problem","title":"First try with automatic bifurcation diagram","text":"","category":"section"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"We can start by using our Automatic bifurcation method.","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"using ForwardDiff\nD(f, x, p, dx) = ForwardDiff.derivative(t -> f(x .+ t .* dx, p), 0.)\ndF_carr(x,p)         \t   =  ForwardDiff.jacobian( z-> F_carr(z,p), x)\nd1F_carr(x,p,dx1)         = D((z, p0) -> F_carr(z, p0), x, p, dx1)\nd2F_carr(x,p,dx1,dx2)     = D((z, p0) -> d1F_carr(z, p0, dx1), x, p, dx2)\nd3F_carr(x,p,dx1,dx2,dx3) = D((z, p0) -> d2F_carr(z, p0, dx1, dx2), x, p, dx3)\njet = (F_carr, Jac_carr, d2F_carr, d3F_carr)\n\noptcont = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= -0.01, pMin = 0.05, plotEveryStep = 10, newtonOptions = NewtonPar(tol = 1e-8, maxIter = 20, verbose = true), maxSteps = 300, detectBifurcation = 3, nev = 40)\n\ndiagram = bifurcationdiagram(jet..., 0*out, par_car,\n\t(@lens _.ϵ), 2,\n\t(arg...) -> @set optcont.newtonOptions.verbose = false;\n\tprintSolution = (x, p) -> (x[2] - x[1]) * sum(x.^2),\n\tplot = true)","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"However, this is a bit disappointing as we only find two branches. (Image: )","category":"page"},{"location":"tutorialCarrier/#Second-try-with-deflated-continuation-1","page":"Deflated Continuation in the Carrier Problem","title":"Second try with deflated continuation","text":"","category":"section"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"# deflation operator to hold solutions\ndeflationOp = DeflationOperator(2.0, dot, 1.0, [out])\n\n# parameter values for the problem\npar_def = @set par_car.ϵ = 0.6\n\n# newton options \noptdef = setproperties(optnew; tol = 1e-7, maxIter = 200)\n\n# function to encode a perturbation of the old solutions\nfunction perturbsol(sol, p, id)\n\t# we use this sol0 for the boundary conditions\n\tsol0 = @. exp(-.01/(1-par_car.X^2)^2)\n\tsolp = 0.02*rand(length(sol))\n\treturn sol .+ solp .* sol0\nend\n\n# call the deflated continuation method\nbr, = @time continuation(\n\tF_carr, Jac_carr,\n\tpar_def, (@lens _.ϵ),\n\tsetproperties(optcont; ds = -0.00021, dsmin=1e-5, maxSteps = 20000, \n\t\tpMax = 0.7, pMin = 0.05, detectBifurcation = 0, plotEveryStep = 40,\n\t\tnewtonOptions = setproperties(optnew; tol = 1e-9, maxIter = 100, verbose = false)),\n\tdeflationOp;\n\tperturbSolution = perturbsol,\n\tprintSolution = (x, p) -> (x[2]-x[1]) * sum(x.^2),\n\tnormN = x -> norm(x, Inf64),\n\t)\n\nplot(br...) ","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"We obtain the following result which is remarkable because it contains many more disconnected branches which we did not find in the first try.","category":"page"},{"location":"tutorialCarrier/#","page":"Deflated Continuation in the Carrier Problem","title":"Deflated Continuation in the Carrier Problem","text":"(Image: )","category":"page"},{"location":"diffeq/#Wrapper-to-the-package-DifferentialEquations.jl-1","page":"DiffEq wrapper","title":"Wrapper to the package DifferentialEquations.jl","text":"","category":"section"},{"location":"diffeq/#","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"Note that this is still work in progress.","category":"page"},{"location":"diffeq/#","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"The current package provides basic methods to wrap some of the functionality of DifferentialEquations.jl. ","category":"page"},{"location":"diffeq/#","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"Basically, the ultimate idea is that you provide a prob::ODEProblem to our newton, continuation... and they will use the expression of the jacobians, the linear solvers... that you already provided for the construction of prob.","category":"page"}]
}
