<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Temperature model (simplest example for equilibria) · Bifurcation Analysis in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Bifurcation Analysis in Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guidelines/">Overview</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (codim 2)</a></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf point</a></li></ul></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated Continuation</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problem</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><input class="collapse-toggle" id="menuitem-4-11" type="checkbox"/><label class="tocitem" for="menuitem-4-11"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Finite Differences</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen Solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Temperature model (simplest example for equilibria)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Temperature model (simplest example for equilibria)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/BifurcationKit.jl/blob/master/docs/src/tutorials1.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Temperature-model-(simplest-example-for-equilibria)-1"><a class="docs-heading-anchor" href="#Temperature-model-(simplest-example-for-equilibria)-1">Temperature model (simplest example for equilibria)</a><a class="docs-heading-anchor-permalink" href="#Temperature-model-(simplest-example-for-equilibria)-1" title="Permalink"></a></h1><ul><li><a href="#Temperature-model-(simplest-example-for-equilibria)-1">Temperature model (simplest example for equilibria)</a></li><ul><li><a href="#Continuation-of-Fold-points-1">Continuation of Fold points</a></li><li><a href="#Using-GMRES-or-another-linear-solver-1">Using GMRES or another linear solver</a></li></ul></ul><blockquote><p>This is a classical example from the <strong>Trilinos</strong> library.</p></blockquote><p>This is a simple example in which we aim at solving <span>$\Delta T+\alpha N(T,\beta)=0$</span> with boundary conditions <span>$T(0) = T(1)=\beta$</span>. This example is coded in <code>examples/chan.jl</code>. We start with some imports:</p><pre><code class="language-julia">using BifurcationKit, LinearAlgebra, Plots, Parameters, Setfield
# Setfield.jl is used to provide the parameter axis @lens
const BK = BifurcationKit

N(x; a = 0.5, b = 0.01) = 1 + (x + a*x^2)/(1 + b*x^2)</code></pre><p>We then write our functional:</p><pre><code class="language-julia">function F_chan(x, p)
	@unpack α, β = p
	f = similar(x)
	n = length(x)
	f[1] = x[1] - β
	f[n] = x[n] - β
	for i=2:n-1
		f[i] = (x[i-1] - 2 * x[i] + x[i+1]) * (n-1)^2 + α * N(x[i], b = β)
	end
	return f
end	</code></pre><p>We want to call a Newton solver. We first need an initial guess:</p><pre><code class="language-julia">n = 101
sol = [(i-1)*(n-i)/n^2+0.1 for i=1:n]

# set of parameters
par = (α = 3.3, β = 0.01)</code></pre><p>Finally, we need to provide some parameters for the Newton iterations. This is done by calling</p><pre><code class="language-julia">optnewton = NewtonPar(tol = 1e-11, verbose = true)</code></pre><p>We call the Newton solver:</p><pre><code class="language-julia">out, = @time newton( F_chan, sol, par, optnewton)</code></pre><p>and you should see</p><pre><code class="language-none"> Newton Iterations 
   Iterations      Func-count      f(x)      Linear-Iterations

        0                1     2.3440e+01         0
        1                2     1.3774e+00         1
        2                3     1.6267e-02         1
        3                4     2.4521e-06         1
        4                5     5.9356e-11         1
        5                6     5.8117e-12         1
  0.014715 seconds (2.90 k allocations: 2.555 MiB)</code></pre><p>Note that, in this case, we did not give the Jacobian. It was computed internally using Finite Differences. </p><blockquote><p>This is not as bad as it looks despite the fact that there are so many allocations even with Finite Differences Jacobian. Using <code>BenchmarkTools.jl</code>, one actually finds <code>1.153 ms (2067 allocations: 2.04 MiB)</code>. This is reasonable as we did not code the problem with much care...</p></blockquote><p>We can perform numerical continuation w.r.t. the parameter <span>$\alpha$</span>. This time, we need to provide additional parameters, but now for the continuation method:</p><pre><code class="language-julia">optcont = ContinuationPar(dsmin = 0.01, dsmax = 0.2, ds= 0.1, pMax = 4.1, newtonOptions = NewtonPar(tol = 1e-8))</code></pre><p>Next, we call the continuation routine as follows.</p><pre><code class="language-julia">br, = @time continuation(F_chan, out, par, (@lens _.α),
		optcont; plot = true, verbosity = 0,
		# function to plot the solution
		plotSolution = (x, p; k...) -&gt; plot!(x; ylabel=&quot;solution&quot;, label=&quot;&quot;, k...))</code></pre><p>The parameter axis <code>lens = @lens _.α</code> can be used to extract the component of <code>par</code> corresponding to <code>α</code>. Internally, it is used as <code>get(par, lens)</code> which returns <code>3.3</code>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We don&#39;t need to call <code>newton</code> first in order to use <code>continuation</code>.</p></div></div><p>You should see <img src="../chan-ex.png" alt/></p><p>The left figure is the norm of the solution as function of the parameter <span>$p=\alpha$</span>, the <em>y-axis</em> can be changed by passing a different <code>printSolution</code> to <code>continuation</code>. The top right figure is the value of <span>$\alpha$</span> as function of the iteration number. The bottom right is the solution for the current value of the parameter. This last plot can be modified by changing the argument <code>plotSolution</code> to <code>continuation</code>.</p><div class="admonition is-info"><header class="admonition-header">Bif. point detection</header><div class="admonition-body"><p>Two Fold points were detected. This can be seen by looking at <code>br.foldpoint</code> or by the black 	dots on the continuation plots. Note that the bifurcation points are located in <code>br.bifpoint</code>.</p></div></div><h2 id="Continuation-of-Fold-points-1"><a class="docs-heading-anchor" href="#Continuation-of-Fold-points-1">Continuation of Fold points</a><a class="docs-heading-anchor-permalink" href="#Continuation-of-Fold-points-1" title="Permalink"></a></h2><p>We get a summary of the branch by doing</p><pre><code class="language-julia">julia&gt; br
Branch number of points: 78
Branch of Equilibrium
Fold points:
- #  1,    fold at p ≈ 4.03926020, step =   6, eigenelements in eig[  6], ind_ev =   0 [    guess]
- #  2,    fold at p ≈ 3.15599445, step =  24, eigenelements in eig[ 24], ind_ev =   0 [    guess]</code></pre><p>We can take the first Fold point, which has been guessed during the previous continuation run and locate it precisely. However, this only works well when the jacobian is computed analytically. We use automatic differentiation for that</p><pre><code class="language-julia">using ForwardDiff

# Jacobian of F_chan
Jac_mat = (x,p) -&gt; ForwardDiff.jacobian(z -&gt; F_chan(z,p),x)

# index of the Fold bifurcation point in br.bifpoint
indfold = 2

outfold, _, flag = newton(F_chan, Jac_mat,
	#index of the fold point
	br, indfold)
flag &amp;&amp; printstyled(color=:red, &quot;--&gt; We found a Fold Point at α = &quot;, outfold.p, &quot;, β = 0.01, from &quot;, br.bifpoint[indfold].param,&quot;\n&quot;)</code></pre><p>which gives</p><pre><code class="language-julia">--&gt; We found a Fold Point at α = 3.1556507316107947, β = 0.01, from 3.155651011218501</code></pre><p>We can finally continue this fold point in the plane <span>$(a,b)$</span> by performing a Fold Point continuation. In the present case, we find a Cusp point.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We don&#39;t need to call <code>newton</code> first in order to use <code>continuation</code> for the codim 2 curve of bifurcation points.</p></div></div><pre><code class="language-julia">optcontfold = ContinuationPar(dsmin = 0.001, dsmax = 0.05,ds= 0.01, pMax = 4.1, pMin = 0.)
	outfoldco, = @time continuation(
		F_chan, Jac_mat,
		br, indfold, 
		# parameter axis to trace to codim 2 curve
		(@lens _.β),
		plot = true, verbosity = 2, optcontfold)
plot(outfoldco)</code></pre><p>This produces:</p><p><img src="../chan-cusp.png" alt/></p><h2 id="Using-GMRES-or-another-linear-solver-1"><a class="docs-heading-anchor" href="#Using-GMRES-or-another-linear-solver-1">Using GMRES or another linear solver</a><a class="docs-heading-anchor-permalink" href="#Using-GMRES-or-another-linear-solver-1" title="Permalink"></a></h2><p>We continue the previous example but now using Matrix Free methods. The user can pass its own solver by implementing a version of <code>LinearSolver</code>. Some linear solvers have been implemented from <code>KrylovKit.jl</code> and <code>IterativeSolvers.jl</code> (see <a href="../linearsolver/#Linear-solvers-(LS)-1">Linear solvers (LS)</a> for more information), we can use them here. Note that we can also use preconditioners as shown below. The same functionality is present for the eigensolver.</p><pre><code class="language-julia"># derivative of N
dN(x; a = 0.5, b = 0.01) = (1-b*x^2+2*a*x)/(1+b*x^2)^2

# Matrix Free version of the differential of F_chan
# Very easy to write since we have F_chan. 
# We could use Automatic Differentiation as well
function dF_chan(x, dx, p)
	@unpack α, β = p
	out = similar(x)
	n = length(x)
	out[1] = dx[1]
	out[n] = dx[n]
	for i=2:n-1
		out[i] = (dx[i-1] - 2 * dx[i] + dx[i+1]) * (n-1)^2 + α * dN(x[i], b = β) * dx[i]
	end
	return out
end

# we create a new linear solver
ls = GMRESKrylovKit(dim = 100)

# and pass it to the newton parameters
optnewton_mf = NewtonPar(verbose = true, linsolver = ls)

# we can then call the newton solver
out_mf, = @time newton(
	F_chan,
	# we pass the differential a x, 
	# which is a linear operator in dx
	(x, p) -&gt; (dx -&gt; dF_chan(x, dx, p)),
	sol, par,
	optnewton_mf)</code></pre><p>which gives:</p><pre><code class="language-julia"> Newton Iterations 
   Iterations      Func-count      f(x)      Linear-Iterations

        0                1     2.3440e+01         0
        1                2     1.3774e+00        68
        2                3     1.6267e-02        98
        3                4     2.4336e-06        73
        4                5     6.2617e-12        73
	0.323253 seconds (1.07 M allocations: 50.779 MiB)</code></pre><p>We can improve this computation, <em>i.e.</em> reduce the number of <code>Linear-Iterations</code>, by using a preconditioner</p><pre><code class="language-julia">using SparseArrays

# define preconditioner which is basically Δ
P = spdiagm(0 =&gt; -2 * (n-1)^2 * ones(n), -1 =&gt; (n-1)^2 * ones(n-1), 1 =&gt; (n-1)^2 * ones(n-1))
P[1,1:2] .= [1, 0.];P[end,end-1:end] .= [0, 1.]

# define gmres solver with left preconditioner
ls = GMRESIterativeSolvers(tol = 1e-4, N = length(sol), restart = 10, maxiter = 10, Pl = lu(P))
	optnewton_mf = NewtonPar(verbose = true, linsolver = ls)
	out_mf, = @time newton(F_chan,
	(x, p) -&gt; (dx -&gt; dF_chan(x, dx, p)),
	sol, par, optnewton_mf)</code></pre><p>which gives</p><pre><code class="language-julia"> Newton Iterations
   Iterations      Func-count      f(x)      Linear-Iterations

        0                1     2.3440e+01         0
        1                2     1.3777e+00         3
        2                3     1.6266e-02         3
        3                4     2.3699e-05         2
        4                5     4.8930e-09         3
        5                6     6.3288e-12         4</code></pre></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 11 March 2021 08:03">Thursday 11 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
