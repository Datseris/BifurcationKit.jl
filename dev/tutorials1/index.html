<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1/ Temperature model · Pseudo Arc Length Continuation in Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Pseudo Arc Length Continuation in Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>1/ Temperature model</a><ul class="internal"><li><a class="tocitem" href="#Continuation-of-Fold-points-1"><span>Continuation of Fold points</span></a></li><li><a class="tocitem" href="#Using-GMRES-or-another-linear-solver-1"><span>Using GMRES or another linear solver</span></a></li></ul></li><li><a class="tocitem" href="../tutorials1b/">2/ Temperature model with Spectral Collocation</a></li><li><a class="tocitem" href="../tutorials2/">3/ Swift-Hohenberg</a></li><li><a class="tocitem" href="../tutorials2b/">4/ The Swift-Hohenberg on the GPU (non-local)</a></li><li><a class="tocitem" href="../tutorials3/">5/ Brusselator 1d</a></li><li><a class="tocitem" href="../tutorialsPD/">6/ Period Doubling in BVAM model</a></li><li><a class="tocitem" href="../tutorialsCGL/">7/ Ginzburg-Landau 2d (GPU)</a></li><li><a class="tocitem" href="../tutorialsCGLShoot/">8/ Ginzburg-Landau 2d (Shooting)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../linearsolver/">Linear / Eigen Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../detectionBifurcation/">Bifurcations</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problem</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><input class="collapse-toggle" id="menuitem-3-8" type="checkbox"/><label class="tocitem" for="menuitem-3-8"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitFD/">Finite Differences</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>1/ Temperature model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1/ Temperature model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/PseudoArcLengthContinuation.jl/blob/master/docs/src/tutorials1.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Temperature-model-1"><a class="docs-heading-anchor" href="#Temperature-model-1">Temperature model</a><a class="docs-heading-anchor-permalink" href="#Temperature-model-1" title="Permalink"></a></h1><blockquote><p>This is a classical example from the <strong>Trilinos</strong> library.</p></blockquote><p>This is a simple example in which we aim at solving <span>$\Delta T+\alpha N(T,\beta)=0$</span> with boundary conditions <span>$T(0) = T(1)=\beta$</span>. This example is coded in <code>examples/chan.jl</code>. We start with some imports:</p><pre><code class="language-julia">using PseudoArcLengthContinuation, LinearAlgebra, Plots
const PALC = PseudoArcLengthContinuation

N(x; a = 0.5, b = 0.01) = 1 + (x + a*x^2)/(1 + b*x^2)</code></pre><p>We then write our functional:</p><pre><code class="language-julia">function F_chan(x, α, β = 0.01)
	f = similar(x)
	n = length(x)
	f[1] = x[1] - β
	f[n] = x[n] - β
	for i=2:n-1
		f[i] = (x[i-1] - 2 * x[i] + x[i+1]) * (n-1)^2 + α * N(x[i], b = β)
	end
	return f
end</code></pre><p>We want to call a Newton solver. We first need an initial guess:</p><pre><code class="language-julia">n = 101
sol = [(i-1)*(n-i)/n^2+0.1 for i=1:n]</code></pre><p>Finally, we need to provide some parameters for the Newton iterations. This is done by calling</p><pre><code class="language-julia">optnewton = NewtonPar(verbose = true)</code></pre><p>We call the Newton solver:</p><pre><code class="language-julia">out, _, _ = @time newton(
		x -&gt; F_chan(x, 3.3),
		sol, optnewton)</code></pre><p>and you should see</p><pre><code class="language-none"> Newton Iterations 
   Iterations      Func-count      f(x)      Linear-Iterations

        0                1     2.3440e+01         0
        1                2     1.3774e+00         1
        2                3     1.6267e-02         1
        3                4     2.4521e-06         1
        4                5     5.9356e-11         1
  0.125980 seconds (117.21 k allocations: 7.438 MiB)</code></pre><p>Note that, in this case, we did not give the Jacobian. It was computed internally using Finite Differences. </p><blockquote><p>This is not as bad as it looks despite the fact that there are so many allocations even with Finite Differences Jacobian. Using <code>BenchmarkTools.jl</code>, one actually finds <code>1.153 ms (2067 allocations: 2.04 MiB)</code>. This is reasonable as we did not code the problem with much care...</p></blockquote><p>We can perform numerical continuation w.r.t. the parameter <span>$\alpha$</span>. This time, we need to provide additional parameters, but now for the continuation method:</p><pre><code class="language-julia">optcont = ContinuationPar(dsmin = 0.01, dsmax = 0.15, ds= 0.01, pMax = 4.1, newtonOptions = NewtonPar(tol = 1e-9))</code></pre><p>Next, we call the continuation routine</p><pre><code class="language-julia">br, _ = continuation((x, p) -&gt; F_chan(x, p),
	out, 3.3, optcont, plot = true,
	plotSolution = (x, p;kwargs...) -&gt; (plot!(x; ylabel=&quot;solution&quot;,label=&quot;&quot;,kwargs...)))</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We don&#39;t need to call <code>newton</code> first in order to use <code>continuation</code>.</p></div></div><p>You should see <img src="../chan-ex.png" alt/></p><p>The left figure is the norm of the solution as function of the parameter <span>$p=\alpha$</span>, the <em>y-axis</em> can be changed by passing a different <code>printSolution</code> to <code>continuation</code>. The top right figure is the value of <span>$\alpha$</span> as function of the iteration number. The bottom right is the solution for the current value of the parameter. This last plot can be modified by changing the argument <code>plotSolution</code> to <code>continuation</code>.</p><div class="admonition is-info"><header class="admonition-header">Bif. point detection</header><div class="admonition-body"><p>Two Fold points were detected. This can be seen by looking at <code>br.foldpoint</code> or by the black 	dots on the continuation plots. Note that the bifurcation points are located in <code>br.bifpoint</code>.</p></div></div><h2 id="Continuation-of-Fold-points-1"><a class="docs-heading-anchor" href="#Continuation-of-Fold-points-1">Continuation of Fold points</a><a class="docs-heading-anchor-permalink" href="#Continuation-of-Fold-points-1" title="Permalink"></a></h2><p>We get a summary of the branch by doing</p><pre><code class="language-julia">julia&gt; br
Branch number of points: 78
Fold points:
-   1,    fold point around p ≈ 4.03439121, step =  11, idx =  11, ind_bif =   0
-   2,    fold point around p ≈ 3.15581463, step =  35, idx =  35, ind_bif =   0</code></pre><p>We can take the first Fold point, which has been guessed during the previous continuation run and locate it precisely. However, this only works well when the jacobian is computed analytically:</p><pre><code class="language-julia"># derivative of N
dN(x; a = 0.5, b = 0.01) = (1-b*x^2+2*a*x)/(1+b*x^2)^2

# Jacobian of F_chan
function Jac_mat(u, α, β = 0.01)
	n = length(u)
	J = zeros(n, n)
	J[1, 1] = 1.0
	J[n, n] = 1.0
	for i = 2:n-1
		J[i, i-1] = (n-1)^2
		J[i, i+1] = (n-1)^2
		J[i, i] = -2 * (n-1)^2 + α * dN(u[i], b = β)
	end
	return J
end

# index of the Fold bifurcation point in br.bifpoint
indfold = 2

outfold, _, flag = newtonFold(
		(x, α) -&gt; F_chan(x, α),
		(x, α) -&gt; Jac_mat(x, α),
		br, indfold, #index of the fold point
		optcont.newtonOptions)
flag &amp;&amp; printstyled(color=:red, &quot;--&gt; We found a Fold Point at α = &quot;, outfold.p, &quot;, β = 0.01, from &quot;, br.foldpoint[indfold].param, &quot;\n&quot;)</code></pre><p>which gives</p><pre><code class="language-julia">--&gt; We found a Fold Point at α = 3.1556507316107947, β = 0.01, from 3.155651011218501</code></pre><p>We can finally continue this fold point in the plane <span>$(a,b)$</span> by performing a Fold Point continuation. In the present case, we find a Cusp point.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We don&#39;t need to call <code>newtonFold</code> first in order to use <code>continuationFold</code>.</p></div></div><pre><code class="language-julia">optcontfold = ContinuationPar(dsmin = 0.001, dsmax = 0.05,ds= 0.01, pMax = 4.1, pMin = 0.)
	outfoldco, _, _ = @time continuationFold(
		(x, α, β) -&gt;  F_chan(x, α, β),
		(x, α, β) -&gt; Jac_mat(x, α, β),
		br, indfold,
		0.01,
		optcontfold)

plot(outfoldco; xlabel=&quot;beta&quot;, ylabel=&quot;alpha&quot;)</code></pre><p>This produces:</p><p><img src="../chan-cusp.png" alt/></p><h2 id="Using-GMRES-or-another-linear-solver-1"><a class="docs-heading-anchor" href="#Using-GMRES-or-another-linear-solver-1">Using GMRES or another linear solver</a><a class="docs-heading-anchor-permalink" href="#Using-GMRES-or-another-linear-solver-1" title="Permalink"></a></h2><p>We continue the previous example but now using Matrix Free methods. The user can pass its own solver by implementing a version of <code>LinearSolver</code>. Some linear solvers have been implemented from <code>KrylovKit.jl</code> and <code>IterativeSolvers.jl</code> (see <a href="../linearsolver/#Linear-solvers-1">Linear solvers</a> for more information), we can use them here. Note that we can also use preconditioners as shown below. The same functionality is present for the eigensolver.</p><pre><code class="language-julia"># Matrix Free version of the differential of F_chan
# Very easy to write since we have F_chan. 
# We could use Automatic Differentiation as well
function dF_chan(x, dx, α, β = 0.01)
	out = similar(x)
	n = length(x)
	out[1] = dx[1]
	out[n] = dx[n]
	for i=2:n-1
		out[i] = (dx[i-1] - 2 * dx[i] + dx[i+1]) * (n-1)^2 + α * dN(x[i], b = β) * dx[i]
	end
	return out
end

# we create a new linear solver
ls = GMRESKrylovKit(dim = 100)

# and pass it to the newton parameters
optnewton_mf = NewtonPar(verbose = true, linsolver = ls)

# we can then call the newton solver
out_mf, _, _ = @time newton(
	x -&gt; F_chan(x, 3.3),
	# we pass the differential a x, 
	# which is a linear operator in dx
	x -&gt; (dx -&gt; dF_chan(x, dx, 3.3)),
	sol,
	optnewton_mf)</code></pre><p>which gives:</p><pre><code class="language-julia"> Newton Iterations 
   Iterations      Func-count      f(x)      Linear-Iterations

        0                1     2.3440e+01         0
        1                2     1.3774e+00        68
        2                3     1.6267e-02        98
        3                4     2.4336e-06        73
        4                5     6.2617e-12        73
	0.323253 seconds (1.07 M allocations: 50.779 MiB)</code></pre><p>We can improve this computation, <em>i.e.</em> reduce the number of <code>Linear-Iterations</code>, by using a preconditioner</p><pre><code class="language-julia">using SparseArrays

# define preconditioner which is basically Δ
P = spdiagm(0 =&gt; -2 * (n-1)^2 * ones(n), -1 =&gt; (n-1)^2 * ones(n-1), 1 =&gt; (n-1)^2 * ones(n-1))
P[1,1:2] .= [1, 0.];P[end,end-1:end] .= [0, 1.]

# define gmres solver with left preconditioner
ls = GMRESIterativeSolvers(tol = 1e-4, N = length(sol), restart = 10, maxiter = 10, Pl = lu(P))
	optnewton_mf = NewtonPar(verbose = true, linsolver = ls)
	out_mf, _, _ = @time newton(
		x -&gt; F_chan(x, 3.3),
		x -&gt; (dx -&gt; dF_chan(x, dx, 3.3)),
		sol,
		optnewton_mf)</code></pre><p>which gives</p><pre><code class="language-julia"> Newton Iterations
   Iterations      Func-count      f(x)      Linear-Iterations

        0                1     2.3440e+01         0
        1                2     1.3777e+00         3
        2                3     1.6266e-02         3
        3                4     2.3699e-05         2
        4                5     4.8930e-09         3
        5                6     6.3288e-12         4</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../tutorials1b/">2/ Temperature model with Spectral Collocation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 21 April 2020 07:38">Tuesday 21 April 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
